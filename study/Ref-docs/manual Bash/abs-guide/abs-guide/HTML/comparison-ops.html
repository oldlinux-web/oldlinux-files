<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>Comparison operators (binary)</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.64
"><LINK
REL="HOME"
TITLE="Advanced Bash-Scripting Guide"
HREF="index.html"><LINK
REL="UP"
TITLE="Tests"
HREF="tests.html"><LINK
REL="PREVIOUS"
TITLE="File test operators"
HREF="fto.html"><LINK
REL="NEXT"
TITLE="Nested if/then Condition Tests"
HREF="nestedifthen.html"><META
HTTP-EQUIV="Content-Style-Type"
CONTENT="text/css"><LINK
REL="stylesheet"
HREF="common/kde-common.css"
TYPE="text/css"><META
HTTP-EQUIV="Content-Type"
CONTENT="text/html; charset=iso-8859-1"><META
HTTP-EQUIV="Content-Language"
CONTENT="en"><LINK
REL="stylesheet"
HREF="common/kde-localised.css"
TYPE="text/css"
TITLE="KDE-English"><LINK
REL="stylesheet"
HREF="common/kde-default.css"
TYPE="text/css"
TITLE="KDE-Default"></HEAD
><BODY
CLASS="SECT1"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#AA0000"
VLINK="#AA0055"
ALINK="#AA0000"
STYLE="font-family: sans-serif;"
><DIV
CLASS="NAVHEADER"
><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TH
COLSPAN="3"
ALIGN="center"
>Advanced Bash-Scripting Guide: An in-depth exploration of the art of shell scripting</TH
></TR
><TR
><TD
WIDTH="10%"
ALIGN="left"
VALIGN="bottom"
><A
HREF="fto.html"
>Prev</A
></TD
><TD
WIDTH="80%"
ALIGN="center"
VALIGN="bottom"
>Chapter 7. Tests</TD
><TD
WIDTH="10%"
ALIGN="right"
VALIGN="bottom"
><A
HREF="nestedifthen.html"
>Next</A
></TD
></TR
></TABLE
><HR
ALIGN="LEFT"
WIDTH="100%"></DIV
><DIV
CLASS="SECT1"
><H1
CLASS="SECT1"
><A
NAME="COMPARISON-OPS"
>7.3. Comparison operators (binary)</A
></H1
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="ICOMPARISON1"
></A
>integer comparison</B
></P
><DL
><DT
><SPAN
CLASS="TOKEN"
>-eq</SPAN
></DT
><DD
><P
><A
NAME="EQUALREF"
></A
></P
><P
>is equal to</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" -eq "$b" ]</B
></TT
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>-ne</SPAN
></DT
><DD
><P
>is not equal to</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" -ne "$b" ]</B
></TT
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>-gt</SPAN
></DT
><DD
><P
>is greater than</P
><P
><TT
CLASS="USERINPUT"
><B
>if ["$a" -gt "$b" ]</B
></TT
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>-ge</SPAN
></DT
><DD
><P
>is greater than or equal to</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" -ge "$b" ]</B
></TT
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>-lt</SPAN
></DT
><DD
><P
>is less than</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" -lt "$b" ]</B
></TT
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>-le</SPAN
></DT
><DD
><P
>is less than or equal to</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" -le "$b" ]</B
></TT
></P
></DD
><DT
><A
NAME="INTLT"
></A
><SPAN
CLASS="TOKEN"
>&#60;</SPAN
></DT
><DD
><P
>is less than (within <A
HREF="dblparens.html"
>double
	      parentheses</A
>)</P
><P
><TT
CLASS="USERINPUT"
><B
>(("$a" &#60; "$b"))</B
></TT
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#60;=</SPAN
></DT
><DD
><P
>is less than or equal to (within double parentheses)</P
><P
><TT
CLASS="USERINPUT"
><B
>(("$a" &#60;= "$b"))</B
></TT
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#62;</SPAN
></DT
><DD
><P
>is greater than (within double parentheses)</P
><P
><TT
CLASS="USERINPUT"
><B
>(("$a" &#62; "$b"))</B
></TT
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>&#62;=</SPAN
></DT
><DD
><P
>is greater than or equal to (within double parentheses)</P
><P
><TT
CLASS="USERINPUT"
><B
>(("$a" &#62;= "$b"))</B
></TT
></P
></DD
></DL
></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="SCOMPARISON1"
></A
>string comparison</B
></P
><DL
><DT
><SPAN
CLASS="TOKEN"
>=</SPAN
></DT
><DD
><P
><A
NAME="EQUALSIGNREF"
></A
></P
><P
>is equal to</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" = "$b" ]</B
></TT
></P
></DD
><DT
><SPAN
CLASS="TOKEN"
>==</SPAN
></DT
><DD
><P
>is equal to</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" == "$b" ]</B
></TT
></P
><P
>This is a synonym for <SPAN
CLASS="TOKEN"
>=</SPAN
>.</P
><P
>	      <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="90%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;[[ $a == z* ]]    # true if $a starts with an "z" (pattern matching)
   2&nbsp;[[ $a == "z*" ]]  # true if $a is equal to z*
   3&nbsp;
   4&nbsp;[ $a == z* ]      # file globbing and word splitting take place
   5&nbsp;[ "$a" == "z*" ]  # true if $a is equal to z*
   6&nbsp;
   7&nbsp;# Thanks, S.C.</PRE
></TD
></TR
></TABLE
>
              </P
></DD
><DT
><SPAN
CLASS="TOKEN"
>!=</SPAN
></DT
><DD
><P
>is not equal to</P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" != "$b" ]</B
></TT
></P
><P
>This operator uses pattern matching within a <A
HREF="tests.html#DBLBRACKETS"
>[[ ... ]]</A
> construct.</P
></DD
><DT
><A
NAME="LTREF"
></A
><SPAN
CLASS="TOKEN"
>&#60;</SPAN
></DT
><DD
><P
>is less than, in ASCII alphabetical order</P
><P
><TT
CLASS="USERINPUT"
><B
>if [[ "$a" &#60; "$b" ]]</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" \&#60; "$b" ]</B
></TT
></P
><P
>Note that the <SPAN
CLASS="QUOTE"
>"&#60;"</SPAN
> needs to be
	      escaped within a <TT
CLASS="USERINPUT"
><B
>[  ]</B
></TT
>
	      construct.</P
></DD
><DT
><A
NAME="GTREF"
></A
><SPAN
CLASS="TOKEN"
>&#62;</SPAN
></DT
><DD
><P
>is greater than, in ASCII alphabetical order</P
><P
><TT
CLASS="USERINPUT"
><B
>if [[ "$a" &#62; "$b" ]]</B
></TT
></P
><P
><TT
CLASS="USERINPUT"
><B
>if [ "$a" \&#62; "$b" ]</B
></TT
></P
><P
>Note that the <SPAN
CLASS="QUOTE"
>"&#62;"</SPAN
> needs to be
	      escaped within a <TT
CLASS="USERINPUT"
><B
>[  ]</B
></TT
> construct.</P
><P
>See <A
HREF="arrays.html#BUBBLE"
>Example 26-4</A
> for an application of this
	      comparison operator.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>-z</SPAN
></DT
><DD
><P
>string is <SPAN
CLASS="QUOTE"
>"null"</SPAN
>, that is, has zero length</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>-n</SPAN
></DT
><DD
><P
>string is not <SPAN
CLASS="QUOTE"
>"null"</SPAN
>.</P
><DIV
CLASS="CAUTION"
><TABLE
CLASS="CAUTION"
WIDTH="90%"
BORDER="0"
><TR
><TD
WIDTH="25"
ALIGN="CENTER"
VALIGN="TOP"
><IMG
SRC="common/caution.png"
HSPACE="5"
ALT="Caution"></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
><P
>The <TT
CLASS="USERINPUT"
><B
>-n</B
></TT
> test absolutely
		requires that the string be quoted within the
		test brackets. Using an unquoted string with
		<TT
CLASS="USERINPUT"
><B
>! -z</B
></TT
>, or even just the
		unquoted string alone within test brackets (see <A
HREF="comparison-ops.html#STRTEST"
>Example 7-5</A
>) normally works, however, this is
		an unsafe practice. <I
CLASS="EMPHASIS"
>Always</I
> quote
		a tested string.
		  <A
NAME="AEN2304"
HREF="#FTN.AEN2304"
>[1]</A
>
		</P
></TD
></TR
></TABLE
></DIV
></DD
></DL
></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX13"
></A
><P
><B
>Example 7-4. arithmetic and string comparisons</B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;a=4
   4&nbsp;b=5
   5&nbsp;
   6&nbsp;#  Here "a" and "b" can be treated either as integers or strings.
   7&nbsp;#  There is some blurring between the arithmetic and string comparisons,
   8&nbsp;#+ since Bash variables are not strongly typed.
   9&nbsp;
  10&nbsp;#  Bash permits integer operations and comparisons on variables
  11&nbsp;#+ whose value consists of all-integer characters.
  12&nbsp;#  Caution advised.
  13&nbsp;
  14&nbsp;if [ "$a" -ne "$b" ]
  15&nbsp;then
  16&nbsp;  echo "$a is not equal to $b"
  17&nbsp;  echo "(arithmetic comparison)"
  18&nbsp;fi
  19&nbsp;
  20&nbsp;echo
  21&nbsp;
  22&nbsp;if [ "$a" != "$b" ]
  23&nbsp;then
  24&nbsp;  echo "$a is not equal to $b."
  25&nbsp;  echo "(string comparison)"
  26&nbsp;fi
  27&nbsp;
  28&nbsp;# In this instance, both "-ne" and "!=" work.
  29&nbsp;
  30&nbsp;echo
  31&nbsp;
  32&nbsp;exit 0</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="STRTEST"
></A
><P
><B
>Example 7-5. testing whether a string is <I
CLASS="EMPHASIS"
>null</I
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;# str-test.sh: Testing null strings and unquoted strings,
   3&nbsp;# but not strings and sealing wax, not to mention cabbages and kings...
   4&nbsp;
   5&nbsp;# Using   if [ ... ]
   6&nbsp;
   7&nbsp;
   8&nbsp;# If a string has not been initialized, it has no defined value.
   9&nbsp;# This state is called "null" (not the same as zero).
  10&nbsp;
  11&nbsp;if [ -n $string1 ]    # $string1 has not been declared or initialized.
  12&nbsp;then
  13&nbsp;  echo "String \"string1\" is not null."
  14&nbsp;else  
  15&nbsp;  echo "String \"string1\" is null."
  16&nbsp;fi  
  17&nbsp;# Wrong result.
  18&nbsp;# Shows $string1 as not null, although it was not initialized.
  19&nbsp;
  20&nbsp;
  21&nbsp;echo
  22&nbsp;
  23&nbsp;
  24&nbsp;# Lets try it again.
  25&nbsp;
  26&nbsp;if [ -n "$string1" ]  # This time, $string1 is quoted.
  27&nbsp;then
  28&nbsp;  echo "String \"string1\" is not null."
  29&nbsp;else  
  30&nbsp;  echo "String \"string1\" is null."
  31&nbsp;fi      # Quote strings within test brackets!
  32&nbsp;
  33&nbsp;
  34&nbsp;echo
  35&nbsp;
  36&nbsp;
  37&nbsp;if [ $string1 ]       # This time, $string1 stands naked.
  38&nbsp;then
  39&nbsp;  echo "String \"string1\" is not null."
  40&nbsp;else  
  41&nbsp;  echo "String \"string1\" is null."
  42&nbsp;fi  
  43&nbsp;# This works fine.
  44&nbsp;# The [ ] test operator alone detects whether the string is null.
  45&nbsp;# However it is good practice to quote it ("$string1").
  46&nbsp;#
  47&nbsp;# As Stephane Chazelas points out,
  48&nbsp;#    if [ $string 1 ]   has one argument, "]"
  49&nbsp;#    if [ "$string 1" ]  has two arguments, the empty "$string1" and "]" 
  50&nbsp;
  51&nbsp;
  52&nbsp;
  53&nbsp;echo
  54&nbsp;
  55&nbsp;
  56&nbsp;
  57&nbsp;string1=initialized
  58&nbsp;
  59&nbsp;if [ $string1 ]       # Again, $string1 stands naked.
  60&nbsp;then
  61&nbsp;  echo "String \"string1\" is not null."
  62&nbsp;else  
  63&nbsp;  echo "String \"string1\" is null."
  64&nbsp;fi  
  65&nbsp;# Again, gives correct result.
  66&nbsp;# Still, it is better to quote it ("$string1"), because...
  67&nbsp;
  68&nbsp;
  69&nbsp;string1="a = b"
  70&nbsp;
  71&nbsp;if [ $string1 ]       # Again, $string1 stands naked.
  72&nbsp;then
  73&nbsp;  echo "String \"string1\" is not null."
  74&nbsp;else  
  75&nbsp;  echo "String \"string1\" is null."
  76&nbsp;fi  
  77&nbsp;# Not quoting "$string1" now gives wrong result!
  78&nbsp;
  79&nbsp;exit 0
  80&nbsp;# Also, thank you, Florian Wisser, for the "heads-up".</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="EXAMPLE"
><HR><A
NAME="EX14"
></A
><P
><B
>Example 7-6. <B
CLASS="COMMAND"
>zmost</B
></B
></P
><TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;#!/bin/bash
   2&nbsp;
   3&nbsp;#View gzipped files with 'most'
   4&nbsp;
   5&nbsp;NOARGS=65
   6&nbsp;NOTFOUND=66
   7&nbsp;NOTGZIP=67
   8&nbsp;
   9&nbsp;if [ $# -eq 0 ] # same effect as:  if [ -z "$1" ]
  10&nbsp;# $1 can exist, but be empty:  zmost "" arg2 arg3
  11&nbsp;then
  12&nbsp;  echo "Usage: `basename $0` filename" &#62;&#38;2
  13&nbsp;  # Error message to stderr.
  14&nbsp;  exit $NOARGS
  15&nbsp;  # Returns 65 as exit status of script (error code).
  16&nbsp;fi  
  17&nbsp;
  18&nbsp;filename=$1
  19&nbsp;
  20&nbsp;if [ ! -f "$filename" ]   # Quoting $filename allows for possible spaces.
  21&nbsp;then
  22&nbsp;  echo "File $filename not found!" &#62;&#38;2
  23&nbsp;  # Error message to stderr.
  24&nbsp;  exit $NOTFOUND
  25&nbsp;fi  
  26&nbsp;
  27&nbsp;if [ ${filename##*.} != "gz" ]
  28&nbsp;# Using bracket in variable substitution.
  29&nbsp;then
  30&nbsp;  echo "File $1 is not a gzipped file!"
  31&nbsp;  exit $NOTGZIP
  32&nbsp;fi  
  33&nbsp;
  34&nbsp;zcat $1 | most
  35&nbsp;
  36&nbsp;# Uses the file viewer 'most' (similar to 'less').
  37&nbsp;# Later versions of 'most' have file decompression capabilities.
  38&nbsp;# May substitute 'more' or 'less', if desired.
  39&nbsp;
  40&nbsp;
  41&nbsp;exit $?   # Script returns exit status of pipe.
  42&nbsp;# Actually "exit $?" unnecessary, as the script will, in any case,
  43&nbsp;# return the exit status of the last command executed.</PRE
></TD
></TR
></TABLE
><HR></DIV
><DIV
CLASS="VARIABLELIST"
><P
><B
><A
NAME="CCOMPARISON1"
></A
>compound comparison</B
></P
><DL
><DT
><SPAN
CLASS="TOKEN"
>-a</SPAN
></DT
><DD
><P
>logical and</P
><P
><TT
CLASS="REPLACEABLE"
><I
>exp1 -a exp2</I
></TT
> returns true if
		<I
CLASS="EMPHASIS"
>both</I
> exp1 and exp2 are true.</P
></DD
><DT
><SPAN
CLASS="TOKEN"
>-o</SPAN
></DT
><DD
><P
>logical or </P
><P
><TT
CLASS="REPLACEABLE"
><I
>exp1 -o exp2</I
></TT
> returns
		true if either exp1 <I
CLASS="EMPHASIS"
>or</I
> exp2 are
		true.</P
></DD
></DL
></DIV
><P
>These are similar to the Bash comparison operators
	 <B
CLASS="COMMAND"
>&#38;&#38;</B
> and <B
CLASS="COMMAND"
>||</B
>, used
	 within <A
HREF="tests.html#DBLBRACKETS"
>double brackets</A
>.
	   <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;[[ condition1 &#38;&#38; condition2 ]]</PRE
></TD
></TR
></TABLE
>
	 The <B
CLASS="COMMAND"
>-o</B
> and <B
CLASS="COMMAND"
>-a</B
> operators
	 work with the <B
CLASS="COMMAND"
>test</B
> command or occur within
	 single test brackets.
	   <TABLE
BORDER="0"
BGCOLOR="#E0E0E0"
WIDTH="100%"
><TR
><TD
><PRE
CLASS="PROGRAMLISTING"
>   1&nbsp;if [ "$exp1" -a "$exp2" ]</PRE
></TD
></TR
></TABLE
>
	   </P
><P
>Refer to <A
HREF="operations.html#ANDOR"
>Example 8-3</A
> and <A
HREF="arrays.html#TWODIM"
>Example 26-8</A
>
	 to see compound comparison operators in action.</P
></DIV
><H3
CLASS="FOOTNOTES"
>Notes</H3
><TABLE
BORDER="0"
CLASS="FOOTNOTES"
WIDTH="100%"
><TR
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="5%"
><A
NAME="FTN.AEN2304"
HREF="comparison-ops.html#AEN2304"
>[1]</A
></TD
><TD
ALIGN="LEFT"
VALIGN="TOP"
WIDTH="95%"
><P
>As S.C. points out, in a compound test,
		    even quoting the string variable might not
		    suffice. <TT
CLASS="USERINPUT"
><B
>[ -n "$string" -o "$a" =
		    "$b" ]</B
></TT
> may cause an error with some
		    versions of Bash if <TT
CLASS="VARNAME"
>$string</TT
>
		    is empty.  The safe way is to append an extra
		    character to possibly empty variables, <TT
CLASS="USERINPUT"
><B
>[
		    "x$string" != x -o "x$a" = "x$b" ]</B
></TT
>
		    (the <SPAN
CLASS="QUOTE"
>"x's"</SPAN
> cancel out).</P
></TD
></TR
></TABLE
><DIV
CLASS="NAVFOOTER"
><HR
ALIGN="LEFT"
WIDTH="100%"><TABLE
WIDTH="100%"
BORDER="0"
CELLPADDING="0"
CELLSPACING="0"
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
><A
HREF="fto.html"
>Prev</A
></TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="index.html"
>Home</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
><A
HREF="nestedifthen.html"
>Next</A
></TD
></TR
><TR
><TD
WIDTH="33%"
ALIGN="left"
VALIGN="top"
>File test operators</TD
><TD
WIDTH="34%"
ALIGN="center"
VALIGN="top"
><A
HREF="tests.html"
>Up</A
></TD
><TD
WIDTH="33%"
ALIGN="right"
VALIGN="top"
>Nested if/then Condition Tests</TD
></TR
></TABLE
></DIV
></BODY
></HTML
>