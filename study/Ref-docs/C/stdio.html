<HTML><HEAD><TITLE>&lt;stdio.h&gt;</TITLE></HEAD><BODY BGCOLOR="#FFFFFF">

<H1><A NAME="&lt;stdio.h&gt;"><CODE>&lt;stdio.h&gt;</CODE></A></H1><HR>

<P><B><CODE><A HREF="#_IOFBF">_IOFBF</A>
&#183; <A HREF="#_IOLBF">_IOLBF</A>
&#183; <A HREF="#_IONBF">_IONBF</A>
&#183; <A HREF="#BUFSIZ">BUFSIZ</A>
&#183; <A HREF="#EOF">EOF</A>
&#183; <A HREF="#FILE">FILE</A>
&#183; <A HREF="#FILENAME_MAX">FILENAME_MAX</A>
&#183; <A HREF="#FOPEN_MAX">FOPEN_MAX</A>
&#183; <A HREF="#L_tmpnam">L_tmpnam</A>
&#183; <A HREF="#NULL">NULL</A>
&#183; <A HREF="#SEEK_CUR">SEEK_CUR</A>
&#183; <A HREF="#SEEK_END">SEEK_END</A>
&#183; <A HREF="#SEEK_SET">SEEK_SET</A>
&#183; <A HREF="#TMP_MAX">TMP_MAX</A>
&#183; <A HREF="#clearerr">clearerr</A>
&#183; <A HREF="#fclose">fclose</A>
&#183; <A HREF="#feof">feof</A>
&#183; <A HREF="#ferror">ferror</A>
&#183; <A HREF="#fflush">fflush</A>
&#183; <A HREF="#fgetc">fgetc</A>
&#183; <A HREF="#fgetpos">fgetpos</A>
&#183; <A HREF="#fgets">fgets</A>
&#183; <A HREF="#fopen">fopen</A>
&#183; <A HREF="#fpos_t">fpos_t</A>
&#183; <A HREF="#fprintf">fprintf</A>
&#183; <A HREF="#fputc">fputc</A>
&#183; <A HREF="#fputs">fputs</A>
&#183; <A HREF="#fread">fread</A>
&#183; <A HREF="#freopen">freopen</A>
&#183; <A HREF="#fscanf">fscanf</A>
&#183; <A HREF="#fseek">fseek</A>
&#183; <A HREF="#fsetpos">fsetpos</A>
&#183; <A HREF="#ftell">ftell</A>
&#183; <A HREF="#fwrite">fwrite</A>
&#183; <A HREF="#getc">getc</A>
&#183; <A HREF="#getchar">getchar</A>
&#183; <A HREF="#gets">gets</A>
&#183; <A HREF="#perror">perror</A>
&#183; <A HREF="#printf">printf</A>
&#183; <A HREF="#putc">putc</A>
&#183; <A HREF="#putchar">putchar</A>
&#183; <A HREF="#puts">puts</A>
&#183; <A HREF="#remove">remove</A>
&#183; <A HREF="#rename">rename</A>
&#183; <A HREF="#rewind">rewind</A>
&#183; <A HREF="#scanf">scanf</A>
&#183; <A HREF="#setbuf">setbuf</A>
&#183; <A HREF="#setvbuf">setvbuf</A>
&#183; <A HREF="#size_t">size_t</A>
&#183; <A HREF="#sprintf">sprintf</A>
&#183; <A HREF="#sscanf">sscanf</A>
&#183; <A HREF="#stderr">stderr</A>
&#183; <A HREF="#stdin">stdin</A>
&#183; <A HREF="#stdout">stdout</A>
&#183; <A HREF="#tmpfile">tmpfile</A>
&#183; <A HREF="#tmpnam">tmpnam</A>
&#183; <A HREF="#ungetc">ungetc</A>
&#183; <A HREF="#vfprintf">vfprintf</A>
&#183; <A HREF="#vprintf">vprintf</A>
&#183; <A HREF="#vsprintf">vsprintf</A>
</CODE></B></P>
<HR>

<P><CODE>
#define <A HREF="#_IOFBF"><B>_IOFBF</B></A>
<I>&lt;integer constant expression&gt;</I><BR>
#define <A HREF="#_IOLBF"><B>_IOLBF</B></A>
<I>&lt;integer constant expression&gt;</I><BR>
#define <A HREF="#_IONBF"><B>_IONBF</B></A>
<I>&lt;integer constant expression&gt;</I><BR>
#define <A HREF="#BUFSIZ"><B>BUFSIZ</B></A>
<I>&lt;integer constant expression &gt;= 256&gt;</I><BR>
#define <A HREF="#EOF"><B>EOF</B></A>
<I>&lt;integer constant expression &lt; 0&gt;</I><BR>
typedef <I>o-type</I> <A HREF="#FILE"><B>FILE</B></A>;<BR>
#define <A HREF="#FILENAME_MAX"><B>FILENAME_MAX</B></A>
<I>&lt;integer constant expression &gt 0&gt;</I><BR>
#define <A HREF="#FOPEN_MAX"><B>FOPEN_MAX</B></A>
<I>&lt;integer constant expression &gt;= 8&gt;</I><BR>
#define <A HREF="#L_tmpnam"><B>L_tmpnam</B></A>
<I>&lt;integer constant expression &gt; 0&gt;</I><BR>
#define <A HREF="#NULL"><B>NULL</B></A>
<I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B><BR>
#define <A HREF="#SEEK_CUR"><B>SEEK_CUR</B></A>
<I>&lt;integer constant expression&gt;</I><BR>
#define <A HREF="#SEEK_END"><B>SEEK_END</B></A>
<I>&lt;integer constant expression&gt;</I><BR>
#define <A HREF="#SEEK_SET"><B>SEEK_SET</B></A>
<I>&lt;integer constant expression&gt;</I><BR>
#define <A HREF="#TMP_MAX"><B>TMP_MAX</B></A>
<I>&lt;integer constant expression &gt;= 25&gt;</I><BR>
void <A HREF="#clearerr"><B>clearerr</B></A>(FILE *stream);<BR>
int <A HREF="#fclose"><B>fclose</B></A>(FILE *stream);<BR>
int <A HREF="#feof"><B>feof</B></A>(FILE *stream);<BR>
int <A HREF="#ferror"><B>ferror</B></A>(FILE *stream);<BR>
int <A HREF="#fflush"><B>fflush</B></A>(FILE *stream);<BR>
int <A HREF="#fgetc"><B>fgetc</B></A>(FILE *stream);<BR>
int <A HREF="#fgetpos"><B>fgetpos</B></A>(FILE *stream,
fpos_t *pos);<BR>
char *<A HREF="#fgets"><B>fgets</B></A>(char *s, int n,
FILE *stream);<BR>
FILE *<A HREF="#fopen"><B>fopen</B></A>(const char *filename,
const char *mode);<BR>
typedef <I>o-type</I> <A HREF="#fpos_t"><B>fpos_t</B></A>;<BR>
int <A HREF="#fprintf"><B>fprintf</B></A>(FILE *stream,
const char *format, ...);<BR>
int <A HREF="#fputc"><B>fputc</B></A>(int c, FILE *stream);<BR>
int <A HREF="#fputs"><B>fputs</B></A>(const char *s,
FILE *stream);<BR>
size_t <A HREF="#fread"><B>fread</B></A>(void *ptr,
size_t size, size_t nelem, FILE *stream);<BR>
FILE *<A HREF="#freopen"><B>freopen</B></A>(const char *filename,
const char *mode, FILE *stream);<BR>
int <A HREF="#fscanf"><B>fscanf</B></A>(FILE *stream,
const char *format, ...);<BR>
int <A HREF="#fseek"><B>fseek</B></A>(FILE *stream,
long offset, int mode);<BR>
int <A HREF="#fsetpos"><B>fsetpos</B></A>(FILE *stream,
const fpos_t *pos);<BR>
long <A HREF="#ftell"><B>ftell</B></A>(FILE *stream);<BR>
size_t <A HREF="#fwrite"><B>fwrite</B></A>(const void *ptr,
size_t size, size_t nelem, FILE *stream);<BR>
int <A HREF="#getc"><B>getc</B></A>(FILE *stream);<BR>
int <A HREF="#getchar"><B>getchar</B></A>(void);<BR>
char *<A HREF="#gets"><B>gets</B></A>(char *s);<BR>
void <A HREF="#perror"><B>perror</B></A>(const char *s);<BR>
int <A HREF="#printf"><B>printf</B></A>(const char *format, ...);<BR>
int <A HREF="#putc"><B>putc</B></A>(int c, FILE *stream);<BR>
int <A HREF="#putchar"><B>putchar</B></A>(int c);<BR>
int <A HREF="#puts"><B>puts</B></A>(const char *s);<BR>
int <A HREF="#remove"><B>remove</B></A>(const char *filename);<BR>
int <A HREF="#rename"><B>rename</B></A>(const char *old,
const char *new);<BR>
void <A HREF="#rewind"><B>rewind</B></A>(FILE *stream);<BR>
int <A HREF="#scanf"><B>scanf</B></A>(const char *format, ...);<BR>
void <A HREF="#setbuf"><B>setbuf</B></A>(FILE *stream,
char *buf);<BR>
int <A HREF="#setvbuf"><B>setvbuf</B></A>(FILE *stream,
char *buf, int mode, size_t size);<BR>
typedef <I>ui-type</I> <A HREF="#size_t"><B>size_t</B></A>;<BR>
int <A HREF="#sprintf"><B>sprintf</B></A>(char *s,
const char *format, ...);<BR>
int <A HREF="#sscanf"><B>sscanf</B></A>(const char *s,
const char *format, ...);<BR>
#define <A HREF="#stderr"><B>stderr</B></A>
<I>&lt;pointer to FILE rvalue&gt;</I><BR>
#define <A HREF="#stdin"><B>stdin</B></A>
<I>&lt;pointer to FILE rvalue&gt;</I><BR>
#define <A HREF="#stdout"><B>stdout</B></A>
<I>&lt;pointer to FILE rvalue&gt;</I><BR>
FILE *<A HREF="#tmpfile"><B>tmpfile</B></A>(void)<BR>
char *<A HREF="#tmpnam"><B>tmpnam</B></A>(char *s);<BR>
int <A HREF="#ungetc"><B>ungetc</B></A>(int c, FILE *stream);<BR>
int <A HREF="#vfprintf"><B>vfprintf</B></A>(FILE *stream,
const char *format, va_list ap);<BR>
int <A HREF="#vprintf"><B>vprintf</B></A>(const char *format,
va_list ap);<BR>
int <A HREF="#vsprintf"><B>vsprintf</B></A>(char *s,
const char *format, va_list ap);<BR>
</CODE></P>

<P>Include the standard header <B><CODE>&lt;stdio.h&gt;</CODE></B>
so that you can perform input and output operations on streams and files.</P>

<H2><A NAME="_IOFBF"><CODE>_IOFBF</CODE></A></H2>

<P><CODE>
#define <B>_IOFBF</B> <I>&lt;integer constant expression&gt;</I>
</CODE></P>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#setvbuf"><CODE>setvbuf</CODE></A> to indicate
<B><A NAME="full buffering">full buffering</A></B>.
(Flush the stream buffer only when it fills.)</P>

<H2><A NAME="_IOLBF"><CODE>_IOLBF</CODE></A></H2>

<P><CODE>
#define <B>_IOLBF</B> <I>&lt;integer constant expression&gt;</I>
</CODE></P>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#setvbuf"><CODE>setvbuf</CODE></A> to indicate
<B><A NAME="line buffering">line buffering</A></B>.
(Flush the stream buffer at the end of a
<A HREF="lib_file.html#text lines" tppabs="http://ccs.ucsd.edu/c/lib_file.html#text lines">text line</A>.)</P>

<H2><A NAME="_IONBF"><CODE>_IONBF</CODE></A></H2>

<P><CODE>
#define <B>_IONBF</B> <I>&lt;integer constant expression&gt;</I>
</CODE></P>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#setvbuf"><CODE>setvbuf</CODE></A> to indicate
<B><A NAME="no buffering">no buffering</A></B>.
(Flush the stream buffer at the end of each write operation.)</P>

<H2><A NAME="BUFSIZ"><CODE>BUFSIZ</CODE></A></H2>

<P><CODE>
#define <B>BUFSIZ</B> <I>&lt;integer constant expression &gt;= 256&gt;</I>
</CODE></P>

<P>The macro yields the size of the stream buffer used by
<A HREF="#setbuf"><CODE>setbuf</CODE></A>.</P>

<H2><A NAME="EOF"><CODE>EOF</CODE></A></H2>

<P><CODE>
#define <B>EOF</B> <I>&lt;integer constant expression &lt; 0&gt;</I>
</CODE></P>

<P>The macro yields the return value used to signal the end of 
a stream or to report an error condition.</P>

<H2><A NAME="FILE"><CODE>FILE</CODE></A></H2>

<P><CODE>
typedef <I>o-type</I> <B>FILE</B>;
</CODE></P>

<P>The type is an object type <CODE><I>o-type</I></CODE> that stores all
<A HREF="lib_file.html#Controlling Streams" tppabs="http://ccs.ucsd.edu/c/lib_file.html#Controlling Streams">control information</A>
for a stream. The functions
<A HREF="#fopen"><CODE>fopen</CODE></A> and
<A HREF="#freopen"><CODE>freopen</CODE></A> 
allocate all <CODE>FILE</CODE> objects used by the read and write functions.</P>

<H2><A NAME="FILENAME_MAX"><CODE>FILENAME_MAX</CODE></A></H2>

<P><CODE>
#define <B>FILENAME_MAX</B> <I>&lt;integer constant expression &gt 0&gt;</I>
</CODE></P>

<P>The macro yields the maximum size array of characters that you 
must provide to hold a
<A HREF="lib_over.html#filename" tppabs="http://ccs.ucsd.edu/c/lib_over.html#filename">filename</A>.</P>

<H2><A NAME="FOPEN_MAX"><CODE>FOPEN_MAX</CODE></A></H2>

<P><CODE>
#define <B>FOPEN_MAX</B> <I>&lt;integer constant expression &gt;= 8&gt;</I>
</CODE></P>

<P>The macro yields the maximum number of files that the target 
environment permits to be simultaneously open (including
<A HREF="#stderr"><CODE>stderr</CODE></A>,
<A HREF="#stdin"><CODE>stdin</CODE></A>, and
<A HREF="#stdout"><CODE>stdout</CODE></A>).</P>

<H2><A NAME="L_tmpnam"><CODE>L_tmpnam</CODE></A></H2>

<P><CODE>
#define <B>L_tmpnam</B> <I>&lt;integer constant expression &gt; 0&gt;</I>
</CODE></P>

<P>The macro yields the number of characters that the target environment 
requires for representing temporary filenames created by
<A HREF="#tmpnam"><CODE>tmpnam</CODE></A>.</P>

<H2><A NAME="NULL"><CODE>NULL</CODE></A></H2>

<P><CODE>
#define <B>NULL</B> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B>
</CODE></P>

<P>The macro yields a null pointer constant that is usable as an 
<A HREF="express.html#address constant expression" tppabs="http://ccs.ucsd.edu/c/express.html#address constant expression">
address constant expression</A>.</P>

<H2><A NAME="SEEK_CUR"><CODE>SEEK_CUR</CODE></A></H2>

<P><CODE>
#define <B>SEEK_CUR</B> <I>&lt;integer constant expression&gt;</I>
</CODE></P>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#fseek"><CODE>fseek</CODE></A> 
to indicate seeking relative to the current
file-position indicator.</P>

<H2><A NAME="SEEK_END"><CODE>SEEK_END</CODE></A></H2>

<P><CODE>
#define <B>SEEK_END</B> <I>&lt;integer constant expression&gt;</I>
</CODE></P>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#fseek"><CODE>fseek</CODE></A> 
to indicate seeking relative to the end of the file.</P>

<H2><A NAME="SEEK_SET"><CODE>SEEK_SET</CODE></A></H2>

<P><CODE>
#define <B>SEEK_SET</B> <I>&lt;integer constant expression&gt;</I>
</CODE></P>

<P>The macro yields the value of the <CODE>mode</CODE> argument to
<A HREF="#fseek"><CODE>fseek</CODE></A> 
to indicate seeking relative to the beginning of the file.</P>

<H2><A NAME="TMP_MAX"><CODE>TMP_MAX</CODE></A></H2>

<P><CODE>
#define <B>TMP_MAX</B> <I>&lt;integer constant expression &gt;= 25&gt;</I>
</CODE></P>

<P>The macro yields the minimum number of distinct filenames created 
by the function
<A HREF="#tmpnam"><CODE>tmpnam</CODE></A>.</P>

<H2><A NAME="clearerr"><CODE>clearerr</CODE></A></H2>

<P><CODE>
void <B>clearerr</B>(FILE *stream);
</CODE></P>

<P>The function clears the end-of-file and error indicators for 
the stream <CODE>stream</CODE>.</P>

<H2><A NAME="fclose"><CODE>fclose</CODE></A></H2>

<P><CODE>
int <B>fclose</B>(FILE *stream);
</CODE></P>

<P>The function closes the file associated with
the stream <CODE>stream</CODE>. 
It returns zero if successful; otherwise, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.
<CODE>fclose</CODE> writes any buffered output to the file,
deallocates the stream buffer if it was automatically allocated,
and removes the association between the stream and the file.
Do not use the value of <CODE>stream</CODE> in subsequent expressions.</P>

<H2><A NAME="feof"><CODE>feof</CODE></A></H2>

<P><CODE>
int <B>feof</B>(FILE *stream);
</CODE></P>

<P>The function returns a nonzero value if the end-of-file indicator 
is set for the stream <CODE>stream</CODE>.</P>

<H2><A NAME="ferror"><CODE>ferror</CODE></A></H2>

<P><CODE>
int <B>ferror</B>(FILE *stream);
</CODE></P>

<P>The function returns a nonzero value if the error indicator 
is set for the stream <CODE>stream</CODE>.</P>

<H2><A NAME="fflush"><CODE>fflush</CODE></A></H2>

<P><CODE>
int <B>fflush</B>(FILE *stream);
</CODE></P>

<P>The function writes any buffered output to the file associated 
with the stream <CODE>stream</CODE> and returns zero if successful;
otherwise, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.
If <CODE>stream</CODE> is a null pointer, <CODE>fflush</CODE> 
writes any buffered output to all files opened for output.</P>

<H2><A NAME="fgetc"><CODE>fgetc</CODE></A></H2>

<P><CODE>
int <B>fgetc</B>(FILE *stream);
</CODE></P>

<P>The function reads the next character <CODE>c</CODE> (if present) 
from the input stream <CODE>stream</CODE>, advances the
file-position indicator (if defined),
and returns <CODE>(int)(unsigned char)c</CODE>. If the 
function sets either the end-of-file indicator or the error indicator, 
it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.</P>

<H2><A NAME="fgetpos"><CODE>fgetpos</CODE></A></H2>

<P><CODE>
int <B>fgetpos</B>(FILE *stream, fpos_t *pos);
</CODE></P>

<P>The function stores the
file-position indicator for the stream 
<CODE>stream</CODE> in <CODE>*pos</CODE> and returns zero if successful;
otherwise, the function stores a positive value in
<A HREF="errno.html#errno" tppabs="http://ccs.ucsd.edu/c/errno.html#errno"><CODE>errno</CODE></A> and returns a 
nonzero value.</P>

<H2><A NAME="fgets"><CODE>fgets</CODE></A></H2>

<P><CODE>
char *<B>fgets</B>(char *s, int n, FILE *stream);
</CODE></P>

<P>The function reads characters from the input stream <CODE>stream</CODE> 
and stores them in successive elements of the array
beginning at <CODE>s</CODE> 
and continuing until it stores <CODE>n-1</CODE> characters,
stores an <CODE><I>NL</I></CODE> character,
or sets the end-of-file or error indicators. If <CODE>fgets</CODE> 
stores any characters, it concludes by storing a null character in 
the next element of the array. It returns <CODE>s</CODE> if it stores any 
characters and it has not set the error indicator for the stream; 
otherwise, it returns a null pointer. If it sets the error indicator, 
the array contents are indeterminate.</P>

<H2><A NAME="fopen"><CODE>fopen</CODE></A></H2>

<P><CODE>
FILE *<B>fopen</B>(const char *filename, const char *mode);
</CODE></P>

<P>The function opens the file with the filename <CODE>filename</CODE>, 
associates it with a stream, and returns a pointer to the object controlling 
the stream. If the open fails, it returns a null pointer. The initial 
characters of <CODE>mode</CODE> determine how the program
<A HREF="lib_file.html#Files and Streams" tppabs="http://ccs.ucsd.edu/c/lib_file.html#Files and Streams">manipulates</A> the stream
and whether it interprets the stream as
<A HREF="lib_file.html#Text and Binary Streams" tppabs="http://ccs.ucsd.edu/c/lib_file.html#Text and Binary Streams">text or binary</A>.
The initial characters must be one of the following sequences:</P>

<UL>
<LI><CODE><B>"r"</B></CODE> -- to open an existing text file for reading

<LI><CODE><B>"w"</B></CODE> -- to create a text file or to open and truncate 
an existing text file, for writing

<LI><CODE><B>"a"</B></CODE> -- to create a text file or to open
an existing text file, for writing. The
file-position indicator is positioned 
at the end of the file before each write

<LI><CODE><B>"rb"</B></CODE> -- to open an existing binary file for reading

<LI><CODE><B>"wb"</B></CODE> -- to create a binary file or to open and truncate 
an existing binary file, for writing

<LI><CODE><B>"ab"</B></CODE> -- to create a binary file or to open an existing 
binary file, for writing. The
file-position indicator is positioned 
at the end of the file (possibly after arbitrary null byte padding) 
before each write

<LI><CODE><B>"r+"</B></CODE> -- to open an existing text file for reading 
and writing

<LI><CODE><B>"w+"</B></CODE> -- to create a text file or to open and truncate 
an existing text file, for reading and writing

<LI><CODE><B>"a+"</B></CODE> -- to create a text file or to open an existing 
text file, for reading and writing. The
file-position indicator is positioned
at the end of the file before each write

<LI><CODE><B>"r+b"</B></CODE> or <CODE><B>"rb+"</B></CODE> -- to open an existing binary 
file for reading and writing

<LI><CODE><B>"w+b"</B></CODE> or <CODE><B>"wb+"</B></CODE> -- to create a binary file or 
to open and truncate an existing binary file, for reading and writing

<LI><CODE><B>"a+b"</B></CODE> or <CODE><B>"ab+"</B></CODE> -- to create a binary file or 
to open an existing binary file, for reading and writing. The
file-position indicator is positioned
at the end of the file (possibly after arbitrary 
null byte padding) before each write
</UL>

<P>If you open a file for both reading and writing, the target 
environment can open a binary file instead of a text file. If the 
file is not interactive, the stream is fully buffered.</P>

<H2><A NAME="fpos_t"><CODE>fpos_t</CODE></A></H2>

<P><CODE>
typedef <I>o-type</I> <B>fpos_t</B>;
</CODE></P>

<P>The type is an object type <CODE><I>o-type</I></CODE>
of an object that you declare to hold the value of a
file-position indicator stored by
<A HREF="#fsetpos"><CODE>fsetpos</CODE></A> and accessed by
<A HREF="#fgetpos"><CODE>fgetpos</CODE></A>.</P>

<H2><A NAME="fprintf"><CODE>fprintf</CODE></A></H2>

<P><CODE>
int <B>fprintf</B>(FILE *stream, const char *format, ...);
</CODE></P>

<P>The function
<A HREF="lib_prin.html#Print Functions" tppabs="http://ccs.ucsd.edu/c/lib_prin.html#Print Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes 
each generated character to the stream <CODE>stream</CODE>. It returns the 
number of characters generated, or it returns a negative value if 
the function sets the error indicator for the stream.</P>

<H2><A NAME="fputc"><CODE>fputc</CODE></A></H2>

<P><CODE>
int <B>fputc</B>(int c, FILE *stream);
</CODE></P>

<P>The function writes the character <CODE>(unsigned char)c</CODE> to 
the output stream <CODE>stream</CODE>, advances the
file-position indicator (if defined),
and returns <CODE>(int)(unsigned char)c</CODE>. If the function 
sets the error indicator for the stream, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.</P>

<H2><A NAME="fputs"><CODE>fputs</CODE></A></H2>

<P><CODE>
int <B>fputs</B>(const char *s, FILE *stream);
</CODE></P>

<P>The function accesses characters from the
<A HREF="lib_over.html#C string" tppabs="http://ccs.ucsd.edu/c/lib_over.html#C string">C string</A> <CODE>s</CODE> and 
writes them to the output stream <CODE>stream</CODE>. The function does 
not write the terminating null character. It returns a nonnegative 
value if it has not set the error indicator; otherwise, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.</P>

<H2><A NAME="fread"><CODE>fread</CODE></A></H2>

<P><CODE>
size_t <B>fread</B>(void *ptr, size_t size, size_t nelem, FILE *stream);
</CODE></P>

<P>The function reads characters from the input stream <CODE>stream</CODE> 
and stores them in successive elements of the array whose first element 
has the address <CODE>(char *)ptr</CODE>
until the function stores <CODE>size*nelem</CODE> 
characters or sets the end-of-file or error indicator. It returns
<CODE>n/size</CODE>, where <CODE>n</CODE>
is the number of characters it read. 
If <CODE>n</CODE> is not a multiple of <CODE>size</CODE>,
the value stored in the last element is indeterminate.
If the function sets the error indicator, the
file-position indicator is indeterminate.</P>

<H2><A NAME="freopen"><CODE>freopen</CODE></A></H2>

<P><CODE>
FILE *<B>freopen</B>(const char *filename, const char *mode, FILE *stream);
</CODE></P>

<P>The function closes the file associated with
the stream <CODE>stream</CODE> (as if by calling
<A HREF="#fclose"><CODE>fclose</CODE></A>);
then it opens the file with the filename <CODE>filename</CODE>
and associates the file with the stream <CODE>stream</CODE> 
(as if by calling
<CODE><A HREF="#fopen">fopen</A>(filename, mode)</CODE>).
It returns <CODE>stream</CODE> if the open is successful;
otherwise, it returns a null pointer.</P>

<H2><A NAME="fscanf"><CODE>fscanf</CODE></A></H2>

<P><CODE>
int <B>fscanf</B>(FILE *stream, const char *format, ...);
</CODE></P>

<P>The function
<A HREF="lib_scan.html#Scan Functions" tppabs="http://ccs.ucsd.edu/c/lib_scan.html#Scan Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned character from the stream <CODE>stream</CODE>. It returns the number 
of input items matched and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A> if the 
function does not store values before it sets the end-of-file or error 
indicator for the stream.</P>

<H2><A NAME="fseek"><CODE>fseek</CODE></A></H2>

<P><CODE>
int <B>fseek</B>(FILE *stream, long offset, int mode);
</CODE></P>

<P>The function sets the
file-position indicator for the stream 
<CODE>stream</CODE> (as specified by
<CODE>offset</CODE> and <CODE>mode</CODE>), clears 
the end-of-file indicator for the stream, and returns zero if successful.</P>

<P>For a
<A HREF="lib_file.html#binary stream" tppabs="http://ccs.ucsd.edu/c/lib_file.html#binary stream">binary stream</A>,
<CODE>offset</CODE> is a signed offset in bytes:</P>

<UL>
<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_SET"><CODE>SEEK_SET</CODE></A>,
<CODE>fseek</CODE> adds <CODE>offset</CODE>
to the file-position indicator for the beginning of the file.

<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_CUR"><CODE>SEEK_CUR</CODE></A>,
<CODE>fseek</CODE> adds <CODE>offset</CODE> to the current
file-position indicator.

<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_END"><CODE>SEEK_END</CODE></A>,
<CODE>fseek</CODE> adds <CODE>offset</CODE> to the
file-position indicator for the end of the file 
(possibly after arbitrary null character padding).
</UL>

<P><CODE>fseek</CODE> sets the file-position indicator to the result 
of this addition.</P>

<P>For a
<A HREF="lib_file.html#text stream" tppabs="http://ccs.ucsd.edu/c/lib_file.html#text stream">text stream</A>:</P>

<UL>
<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_SET"><CODE>SEEK_SET</CODE></A>,
<CODE>fseek</CODE> sets the
file-position indicator to the value encoded 
in <CODE>offset</CODE>, which is either a value returned
by an earlier successful call to
<A HREF="#ftell"><CODE>ftell</CODE></A>
or zero to indicate the beginning of the file.

<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_CUR"><CODE>SEEK_CUR</CODE></A>
and <CODE>offset</CODE> is zero, <CODE>fseek</CODE> leaves the
file-position indicator at its current value.

<LI>If <CODE>mode</CODE> has the value
<A HREF="#SEEK_END"><CODE>SEEK_END</CODE></A>
and <CODE>offset</CODE> is zero, <CODE>fseek</CODE> sets the
file-position indicator to indicate the end of the file.
</UL>

<P>The function defines no other combination of argument values.</P>

<H2><A NAME="fsetpos"><CODE>fsetpos</CODE></A></H2>

<P><CODE>
int <B>fsetpos</B>(FILE *stream, const fpos_t *pos);
</CODE></P>

<P>The function sets the file-position indicator for the stream 
<CODE>stream</CODE> to the value stored in <CODE>*pos</CODE>,
clears the end-of-file indicator for the stream,
and returns zero if successful. Otherwise, 
the function stores a positive value in
<A HREF="errno.html#errno" tppabs="http://ccs.ucsd.edu/c/errno.html#errno"><CODE>errno</CODE></A>
and returns a nonzero value.</P>

<H2><A NAME="ftell"><CODE>ftell</CODE></A></H2>

<P><CODE>
long <B>ftell</B>(FILE *stream);
</CODE></P>

<P>The function returns an encoded form of the file-position indicator 
for the stream <CODE>stream</CODE> or stores a positive value in
<A HREF="errno.html#errno" tppabs="http://ccs.ucsd.edu/c/errno.html#errno"><CODE>errno</CODE></A> and returns
the value -1. For a binary file, a successful return 
value gives the number of bytes from the beginning of the file. For 
a text file, target environments can vary on the representation and 
range of encoded file-position indicator values.</P>

<H2><A NAME="fwrite"><CODE>fwrite</CODE></A></H2>

<CODE>size_t <B>fwrite</B>(const void *ptr, size_t size, size_t nelem,
FILE *stream);</CODE>

<P>The function writes characters to the output stream <CODE>stream</CODE>, 
accessing values from successive elements of the array whose first 
element has the address <CODE>(char *)ptr</CODE> until the function writes 
<CODE>size*nelem</CODE> characters or sets the error indicator. It returns 
<CODE>n/size</CODE>, where <CODE>n</CODE>
is the number of characters it wrote. 
If the function sets the error indicator,
the file-position indicator is indeterminate.</P>

<H2><A NAME="getc"><CODE>getc</CODE></A></H2>

<P><CODE>
int <B>getc</B>(FILE *stream);
</CODE></P>

<P>The function has the same effect as
<CODE><A HREF="#fgetc">fgetc</A>(stream)</CODE> except 
that a macro version of <CODE>getc</CODE>
can evaluate <CODE>stream</CODE> more than once.</P>

<H2><A NAME="getchar"><CODE>getchar</CODE></A></H2>

<P><CODE>
int <B>getchar</B>(void);
</CODE></P>

<P>The function has the same effect as
<CODE><A HREF="#fgetc">fgetc</A>(stdin)</CODE>,
reading a character from the stream
<A HREF="#stdin"><CODE>stdin</CODE></A></P>

<H2><A NAME="gets"><CODE>gets</CODE></A></H2>

<P><CODE>
char *<B>gets</B>(char *s);
</CODE></P>

<P>The function reads characters from the stream
<A HREF="#stdin"><CODE>stdin</CODE></A> 
and stores them in successive elements of the array whose first element 
has the address <CODE>s</CODE> until the function reads
an <CODE><I>NL</I></CODE> character 
(which is not stored) or sets the end-of-file or error indicator. 
If <CODE>gets</CODE> reads any characters, it concludes by storing a null 
character in the next element of the array. It returns <CODE>s</CODE> if 
it reads any characters and has not set the error indicator for the 
stream; otherwise, it returns a null pointer. If it sets the error 
indicator, the array contents are indeterminate. The number of characters 
that <CODE>gets</CODE> reads and stores cannot be limited. Use
<A HREF="#fgets"><CODE>fgets</CODE></A> instead.</P>

<H2><A NAME="perror"><CODE>perror</CODE></A></H2>

<P><CODE>
void <B>perror</B>(const char *s);
</CODE></P>

<P>The function writes a line of text to the stream
<A HREF="#stderr"><CODE>stderr</CODE></A>.
If <CODE>s</CODE> is not a null pointer,
the function first writes the
<A HREF="lib_over.html#C string" tppabs="http://ccs.ucsd.edu/c/lib_over.html#C string">C string</A> <CODE>s</CODE>
(as if by calling
<CODE><A HREF="#fputs">fputs</A>(s, stderr)</CODE>),
followed by a colon (<CODE>:</CODE>) and a <CODE><I>space</I></CODE>.
It then writes the same message
<A HREF="lib_over.html#C string" tppabs="http://ccs.ucsd.edu/c/lib_over.html#C string">C string</A> that is returned by
<CODE><A HREF="string.html#strerror" tppabs="http://ccs.ucsd.edu/c/string.html#strerror">strerror</A>(errno)</CODE>,
converting the value stored in
<A HREF="errno.html#errno" tppabs="http://ccs.ucsd.edu/c/errno.html#errno"><CODE>errno</CODE></A>,
followed by an <CODE><I>NL</I></CODE>.</P>

<H2><A NAME="printf"><CODE>printf</CODE></A></H2>

<P><CODE>
int <B>printf</B>(const char *format, ...);
</CODE></P>

<P>The function
<A HREF="lib_prin.html#Print Functions" tppabs="http://ccs.ucsd.edu/c/lib_prin.html#Print Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes 
each generated character to the stream
<A HREF="#stdout"><CODE>stdout</CODE></A>.
It returns the number of characters generated,
or it returns a negative value if the function 
sets the error indicator for the stream.</P>

<H2><A NAME="putc"><CODE>putc</CODE></A></H2>

<P><CODE>
int <B>putc</B>(int c, FILE *stream);
</CODE></P>

<P>The function has the same effect as
<CODE><A HREF="#fputc">fputc</A>(c, stream)</CODE> 
except that a macro version of <CODE>putc</CODE>
can evaluate <CODE>stream</CODE> more than once.</P>

<H2><A NAME="putchar"><CODE>putchar</CODE></A></H2>

<P><CODE>
int <B>putchar</B>(int c);
</CODE></P>

<P>The function has the same effect as
<CODE><A HREF="#fputc">fputc</A>(c, stdout)</CODE>,
writing a character to the stream
<A HREF="#stdout"><CODE>stdout</CODE></A>.</P>

<H2><A NAME="puts"><CODE>puts</CODE></A></H2>

<P><CODE>
int <B>puts</B>(const char *s);
</CODE></P>

<P>The function accesses characters from the
<A HREF="lib_over.html#C string" tppabs="http://ccs.ucsd.edu/c/lib_over.html#C string">C string</A> <CODE>s</CODE> and 
writes them to the stream
<A HREF="#stdout"><CODE>stdout</CODE></A>. The function writes 
an <CODE><I>NL</I></CODE> character to the stream
in place of the terminating null character.
It returns a nonnegative value if it has not set the 
error indicator; otherwise, it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>.</P>

<H2><A NAME="remove"><CODE>remove</CODE></A></H2>

<P><CODE>
int <B>remove</B>(const char *filename);
</CODE></P>

<P>The function removes the file with the filename <CODE>filename</CODE> 
and returns zero if successful.
If the file is open when you remove it,
the result is implementation defined. After you remove it, you 
cannot open it as an existing file.</P>

<H2><A NAME="rename"><CODE>rename</CODE></A></H2>

<P><CODE>
int <B>rename</B>(const char *old, const char *new);
</CODE></P>

<P>The function renames the file with the filename <CODE>old</CODE> to 
have the filename <CODE>new</CODE> and returns zero if successful. If a 
file with the filename <CODE>new</CODE> already exists,
the result is implementation defined. 
After you rename it, you cannot open the file
with the filename <CODE>old</CODE>.</P>

<H2><A NAME="rewind"><CODE>rewind</CODE></A></H2>

<P><CODE>
void <B>rewind</B>(FILE *stream);
</CODE></P>

<P>The function calls
<CODE><A HREF="#fseek">fseek</A>(stream, 0L, SEEK_SET)</CODE>
and then clears the error indicator for the stream <CODE>stream</CODE>.</P>

<H2><A NAME="scanf"><CODE>scanf</CODE></A></H2>

<P><CODE>
int <B>scanf</B>(const char *format, ...);
</CODE></P>

<P>The function
<A HREF="lib_scan.html#Scan Functions" tppabs="http://ccs.ucsd.edu/c/lib_scan.html#Scan Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It obtains each
scanned character from the stream
<A HREF="#stdin"><CODE>stdin</CODE></A>. It returns the number 
of input items matched and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A> if the 
function does not store values before it sets the end-of-file or error 
indicators for the stream.</P>

<H2><A NAME="setbuf"><CODE>setbuf</CODE></A></H2>

<P><CODE>
void <B>setbuf</B>(FILE *stream, char *buf);
</CODE></P>

<P>If <CODE>buf</CODE> is not a null pointer, the function calls
<CODE><A HREF="#setvbuf">setvbuf</A>(stream, buf,
__IOFBF, BUFSIZ)</CODE>,
specifying full buffering with
<A HREF="#_IOFBF"><CODE>_IOFBF</CODE></A>
and a buffer size of
<A HREF="#BUFSIZ"><CODE>BUFSIZ</CODE></A> characters.
Otherwise, the function calls
<CODE><A HREF="#setvbuf">setvbuf</A>(stream,
0, _IONBF, BUFSIZ)</CODE>,
specifying no buffering with
<A HREF="#_IONBF"><CODE>_IONBF</CODE></A>.</P>

<H2><A NAME="setvbuf"><CODE>setvbuf</CODE></A></H2>

<P><CODE>
int <B>setvbuf</B>(FILE *stream, char *buf, int mode, size_t size);
</CODE></P>

<P>The function sets the buffering mode for the stream <CODE>stream</CODE> 
according to <CODE>buf</CODE>, <CODE>mode</CODE>, and <CODE>size</CODE>.
It returns zero if successful.
If <CODE>buf</CODE> is not a null pointer, then <CODE>buf</CODE> 
is the address of the first element of an array of <I>char</I> of 
size <CODE>size</CODE> that can be used as the stream buffer. Otherwise, 
<CODE>setvbuf</CODE> can allocate a stream buffer that is freed when the 
file is closed. For <CODE>mode</CODE> you must supply one of the following 
values:</P>

<UL>
<LI><B><A HREF="#_IOFBF"><CODE>_IOFBF</CODE></A></B>
-- to indicate full buffering

<LI><B><A HREF="#_IOLBF"><CODE>_IOLBF</CODE></A></B>
-- to indicate line buffering

<LI><B><A HREF="#_IONBF"><CODE>_IONBF</CODE></A></B>
-- to indicate no buffering
</UL>

<P>You must call <CODE>setvbuf</CODE> after you call
<A HREF="#fopen"><CODE>fopen</CODE></A> 
to associate a file with that stream and before you call a library 
function that performs any other operation on the stream.</P>

<H2><A NAME="size_t"><CODE>size_t</CODE></A></H2>

<P><CODE>
typedef <I>ui-type</I> <B>size_t</B>;
</CODE></P>

<P>The type is the unsigned integer type <CODE><I>ui-type</I></CODE>
of an object that you declare to store the result of the
<A HREF="express.html#sizeof operator" tppabs="http://ccs.ucsd.edu/c/express.html#sizeof operator"><I>sizeof</I></A> operator.</P>

<H2><A NAME="sprintf"><CODE>sprintf</CODE></A></H2>

<P><CODE>
int <B>sprintf</B>(char *s, const char *format, ...);
</CODE></P>

<P>The function
<A HREF="lib_prin.html#Print Functions" tppabs="http://ccs.ucsd.edu/c/lib_prin.html#Print Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated character in successive locations of the array object whose 
first element has the address <CODE>s</CODE>. The function concludes by 
storing a null character in the next location of the array. It returns 
the number of characters generated -- not including the null character. 

<H2><A NAME="sscanf"><CODE>sscanf</CODE></A></H2>

<P><CODE>
int <B>sscanf</B>(const char *s, const char *format, ...);
</CODE></P>

<P>The function
<A HREF="lib_scan.html#Scan Functions" tppabs="http://ccs.ucsd.edu/c/lib_scan.html#Scan Functions">scans formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments. It accesses each scanned 
character from successive locations of the array object whose first 
element has the address <CODE>s</CODE>.
It returns the number of items matched 
and assigned, or it returns
<A HREF="#EOF"><CODE>EOF</CODE></A>
if the function does not store 
values before it accesses a null character from the array.</P>

<H2><A NAME="stderr"><CODE>stderr</CODE></A></H2>

<P><CODE>
#define <B>stderr</B> <I>&lt;pointer to FILE rvalue&gt;</I>
</CODE></P>

<P>The macro yields a pointer to the object that controls the standard 
error output stream.</P>

<H2><A NAME="stdin"><CODE>stdin</CODE></A></H2>

<P><CODE>
#define <B>stdin</B> <I>&lt;pointer to FILE rvalue&gt;</I>
</CODE></P>

<P>The macro yields a pointer to the object that controls the standard 
input stream.</P>

<H2><A NAME="stdout"><CODE>stdout</CODE></A></H2>

<P><CODE>
#define <B>stdout</B> <I>&lt;pointer to FILE rvalue&gt;</I>
</CODE></P>

<P>The macro yields a pointer to the object that controls the standard 
output stream.</P>

<H2><A NAME="tmpfile"><CODE>tmpfile</CODE></A></H2>

<P><CODE>
FILE *<B>tmpfile</B>(void)
</CODE></P>

<P>The function creates a temporary binary file with the filename 
<CODE><I>temp-name</I></CODE> and then has the same effect as calling
<CODE><A HREF="#fopen">fopen</A>(<I>temp-name</I>,
"wb+")</CODE>.
The file <CODE><I>temp-name</I></CODE> is removed when the program closes 
it, either by calling
<A HREF="#fclose"><CODE>fclose</CODE></A>
explicitly or at normal program termination.
The filename <CODE><I>temp-name</I></CODE> does not conflict with 
any filenames that you create. If the open is successful, the function 
returns a pointer to the object controlling the stream; otherwise, 
it returns a null pointer.</P>

<H2><A NAME="tmpnam"><CODE>tmpnam</CODE></A></H2>

<P><CODE>
char *<B>tmpnam</B>(char *s);
</CODE></P>

<P>The function creates a unique filename <CODE><I>temp-name</I></CODE> and 
returns a pointer to the filename. If <CODE>s</CODE> is not a null pointer, 
then <CODE>s</CODE> must be the address
of the first element of an array at least of size
<A HREF="#L_tmpnam"><CODE>L_tmpnam</CODE></A>.
The function stores <CODE><I>temp-name</I></CODE> 
in the array and returns <CODE>s</CODE>.
Otherwise, if <CODE>s</CODE> is a null 
pointer, the function stores <CODE><I>temp-name</I></CODE>
in a static-duration array and returns the address of its first element.
Subsequent calls to <CODE>tmpnam</CODE>
can alter the values stored in this array.</P>

<P>The function returns unique filenames for each of the first
<A HREF="#TMP_MAX"><CODE>TMP_MAX</CODE></A>
times it is called, after which its behavior is implementation defined. 
The filename <CODE><I>temp-name</I></CODE>
does not conflict with any filenames that you create.</P>

<H2><A NAME="ungetc"><CODE>ungetc</CODE></A></H2>

<P><CODE>
int <B>ungetc</B>(int c, FILE *stream);
</CODE></P>

<P>If <CODE>c</CODE> is not equal to
<A HREF="#EOF"><CODE>EOF</CODE></A>, the function stores 
<CODE>(unsigned char)c</CODE> in the object
whose address is <CODE>stream</CODE> 
and clears the end-of-file indicator. If <CODE>c</CODE> equals
<A HREF="#EOF"><CODE>EOF</CODE></A> 
or the store cannot occur, the function returns
<A HREF="#EOF"><CODE>EOF</CODE></A>; otherwise, 
it returns <CODE>(unsigned char)c</CODE>. A subsequent library function 
call that reads a character from the stream <CODE>stream</CODE> obtains 
this stored value, which is then forgotten.</P>

<P>Thus, you can effectively
<B><A NAME="push back">push back</A></B> a character to a 
stream after reading a character. (You need not push back the same 
character that you read.) An implementation can let you push back 
additional characters before you read the first one. You read the 
characters in reverse order of pushing them back to the stream. You 
cannot portably:</P>

<UL>
<LI>push back more than one character

<LI>push back a character if the file-position indicator is at the 
beginning of the file

<LI>Call
<A HREF="#ftell"><CODE>ftell</CODE></A>
for a text file that has a character currently pushed back
</UL>

<P>A call to the functions
<A HREF="#fseek"><CODE>fseek</CODE></A>,
<A HREF="#fsetpos"><CODE>fsetpos</CODE></A>, or
<A HREF="#rewind"><CODE>rewind</CODE></A> 
for the stream causes the stream to forget any pushed-back characters. 
For a binary stream, the file-position indicator is decremented for 
each character that is pushed back.</P>

<H2><A NAME="vfprintf"><CODE>vfprintf</CODE></A></H2>

<P><CODE>
int <B>vfprintf</B>(FILE *stream, const char *format, va_list ap);
</CODE></P>

<P>The function
<A HREF="lib_prin.html#Print Functions" tppabs="http://ccs.ucsd.edu/c/lib_prin.html#Print Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes 
each generated character to the stream <CODE>stream</CODE>.
It returns the number 
of characters generated, or it returns a negative value if the function 
sets the error indicator for the stream.</P>

<P>The function accesses additional arguments by using the context 
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start" tppabs="http://ccs.ucsd.edu/c/stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end" tppabs="http://ccs.ucsd.edu/c/stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vprintf"><CODE>vprintf</CODE></A></H2>

<P><CODE>
int <B>vprintf</B>(const char *format, va_list ap);
</CODE></P>

<P>The function
<A HREF="lib_prin.html#Print Functions" tppabs="http://ccs.ucsd.edu/c/lib_prin.html#Print Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and writes 
each generated character to the stream
<A HREF="#stdout"><CODE>stdout</CODE></A>.
It returns the number of characters generated,
or a negative value if the function sets 
the error indicator for the stream.</P>

<P>The function accesses additional arguments by using the context 
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start" tppabs="http://ccs.ucsd.edu/c/stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end" tppabs="http://ccs.ucsd.edu/c/stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<H2><A NAME="vsprintf"><CODE>vsprintf</CODE></A></H2>

<P><CODE>
int <B>vsprintf</B>(char *s, const char *format, va_list ap);
</CODE></P>

<P>The function
<A HREF="lib_prin.html#Print Functions" tppabs="http://ccs.ucsd.edu/c/lib_prin.html#Print Functions">generates formatted text</A>,
under the control of the format <CODE>format</CODE>
and any additional arguments, and stores
each generated character in successive locations of the array object whose 
first element has the address <CODE>s</CODE>. The function concludes by 
storing a null character in the next location of the array. It returns 
the number of characters generated -- not including the null character.</P>

<P>The function accesses additional arguments by using the context 
information designated by <CODE>ap</CODE>.
The program must execute the macro
<A HREF="stdarg.html#va_start" tppabs="http://ccs.ucsd.edu/c/stdarg.html#va_start"><CODE>va_start</CODE></A>
before it calls the function, and then execute the macro
<A HREF="stdarg.html#va_end" tppabs="http://ccs.ucsd.edu/c/stdarg.html#va_end"><CODE>va_end</CODE></A>
after the function returns.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents" tppabs="http://ccs.ucsd.edu/c/index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html" tppabs="http://ccs.ucsd.edu/c/_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pb.html" tppabs="http://ccs.ucsd.edu/c/crit_pb.html">Copyright</A> &#169; 1989-1996
by P.J. Plauger and Jim Brodie. All rights reserved.</I></P>

</BODY></HTML>
