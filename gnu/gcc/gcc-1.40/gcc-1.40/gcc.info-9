Info file gcc.info, produced by Makeinfo, -*- Text -*- from input
file gcc.texinfo.

   This file documents the use and the internals of the GNU compiler.

   Copyright (C) 1988, 1989, 1990 Free Software Foundation, Inc.

   Permission is granted to make and distribute verbatim copies of
this manual provided the copyright notice and this permission notice
are preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the sections entitled "GNU General Public License" and "Protect
Your Freedom--Fight `Look And Feel'" are included exactly as in the
original, and provided that the entire resulting derived work is
distributed under the terms of a permission notice identical to this
one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the sections entitled "GNU General Public
License" and "Protect Your Freedom--Fight `Look And Feel'" and this
permission notice may be included in translations approved by the
Free Software Foundation instead of in the original English.


File: gcc.info,  Node: Registers,  Next: Register Classes,  Prev: Storage Layout,  Up: Machine Macros

Register Usage
==============

`FIRST_PSEUDO_REGISTER'
     Number of hardware registers known to the compiler.  They
     receive numbers 0 through `FIRST_PSEUDO_REGISTER-1'; thus, the
     first pseudo register's number really is assigned the number
     `FIRST_PSEUDO_REGISTER'.

`FIXED_REGISTERS'
     An initializer that says which registers are used for fixed
     purposes all throughout the compiled code and are therefore not
     available for general allocation.  These would include the stack
     pointer, the frame pointer (except on machines where that can be
     used as a general register when no frame pointer is needed), the
     program counter on machines where that is considered one of the
     addressable registers, and any other numbered register with a
     standard use.

     This information is expressed as a sequence of numbers,
     separated by commas and surrounded by braces.  The Nth number is
     1 if register N is fixed, 0 otherwise.

     The table initialized from this macro, and the table initialized
     by the following one, may be overridden at run time either
     automatically, by the actions of the macro
     `CONDITIONAL_REGISTER_USAGE', or by the user with the command
     options `-ffixed-REG', `-fcall-used-REG' and `-fcall-saved-REG'.

`CALL_USED_REGISTERS'
     Like `FIXED_REGISTERS' but has 1 for each register that is
     clobbered (in general) by function calls as well as for fixed
     registers.  This macro therefore identifies the registers that
     are not available for general allocation of values that must
     live across function calls.

     If a register has 0 in `CALL_USED_REGISTERS', the compiler
     automatically saves it on function entry and restores it on
     function exit, if the register is used within the function.

`DEFAULT_CALLER_SAVES'
     Define this macro if function calls on the target machine do not
     preserve any registers; in other words, if `CALL_USED_REGISTERS'
     has 1 for all registers.  This macro enables `-fcaller-saves' by
     default.  Eventually that option will be enabled by default on
     all machines and both the option and this macro will be
     eliminated.

`CONDITIONAL_REGISTER_USAGE'
     Zero or more C statements that may conditionally modify two
     variables `fixed_regs' and `call_used_regs' (both of type `char
     []') after they have been initialized from the two preceding
     macros.

     This is necessary in case the fixed or call-clobbered registers
     depend on target flags.

     You need not define this macro if it has no work to do.

     If the usage of an entire class of registers depends on the
     target flags, you may indicate this to GCC by using this macro
     to modify `fixed_regs' and `call_used_regs' to 1 for each of the
     registers in the classes which should not be used by GCC.  Also
     define the macro `REG_CLASS_FROM_LETTER' to return `NO_REGS' if
     it is called with a letter for a class that shouldn't be used.

     (However, if this class is not included in `GENERAL_REGS' and
     all of the insn patterns whose constraints permit this class are
     controlled by target switches, then GCC will automatically avoid
     using these registers when the target switches are opposed to
     them.)

`OVERLAPPING_REGNO_P (REGNO)'
     If defined, this is a C expression whose value is nonzero if
     hard register number REGNO is an overlapping register.  This
     means a hard register which overlaps a hard register with a
     different number.  (Such overlap is undesirable, but
     occasionally it allows a machine to be supported which otherwise
     could not be.)  This macro must return nonzero for *all* the
     registers which overlap each other.  GNU CC can use an
     overlapping register only in certain limited ways.  It can be
     used for allocation within a basic block, and may be spilled for
     reloading; that is all.

     If this macro is not defined, it means that none of the hard
     registers overlap each other.  This is the usual situation.

`INSN_CLOBBERS_REGNO_P (INSN, REGNO)'
     If defined, this is a C expression whose value should be nonzero
     if the insn INSN has the effect of mysteriously clobbering the
     contents of hard register number REGNO.  By "mysterious" we mean
     that the insn's RTL expression doesn't describe such an effect.

     If this macro is not defined, it means that no insn clobbers
     registers mysteriously.  This is the usual situation; all else
     being equal, it is best for the RTL expression to show all the
     activity.

`PRESERVE_DEATH_INFO_REGNO_P (REGNO)'
     If defined, this is a C expression whose value is nonzero if
     accurate `REG_DEAD' notes are needed for hard register number
     REGNO at the time of outputting the assembler code.  When this
     is so, a few optimizations that take place after register
     allocation and could invalidate the death notes are not done
     when this register is involved.

     You would arrange to preserve death info for a register when
     some of the code in the machine description which is executed to
     write the assembler code looks at the death notes.  This is
     necessary only when the actual hardware feature which GNU CC
     thinks of as a register is not actually a register of the usual
     sort.  (It might, for example, be a hardware stack.)

     If this macro is not defined, it means that no death notes need
     to be preserved.  This is the usual situation.

`HARD_REGNO_NREGS (REGNO, MODE)'
     A C expression for the number of consecutive hard registers,
     starting at register number REGNO, required to hold a value of
     mode MODE.

     On a machine where all registers are exactly one word, a
     suitable definition of this macro is

          #define HARD_REGNO_NREGS(REGNO, MODE)            \
             ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1)  \
              / UNITS_PER_WORD))

`HARD_REGNO_MODE_OK (REGNO, MODE)'
     A C expression that is nonzero if it is permissible to store a
     value of mode MODE in hard register number REGNO (or in several
     registers starting with that one).  For a machine where all
     registers are equivalent, a suitable definition is

          #define HARD_REGNO_MODE_OK(REGNO, MODE) 1

     It is not necessary for this macro to check for the numbers of
     fixed registers, because the allocation mechanism considers them
     to be always occupied.

     On some machines, double-precision values must be kept in
     even/odd register pairs.  The way to implement that is to define
     this macro to reject odd register numbers for such modes.

     GNU CC assumes that it can always move values between registers
     and (suitably addressed) memory locations.  If it is impossible
     to move a value of a certain mode between memory and certain
     registers, then `HARD_REGNO_MODE_OK' must not allow this mode in
     those registers.

     Many machines have special registers for floating point
     arithmetic.  Often people assume that floating point machine
     modes are allowed only in floating point registers.  This is not
     true.  Any registers that can hold integers can safely *hold* a
     floating point machine mode, whether or not floating arithmetic
     can be done on it in those registers.

     On some machines, though, the converse is true: fixed-point
     machine modes may not go in floating registers.  This is true if
     the floating registers normalize any value stored in them,
     because storing a non-floating value there would garble it.  In
     this case, `HARD_REGNO_MODE_OK' should reject fixed-point
     machine modes in floating registers.  But if the floating
     registers do not automatically normalize, if you can store any
     bit pattern in one and retrieve it unchanged without a trap,
     then any machine mode may go in a floating register and this
     macro should say so.

     The primary significance of special floating registers is rather
     that they are the registers acceptable in floating point
     arithmetic instructions.  However, this is of no concern to
     `HARD_REGNO_MODE_OK'.  You handle it by writing the proper
     constraints for those instructions.

     On some machines, the floating registers are especially slow to
     access, so that it is better to store a value in a stack frame
     than in such a register if floating point arithmetic is not
     being done.  As long as the floating registers are not in class
     `GENERAL_REGS', they will not be used unless some insn's
     constraint asks for one.

`MODES_TIEABLE_P (MODE1, MODE2)'
     A C expression that is nonzero if it is desirable to choose
     register allocation so as to avoid move instructions between a
     value of mode MODE1 and a value of mode MODE2.

     If `HARD_REGNO_MODE_OK (R, MODE1)' and `HARD_REGNO_MODE_OK (R,
     MODE2)' are ever different for any R, then `MODES_TIEABLE_P
     (MODE1, MODE2)' must be zero.

`PC_REGNUM'
     If the program counter has a register number, define this as
     that register number.  Otherwise, do not define it.

`STACK_POINTER_REGNUM'
     The register number of the stack pointer register, which must
     also be a fixed register according to `FIXED_REGISTERS'.  On
     many machines, the hardware determines which register this is.

`FRAME_POINTER_REGNUM'
     The register number of the frame pointer register, which is used
     to access automatic variables in the stack frame.  On some
     machines, the hardware determines which register this is.  On
     other machines, you can choose any register you wish for this
     purpose.

`FRAME_POINTER_REQUIRED'
     A C expression which is nonzero if a function must have and use
     a frame pointer.  This expression is evaluated twice: at the
     beginning of generating RTL, and in the reload pass.  If its
     value is nonzero at either time, then the function will have a
     frame pointer.

     The expression can in principle examine the current function and
     decide according to the facts, but on most machines the constant
     0 or the constant 1 suffices.  Use 0 when the machine allows
     code to be generated with no frame pointer, and doing so saves
     some time or space.  Use 1 when there is no possible advantage
     to avoiding a frame pointer.

     In certain cases, the compiler does not know how to produce
     valid code without a frame pointer.  The compiler recognizes
     those cases and automatically gives the function a frame pointer
     regardless of what `FRAME_POINTER_REQUIRED' says.  You don't
     need to worry about them.

     In a function that does not require a frame pointer, the frame
     pointer register can be allocated for ordinary usage, unless you
     mark it as a fixed register.  See `FIXED_REGISTERS' for more
     information.

`ARG_POINTER_REGNUM'
     The register number of the arg pointer register, which is used
     to access the function's argument list.  On some machines, this
     is the same as the frame pointer register.  On some machines,
     the hardware determines which register this is.  On other
     machines, you can choose any register you wish for this purpose.
     If this is not the same register as the frame pointer register,
     then you must mark it as a fixed register according to
     `FIXED_REGISTERS'.

`STATIC_CHAIN_REGNUM'
     The register number used for passing a function's static chain
     pointer.  This is needed for languages such as Pascal and Algol
     where functions defined within other functions can access the
     local variables of the outer functions; it is not currently used
     because C does not provide this feature, but you must define the
     macro.

     The static chain register need not be a fixed register.

`STRUCT_VALUE_REGNUM'
     When a function's value's mode is `BLKmode', the value is not
     returned according to `FUNCTION_VALUE'.  Instead, the caller
     passes the address of a block of memory in which the value
     should be stored.

     If this value is passed in a register, then
     `STRUCT_VALUE_REGNUM' should be the number of that register.

`STRUCT_VALUE'
     If the structure value address is not passed in a register,
     define `STRUCT_VALUE' as an expression returning an RTX for the
     place where the address is passed.  If it returns a `mem' RTX,
     the address is passed as an "invisible" first argument.

`STRUCT_VALUE_INCOMING_REGNUM'
     On some architectures the place where the structure value
     address is found by the called function is not the same place
     that the caller put it.  This can be due to register windows, or
     it could be because the function prologue moves it to a
     different place.

     If the incoming location of the structure value address is in a
     register, define this macro as the register number.

`STRUCT_VALUE_INCOMING'
     If the incoming location is not a register, define
     `STRUCT_VALUE_INCOMING' as an expression for an RTX for where
     the called function should find the value.  If it should find
     the value on the stack, define this to create a `mem' which
     refers to the frame pointer.  If the value is a `mem', the
     compiler assumes it is for an invisible first argument, and
     leaves space for it when finding the first real argument.

`REG_ALLOC_ORDER'
     If defined, an initializer for a vector of integers, containing
     the numbers of hard registers in the order in which the GNU CC
     should prefer to use them (from most preferred to least).

     If this macro is not defined, registers are used lowest numbered
     first (all else being equal).

     One use of this macro is on the 360, where the highest numbered
     registers must always be saved and the save-multiple-registers
     instruction supports only sequences of consecutive registers. 
     This macro is defined to cause the highest numbered allocatable
     registers to be used first.


File: gcc.info,  Node: Register Classes,  Next: Stack Layout,  Prev: Registers,  Up: Machine Macros

Register Classes
================

   On many machines, the numbered registers are not all equivalent. 
For example, certain registers may not be allowed for indexed
addressing; certain registers may not be allowed in some
instructions.  These machine restrictions are described to the
compiler using "register classes".

   You define a number of register classes, giving each one a name
and saying which of the registers belong to it.  Then you can specify
register classes that are allowed as operands to particular
instruction patterns.

   In general, each register will belong to several classes.  In
fact, one class must be named `ALL_REGS' and contain all the
registers.  Another class must be named `NO_REGS' and contain no
registers.  Often the union of two classes will be another class;
however, this is not required.

   One of the classes must be named `GENERAL_REGS'.  There is nothing
terribly special about the name, but the operand constraint letters
`r' and `g' specify this class.  If `GENERAL_REGS' is the same as
`ALL_REGS', just define it as a macro which expands to `ALL_REGS'.

   The way classes other than `GENERAL_REGS' are specified in operand
constraints is through machine-dependent operand constraint letters. 
You can define such letters to correspond to various classes, then
use them in operand constraints.

   You should define a class for the union of two classes whenever
some instruction allows both classes.  For example, if an instruction
allows either a floating-point (coprocessor) register or a general
register for a certain operand, you should define a class
`FLOAT_OR_GENERAL_REGS' which includes both of them.  Otherwise you
will get suboptimal code.

   You must also specify certain redundant information about the
register classes: for each class, which classes contain it and which
ones are contained in it; for each pair of classes, the largest class
contained in their union.

   When a value occupying several consecutive registers is expected
in a certain class, all the registers used must belong to that class.
Therefore, register classes cannot be used to enforce a requirement
for a register pair to start with an even-numbered register.  The way
to specify this requirement is with `HARD_REGNO_MODE_OK'.

   Register classes used for input-operands of bitwise-and or shift
instructions have a special requirement: each such class must have,
for each fixed-point machine mode, a subclass whose registers can
transfer that mode to or from memory.  For example, on some machines,
the operations for single-byte values (`QImode') are limited to
certain registers.  When this is so, each register class that is used
in a bitwise-and or shift instruction must have a subclass consisting
of registers from which single-byte values can be loaded or stored. 
This is so that `PREFERRED_RELOAD_CLASS' can always have a possible
value to return.

`enum reg_class'
     An enumeral type that must be defined with all the register
     class names as enumeral values.  `NO_REGS' must be first. 
     `ALL_REGS' must be the last register class, followed by one more
     enumeral value, `LIM_REG_CLASSES', which is not a register class
     but rather tells how many classes there are.

     Each register class has a number, which is the value of casting
     the class name to type `int'.  The number serves as an index in
     many of the tables described below.

`N_REG_CLASSES'
     The number of distinct register classes, defined as follows:

          #define N_REG_CLASSES (int) LIM_REG_CLASSES

`REG_CLASS_NAMES'
     An initializer containing the names of the register classes as C
     string constants.  These names are used in writing some of the
     debugging dumps.

`REG_CLASS_CONTENTS'
     An initializer containing the contents of the register classes,
     as integers which are bit masks.  The Nth integer specifies the
     contents of class N.  The way the integer MASK is interpreted is
     that register R is in the class if `MASK & (1 << R)' is 1.

     When the machine has more than 32 registers, an integer does not
     suffice.  Then the integers are replaced by sub-initializers,
     braced groupings containing several integers.  Each
     sub-initializer must be suitable as an initializer for the type
     `HARD_REG_SET' which is defined in `hard-reg-set.h'.

`REGNO_REG_CLASS (REGNO)'
     A C expression whose value is a register class containing hard
     register REGNO.  In general there is more that one such class;
     choose a class which is "minimal", meaning that no smaller class
     also contains the register.

`BASE_REG_CLASS'
     A macro whose definition is the name of the class to which a
     valid base register must belong.  A base register is one used in
     an address which is the register value plus a displacement.

`INDEX_REG_CLASS'
     A macro whose definition is the name of the class to which a
     valid index register must belong.  An index register is one used
     in an address where its value is either multiplied by a scale
     factor or added to another register (as well as added to a
     displacement).

`REG_CLASS_FROM_LETTER (CHAR)'
     A C expression which defines the machine-dependent operand
     constraint letters for register classes.  If CHAR is such a
     letter, the value should be the register class corresponding to
     it.  Otherwise, the value should be `NO_REGS'.

`REGNO_OK_FOR_BASE_P (NUM)'
     A C expression which is nonzero if register number NUM is
     suitable for use as a base register in operand addresses.  It
     may be either a suitable hard register or a pseudo register that
     has been allocated such a hard register.

`REGNO_OK_FOR_INDEX_P (NUM)'
     A C expression which is nonzero if register number NUM is
     suitable for use as an index register in operand addresses.  It
     may be either a suitable hard register or a pseudo register that
     has been allocated such a hard register.

     The difference between an index register and a base register is
     that the index register may be scaled.  If an address involves
     the sum of two registers, neither one of them scaled, then
     either one may be labeled the "base" and the other the "index";
     but whichever labeling is used must fit the machine's
     constraints of which registers may serve in each capacity.  The
     compiler will try both labelings, looking for one that is valid,
     and will reload one or both registers only if neither labeling
     works.

`PREFERRED_RELOAD_CLASS (X, CLASS)'
     A C expression that places additional restrictions on the
     register class to use when it is necessary to copy value X into
     a register in class CLASS.  The value is a register class;
     perhaps CLASS, or perhaps another, smaller class.  On many
     machines, the definition

          #define PREFERRED_RELOAD_CLASS(X,CLASS) CLASS

     is safe.

     Sometimes returning a more restrictive class makes better code. 
     For example, on the 68000, when X is an integer constant that is
     in range for a `moveq' instruction, the value of this macro is
     always `DATA_REGS' as long as CLASS includes the data registers.
     Requiring a data register guarantees that a `moveq' will be used.

     If X is a `const_double', by returning `NO_REGS' you can force X
     into a memory constant.  This is useful on certain machines
     where immediate floating values cannot be loaded into certain
     kinds of registers.

     In a shift instruction or a bitwise-and instruction, the mode of
     X, the value being reloaded, may not be the same as the mode of
     the instruction's operand.  (They will both be fixed-point
     modes, however.)  In such a case, CLASS may not be a safe value
     to return.  CLASS is certainly valid for the instruction, but it
     may not be valid for reloading X.  This problem can occur on
     machines such as the 68000 and 80386 where some registers can
     handle full-word values but cannot handle single-byte values.

     On such machines, this macro must examine the mode of X and
     return a subclass of CLASS which can handle loads and stores of
     that mode.  On the 68000, where address registers cannot handle
     `QImode', if X has `QImode' then you must return `DATA_REGS'. 
     If CLASS is `ADDR_REGS', then there is no correct value to
     return; but the shift and bitwise-and instructions don't use
     `ADDR_REGS', so this fatal case never arises.

`CLASS_MAX_NREGS (CLASS, MODE)'
     A C expression for the maximum number of consecutive registers
     of class CLASS needed to hold a value of mode MODE.

     This is closely related to the macro `HARD_REGNO_NREGS'.  In
     fact, the value of the macro `CLASS_MAX_NREGS (CLASS, MODE)'
     should be the maximum value of `HARD_REGNO_NREGS (REGNO, MODE)'
     for all REGNO values in the class CLASS.

     This macro helps control the handling of multiple-word values in
     the reload pass.

   Two other special macros describe which constants fit which
constraint letters.

`CONST_OK_FOR_LETTER_P (VALUE, C)'
     A C expression that defines the machine-dependent operand
     constraint letters that specify particular ranges of integer
     values.  If C is one of those letters, the expression should
     check that VALUE, an integer, is in the appropriate range and
     return 1 if so, 0 otherwise.  If C is not one of those letters,
     the value should be 0 regardless of VALUE.

`CONST_DOUBLE_OK_FOR_LETTER_P (VALUE, C)'
     A C expression that defines the machine-dependent operand
     constraint letters that specify particular ranges of floating
     values.  If C is one of those letters, the expression should
     check that VALUE, an RTX of code `const_double', is in the
     appropriate range and return 1 if so, 0 otherwise.  If C is not
     one of those letters, the value should be 0 regardless of VALUE.


File: gcc.info,  Node: Stack Layout,  Next: Library Calls,  Prev: Register Classes,  Up: Machine Macros

Describing Stack Layout
=======================

`STACK_GROWS_DOWNWARD'
     Define this macro if pushing a word onto the stack moves the
     stack pointer to a smaller address.

     When we say, "define this macro if ...," it means that the
     compiler checks this macro only with `#ifdef' so the precise
     definition used does not matter.

`FRAME_GROWS_DOWNWARD'
     Define this macro if the addresses of local variable slots are
     at negative offsets from the frame pointer.

`STARTING_FRAME_OFFSET'
     Offset from the frame pointer to the first local variable slot
     to be allocated.

     If `FRAME_GROWS_DOWNWARD', the next slot's offset is found by
     subtracting the length of the first slot from
     `STARTING_FRAME_OFFSET'.  Otherwise, it is found by adding the
     length of the first slot to the value `STARTING_FRAME_OFFSET'.

`PUSH_ROUNDING (NPUSHED)'
     A C expression that is the number of bytes actually pushed onto
     the stack when an instruction attempts to push NPUSHED bytes.

     If the target machine does not have a push instruction, do not
     define this macro.  That directs GNU CC to use an alternate
     strategy: to allocate the entire argument block and then store
     the arguments into it.

     On some machines, the definition

          #define PUSH_ROUNDING(BYTES) (BYTES)

     will suffice.  But on other machines, instructions that appear
     to push one byte actually push two bytes in an attempt to
     maintain alignment.  Then the definition should be

          #define PUSH_ROUNDING(BYTES) (((BYTES) + 1) & ~1)

`FIRST_PARM_OFFSET (FUNDECL)'
     Offset from the argument pointer register to the first
     argument's address.  On some machines it may depend on the data
     type of the function.  (In the next version of GNU CC, the
     argument will be changed to the function data type rather than
     its declaration.)

`FIRST_PARM_CALLER_OFFSET (FUNDECL)'
     Define this macro on machines where register parameters have
     shadow locations on the stack, at addresses below the nominal
     parameter.  This matters because certain arguments cannot be
     passed on the stack.  On these machines, such arguments must be
     stored into the shadow locations.

     This macro should expand into a C expression whose value is the
     offset of the first parameter's shadow location from the nominal
     stack pointer value.  (That value is itself computed by adding
     the value of `STACK_POINTER_OFFSET' to the stack pointer
     register.)

`REG_PARM_STACK_SPACE'
     Define this macro if functions should assume that stack space
     has been allocated for arguments even when their values are
     passed in registers.

     The actual allocation of such space would be done either by the
     call instruction or by the function prologue, or by defining
     `FIRST_PARM_CALLER_OFFSET'.

`STACK_ARGS_ADJUST (SIZE)'
     Define this macro if the machine requires padding on the stack
     for certain function calls.  This is padding on a
     per-function-call basis, not padding for individual arguments.

     The argument SIZE will be a C variable of type `struct arg_data'
     which contains two fields, an integer named `constant' and an
     RTX named `var'.  These together represent a size measured in
     bytes which is the sum of the integer and the RTX.  Most of the
     time `var' is 0, which means that the size is simply the integer.

     The definition should be a C statement or compound statement
     which alters the variable supplied in whatever way you wish.

     Note that the value you leave in the variable `size' will
     ultimately be rounded up to a multiple of `STACK_BOUNDARY' bits.

     This macro is not fully implemented for machines which have push
     instructions (i.e., on which `PUSH_ROUNDING' is defined).

`RETURN_POPS_ARGS (FUNTYPE)'
     A C expression that should be 1 if a function pops its own
     arguments on returning, or 0 if the function pops no arguments
     and the caller must therefore pop them all after the function
     returns.

     FUNTYPE is a C variable whose value is a tree node that
     describes the function in question.  Normally it is a node of
     type `FUNCTION_TYPE' that describes the data type of the function.
     From this it is possible to obtain the data types of the value
     and arguments (if known).

     When a call to a library function is being considered, FUNTYPE
     will contain an identifier node for the library function.  Thus,
     if you need to distinguish among various library functions, you
     can do so by their names.  Note that "library function" in this
     context means a function used to perform arithmetic, whose name
     is known specially in the compiler and was not mentioned in the
     C code being compiled.

     On the Vax, all functions always pop their arguments, so the
     definition of this macro is 1.  On the 68000, using the standard
     calling convention, no functions pop their arguments, so the
     value of the macro is always 0 in this case.  But an alternative
     calling convention is available in which functions that take a
     fixed number of arguments pop them but other functions (such as
     `printf') pop nothing (the caller pops all).  When this
     convention is in use, FUNTYPE is examined to determine whether a
     function takes a fixed number of arguments.

     When this macro returns nonzero, the macro
     `FRAME_POINTER_REQUIRED' must also return nonzero for proper
     operation.

`FUNCTION_VALUE (VALTYPE, FUNC)'
     A C expression to create an RTX representing the place where a
     function returns a value of data type VALTYPE.  VALTYPE is a
     tree node representing a data type.  Write `TYPE_MODE (VALTYPE)'
     to get the machine mode used to represent that type.  On many
     machines, only the mode is relevant.  (Actually, on most
     machines, scalar values are returned in the same place
     regardless of mode).

     If the precise function being called is known, FUNC is a tree
     node (`FUNCTION_DECL') for it; otherwise, FUNC is a null
     pointer.  This makes it possible to use a different
     value-returning convention for specific functions when all their
     calls are known.

`FUNCTION_OUTGOING_VALUE (VALTYPE, FUNC)'
     Define this macro if the target machine has "register windows"
     so that the register in which a function returns its value is
     not the same as the one in which the caller sees the value.

     For such machines, `FUNCTION_VALUE' computes the register in
     which the caller will see the value, and
     `FUNCTION_OUTGOING_VALUE' should be defined in a similar fashion
     to tell the function where to put the value.

     If `FUNCTION_OUTGOING_VALUE' is not defined, `FUNCTION_VALUE'
     serves both purposes.

`RETURN_IN_MEMORY (TYPE)'
     A C expression which can inhibit the returning of certain
     function values in registers, based on the type of value.  A
     nonzero value says to return the function value in memory, just
     as large structures are always returned.  Here TYPE will be a C
     expression of type `tree', representing the data type of the
     value.

     Note that values of mode `BLKmode' are returned in memory
     regardless of this macro.  Also, the option
     `-fpcc-struct-return' takes effect regardless of this macro.  On
     most systems, it is possible to leave the macro undefined; this
     causes a default definition to be used, whose value is the
     constant 0.

`LIBCALL_VALUE (MODE)'
     A C expression to create an RTX representing the place where a
     library function returns a value of mode MODE.  If the precise
     function being called is known, FUNC is a tree node
     (`FUNCTION_DECL') for it; otherwise, FUNC is a null pointer. 
     This makes it possible to use a different value-returning
     convention for specific functions when all their calls are known.

     Note that "library function" in this context means a compiler
     support routine, used to perform arithmetic, whose name is known
     specially by the compiler and was not mentioned in the C code
     being compiled.

`FUNCTION_VALUE_REGNO_P (REGNO)'
     A C expression that is nonzero if REGNO is the number of a hard
     register in which the values of called function may come back.

     A register whose use for returning values is limited to serving
     as the second of a pair (for a value of type `double', say) need
     not be recognized by this macro.  So for most machines, this
     definition suffices:

          #define FUNCTION_VALUE_REGNO_P(N) ((N) == 0)

     If the machine has register windows, so that the caller and the
     called function use different registers for the return value,
     this macro should recognize only the caller's register numbers.

`FUNCTION_ARG (CUM, MODE, TYPE, NAMED)'
     A C expression that controls whether a function argument is
     passed in a register, and which register.

     The arguments are CUM, which summarizes all the previous
     arguments; MODE, the machine mode of the argument; TYPE, the
     data type of the argument as a tree node or 0 if that is not
     known (which happens for C support library functions); and
     NAMED, which is 1 for an ordinary argument and 0 for nameless
     arguments that correspond to `...' in the called function's
     prototype.

     The value of the expression should either be a `reg' RTX for the
     hard register in which to pass the argument, or zero to pass the
     argument on the stack.

     For the Vax and 68000, where normally all arguments are pushed,
     zero suffices as a definition.

     The usual way to make the ANSI library `stdarg.h' work on a
     machine where some arguments are usually passed in registers, is
     to cause nameless arguments to be passed on the stack instead. 
     This is done by making `FUNCTION_ARG' return 0 whenever NAMED is
     0.

`FUNCTION_INCOMING_ARG (CUM, MODE, TYPE, NAMED)'
     Define this macro if the target machine has "register windows",
     so that the register in which a function sees an arguments is
     not necessarily the same as the one in which the caller passed
     the argument.

     For such machines, `FUNCTION_ARG' computes the register in which
     the caller passes the value, and `FUNCTION_INCOMING_ARG' should
     be defined in a similar fashion to tell the function being
     called where the arguments will arrive.

     If `FUNCTION_INCOMING_ARG' is not defined, `FUNCTION_ARG' serves
     both purposes.

`FUNCTION_ARG_PARTIAL_NREGS (CUM, MODE, TYPE, NAMED)'
     A C expression for the number of words, at the beginning of an
     argument, must be put in registers.  The value must be zero for
     arguments that are passed entirely in registers or that are
     entirely pushed on the stack.

     On some machines, certain arguments must be passed partially in
     registers and partially in memory.  On these machines, typically
     the first N words of arguments are passed in registers, and the
     rest on the stack.  If a multi-word argument (a `double' or a
     structure) crosses that boundary, its first few words must be
     passed in registers and the rest must be pushed.  This macro
     tells the compiler when this occurs, and how many of the words
     should go in registers.

     `FUNCTION_ARG' for these arguments should return the first
     register to be used by the caller for this argument; likewise
     `FUNCTION_INCOMING_ARG', for the called function.

`CUMULATIVE_ARGS'
     A C type for declaring a variable that is used as the first
     argument of `FUNCTION_ARG' and other related values.  For some
     target machines, the type `int' suffices and can hold the number
     of bytes of argument so far.

`INIT_CUMULATIVE_ARGS (CUM, FNTYPE)'
     A C statement (sans semicolon) for initializing the variable CUM
     for the state at the beginning of the argument list.  The
     variable has type `CUMULATIVE_ARGS'.  The value of FNTYPE is the
     tree node for the data type of the function which will receive
     the args, or 0 if the args are to a compiler support library
     function.

`FUNCTION_ARG_ADVANCE (CUM, MODE, TYPE, NAMED)'
     A C statement (sans semicolon) to update the summarizer variable
     CUM to advance past an argument in the argument list.  The
     values MODE, TYPE and NAMED describe that argument.  Once this
     is done, the variable CUM is suitable for analyzing the
     *following* argument with `FUNCTION_ARG', etc.

`FUNCTION_ARG_REGNO_P (REGNO)'
     A C expression that is nonzero if REGNO is the number of a hard
     register in which function arguments are sometimes passed.  This
     does *not* include implicit arguments such as the static chain
     and the structure-value address.  On many machines, no registers
     can be used for this purpose since all function arguments are
     pushed on the stack.

`FUNCTION_ARG_PADDING (MODE, SIZE)'
     If defined, a C expression which determines whether, and in
     which direction, to pad out an argument with extra space.  The
     value should be of type `enum direction': either `upward' to pad
     above the argument, `downward' to pad below, or `none' to
     inhibit padding.

     The argument SIZE is an RTX which describes the size of the
     argument, in bytes.  It should be used only if MODE is
     `BLKmode'.  Otherwise, SIZE is 0.

     This macro does not control the *amount* of padding; that is
     always just enough to reach the next multiple of `PARM_BOUNDARY'.

     This macro has a default definition which is right for most
     systems.  For little-endian machines, the default is to pad
     upward.  For big-endian machines, the default is to pad downward
     for an argument of constant size shorter than an `int', and
     upward otherwise.

`FUNCTION_PROLOGUE (FILE, SIZE)'
     A C compound statement that outputs the assembler code for entry
     to a function.  The prologue is responsible for setting up the
     stack frame, initializing the frame pointer register, saving
     registers that must be saved, and allocating SIZE additional
     bytes of storage for the local variables.  SIZE is an integer. 
     FILE is a stdio stream to which the assembler code should be
     output.

     The label for the beginning of the function need not be output
     by this macro.  That has already been done when the macro is run.

     To determine which registers to save, the macro can refer to the
     array `regs_ever_live': element R is nonzero if hard register R
     is used anywhere within the function.  This implies the function
     prologue should save register R, but not if it is one of the
     call-used registers.

     On machines where functions may or may not have frame-pointers,
     the function entry code must vary accordingly; it must set up
     the frame pointer if one is wanted, and not otherwise.  To
     determine whether a frame pointer is in wanted, the macro can
     refer to the variable `frame_pointer_needed'.  The variable's
     value will be 1 at run time in a function that needs a frame
     pointer.

     On machines where an argument may be passed partly in registers
     and partly in memory, this macro must examine the variable
     `current_function_pretend_args_size', and allocate that many
     bytes of uninitialized space on the stack just underneath the
     first argument arriving on the stack.  (This may not be at the
     very end of the stack, if the calling sequence has pushed
     anything else since pushing the stack arguments.  But usually,
     on such machines, nothing else has been pushed yet, because the
     function prologue itself does all the pushing.)

`FUNCTION_PROFILER (FILE, LABELNO)'
     A C statement or compound statement to output to FILE some
     assembler code to call the profiling subroutine `mcount'. 
     Before calling, the assembler code must load the address of a
     counter variable into a register where `mcount' expects to find
     the address.  The name of this variable is `LP' followed by the
     number LABELNO, so you would generate the name using `LP%d' in a
     `fprintf'.

     The details of how the address should be passed to `mcount' are
     determined by your operating system environment, not by GNU CC. 
     To figure them out, compile a small program for profiling using
     the system's installed C compiler and look at the assembler code
     that results.

`FUNCTION_BLOCK_PROFILER (FILE, LABELNO)'
     A C statement or compound statement to output to FILE some
     assembler code to initialize basic-block profiling for the
     current object module.  This code should call the subroutine
     `__bb_init_func' once per object module, passing it as its sole
     argument the address of a block allocated in the object module.

     The name of the block is a local symbol made with this statement:

          ASM_GENERATE_INTERNAL_LABEL (BUFFER, "LPBX", 0);

     Of course, since you are writing the definition of
     `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you
     can take a short cut in the definition of this macro and use the
     name that you know will result.

     The first word of this block is a flag which will be nonzero if
     the object module has already been initialized.  So test this
     word first, and do not call `__bb_init_func' if the flag is
     nonzero.

`BLOCK_PROFILER (FILE, BLOCKNO)'
     A C statement or compound statement to increment the count
     associated with the basic block number BLOCKNO.  Basic blocks
     are numbered separately from zero within each compilation.  The
     count associated with block number BLOCKNO is at index BLOCKNO
     in a vector of words; the name of this array is a local symbol
     made with this statement:

          ASM_GENERATE_INTERNAL_LABEL (BUFFER, "LPBX", 2);

     Of course, since you are writing the definition of
     `ASM_GENERATE_INTERNAL_LABEL' as well as that of this macro, you
     can take a short cut in the definition of this macro and use the
     name that you know will result.

`EXIT_IGNORE_STACK'
     Define this macro as a C expression that is nonzero if the
     return instruction or the function epilogue ignores the value of
     the stack pointer; in other words, if it is safe to delete an
     instruction to adjust the stack pointer before a return from the
     function.

     Note that this macro's value is relevant only for functions for
     which frame pointers are maintained.  It is never safe to delete
     a final stack adjustment in a function that has no frame
     pointer, and the compiler knows this regardless of
     `EXIT_IGNORE_STACK'.

`FUNCTION_EPILOGUE (FILE, SIZE)'
     A C compound statement that outputs the assembler code for exit
     from a function.  The epilogue is responsible for restoring the
     saved registers and stack pointer to their values when the
     function was called, and returning control to the caller.  This
     macro takes the same arguments as the macro `FUNCTION_PROLOGUE',
     and the registers to restore are determined from
     `regs_ever_live' and `CALL_USED_REGISTERS' in the same way.

     On some machines, there is a single instruction that does all
     the work of returning from the function.  On these machines,
     give that instruction the name `return' and do not define the
     macro `FUNCTION_EPILOGUE' at all.

     Do not define a pattern named `return' if you want the
     `FUNCTION_EPILOGUE' to be used.  If you want the target switches
     to control whether return instructions or epilogues are used,
     define a `return' pattern with a validity condition that tests
     the target switches appropriately.  If the `return' pattern's
     validity condition is false, epilogues will be used.

     On machines where functions may or may not have frame-pointers,
     the function exit code must vary accordingly.  Sometimes the
     code for these two cases is completely different.  To determine
     whether a frame pointer is in wanted, the macro can refer to the
     variable `frame_pointer_needed'.  The variable's value will be 1
     at run time in a function that needs a frame pointer.

     On some machines, some functions pop their arguments on exit
     while others leave that for the caller to do.  For example, the
     68020 when given `-mrtd' pops arguments in functions that take a
     fixed number of arguments.

     Your definition of the macro `RETURN_POPS_ARGS' decides which
     functions pop their own arguments.  `FUNCTION_EPILOGUE' needs to
     know what was decided.  The variable
     `current_function_pops_args' is nonzero if the function should
     pop its own arguments.  If so, use the variable
     `current_function_args_size' as the number of bytes to pop.

`FIX_FRAME_POINTER_ADDRESS (ADDR, DEPTH)'
     A C compound statement to alter a memory address that uses the
     frame pointer register so that it uses the stack pointer
     register instead.  This must be done in the instructions that
     load parameter values into registers, when the reload pass
     determines that a frame pointer is not necessary for the
     function.  ADDR will be a C variable name, and the updated
     address should be stored in that variable.  DEPTH will be the
     current depth of stack temporaries (number of bytes of arguments
     currently pushed).  The change in offset between a
     frame-pointer-relative address and a stack-pointer-relative
     address must include DEPTH.

     Even if your machine description specifies there will always be
     a frame pointer in the frame pointer register, you must still
     define `FIX_FRAME_POINTER_ADDRESS', but the definition will
     never be executed at run time, so it may be empty.

`LONGJMP_RESTORE_FROM_STACK'
     Define this macro if the `longjmp' function restores registers
     from the stack frames, rather than from those saved specifically
     by `setjmp'.  Certain quantities must not be kept in registers
     across a call to `setjmp' on such machines.


File: gcc.info,  Node: Library Calls,  Next: Addressing Modes,  Prev: Stack Layout,  Up: Machine Macros

Implicit Use of Library Routines
================================

`MULSI3_LIBCALL'
     A C string constant giving the name of the function to call for
     multiplication of one signed full-word by another.  If you do
     not define this macro, the default name is used, which is
     `__mulsi3', a function defined in `gnulib'.

`UMULSI3_LIBCALL'
     A C string constant giving the name of the function to call for
     multiplication of one unsigned full-word by another.  If you do
     not define this macro, the default name is used, which is
     `__umulsi3', a function defined in `gnulib'.

`DIVSI3_LIBCALL'
     A C string constant giving the name of the function to call for
     division of one signed full-word by another.  If you do not
     define this macro, the default name is used, which is
     `__divsi3', a function defined in `gnulib'.

`UDIVSI3_LIBCALL'
     A C string constant giving the name of the function to call for
     division of one unsigned full-word by another.  If you do not
     define this macro, the default name is used, which is
     `__udivsi3', a function defined in `gnulib'.

`MODSI3_LIBCALL'
     A C string constant giving the name of the function to call for
     the remainder in division of one signed full-word by another. 
     If you do not define this macro, the default name is used, which
     is `__modsi3', a function defined in `gnulib'.

`UMODSI3_LIBCALL'
     A C string constant giving the name of the function to call for
     the remainder in division of one unsigned full-word by another. 
     If you do not define this macro, the default name is used, which
     is `__umodsi3', a function defined in `gnulib'.

`TARGET_MEM_FUNCTIONS'
     Define this macro if GNU CC should generate calls to the System
     V (and ANSI C) library functions `memcpy' and `memset' rather
     than the BSD functions `bcopy' and `bzero'.

`GNULIB_NEEDS_DOUBLE'
     Define this macro if only `float' arguments cannot be passed to
     library routines (so they must be converted to `double').  This
     macro affects both how library calls are generated and how the
     library routines in `gnulib.c' accept their arguments.  It is
     useful on machines where floating and fixed point arguments are
     passed differently, such as the i860.

