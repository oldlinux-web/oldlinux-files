This is Info file ./gdb.info, produced by Makeinfo-1.47 from the input
file gdb-all.texi.

START-INFO-DIR-ENTRY
* Gdb: (gdb).                   The GNU debugger.
END-INFO-DIR-ENTRY
   This file documents the GNU debugger GDB.

   This is Edition 4.06, July 1992, of `Debugging with GDB: the GNU
Source-Level Debugger' for GDB Version 4.6.

   Copyright (C) 1988, 1989, 1990, 1991, 1992 Free Software Foundation,
Inc.

   Permission is granted to make and distribute verbatim copies of this
manual provided the copyright notice and this permission notice are
preserved on all copies.

   Permission is granted to copy and distribute modified versions of
this manual under the conditions for verbatim copying, provided also
that the section entitled "GNU General Public License" is included
exactly as in the original, and provided that the entire resulting
derived work is distributed under the terms of a permission notice
identical to this one.

   Permission is granted to copy and distribute translations of this
manual into another language, under the above conditions for modified
versions, except that the section entitled "GNU General Public License"
may be included in a translation approved by the Free Software
Foundation instead of in the original English.


File: gdb.info,  Node: Assignment,  Next: Jumping,  Prev: Altering,  Up: Altering

Assignment to Variables
=======================

   To alter the value of a variable, evaluate an assignment expression.
*Note Expressions: Expressions.  For example,

     print x=4

stores the value 4 into the variable `x', and then prints the value of
the assignment expression (which is 4).  *Note Using GDB with Different
Languages: Languages, for more information on operators in supported
languages.

   If you are not interested in seeing the value of the assignment, use
the `set' command instead of the `print' command.  `set' is really the
same as `print' except that the expression's value is not printed and
is not put in the value history (*note Value History: Value History.). 
The expression is evaluated only for its effects.

   If the beginning of the argument string of the `set' command appears
identical to a `set' subcommand, use the `set variable' command instead
of just `set'.  This command is identical to `set' except for its lack
of subcommands.  For example, a program might well have a variable
`width'--which leads to an error if we try to set a new value with just
`set width=13', as we might if `set width' did not happen to be a GDB
command:

     (gdb) whatis width
     type = double
     (gdb) p width
     $4 = 13
     (gdb) set width=47
     Invalid syntax in expression.

The invalid expression, of course, is `=47'.  What we can do in order
to actually set our program's variable `width' is

     (gdb) set var width=47

   GDB allows more implicit conversions in assignments than C; you can
freely store an integer value into a pointer variable or vice versa,
and any structure can be converted to any other structure that is the
same length or shorter.

   To store values into arbitrary places in memory, use the `{...}'
construct to generate a value of specified type at a specified address
(*note Expressions: Expressions.).  For example, `{int}0x83040' refers
to memory location `0x83040' as an integer (which implies a certain size
and representation in memory), and

     set {int}0x83040 = 4

stores the value 4 into that memory location.


File: gdb.info,  Node: Jumping,  Next: Signaling,  Prev: Assignment,  Up: Altering

Continuing at a Different Address
=================================

   Ordinarily, when you continue your program, you do so at the place
where it stopped, with the `continue' command.  You can instead
continue at an address of your own choosing, with the following
commands:

`jump LINESPEC'
     Resume execution at line LINESPEC.  Execution will stop
     immediately if there is a breakpoint there.  *Note Printing Source
     Lines: List, for a description of the different forms of LINESPEC.

     The `jump' command does not change the current stack frame, or the
     stack pointer, or the contents of any memory location or any
     register other than the program counter.  If line LINESPEC is in a
     different function from the one currently executing, the results
     may be bizarre if the two functions expect different patterns of
     arguments or of local variables.  For this reason, the `jump'
     command requests confirmation if the specified line is not in the
     function currently executing.  However, even bizarre results are
     predictable if you are well acquainted with the machine-language
     code of your program.

`jump *ADDRESS'
     Resume execution at the instruction at address ADDRESS.

   You can get much the same effect as the `jump' command by storing a
new value into the register `$pc'.  The difference is that this does
not start your program running; it only changes the address where it
*will* run when it is continued.  For example,

     set $pc = 0x485

causes the next `continue' command or stepping command to execute at
address `0x485', rather than at the address where your program stopped.
*Note Continuing and Stepping: Continuing and Stepping.

   The most common occasion to use the `jump' command is to back up,
perhaps with more breakpoints set, over a portion of a program that has
already executed, in order to examine its execution in more detail.


File: gdb.info,  Node: Signaling,  Next: Returning,  Prev: Jumping,  Up: Altering

Giving your program a Signal
============================

`signal SIGNALNUM'
     Resume execution where your program stopped, but give it
     immediately the signal number SIGNALNUM.

     Alternatively, if SIGNALNUM is zero, continue execution without
     giving a signal.  This is useful when your program stopped on
     account of a signal and would ordinary see the signal when resumed
     with the `continue' command; `signal 0' causes it to resume
     without a signal.

     `signal' does not repeat when you press RET a second time after
     executing the command.


File: gdb.info,  Node: Returning,  Next: Calling,  Prev: Signaling,  Up: Altering

Returning from a Function
=========================

`return'
`return EXPRESSION'
     You can cancel execution of a function call with the `return'
     command.  If you give an EXPRESSION argument, its value is used as
     the function's return value.

   When you use `return', GDB discards the selected stack frame (and
all frames within it).  You can think of this as making the discarded
frame return prematurely.  If you wish to specify a value to be
returned, give that value as the argument to `return'.

   This pops the selected stack frame (*note Selecting a Frame:
Selection.), and any other frames inside of it, leaving its caller as
the innermost remaining frame.  That frame becomes selected.  The
specified value is stored in the registers used for returning values of
functions.

   The `return' command does not resume execution; it leaves the
program stopped in the state that would exist if the function had just
returned.  In contrast, the `finish' command (*note Continuing and
Stepping: Continuing and Stepping.) resumes execution until the
selected stack frame returns naturally.


File: gdb.info,  Node: Calling,  Next: Patching,  Prev: Returning,  Up: Altering

Calling your Program's Functions
================================

`call EXPR'
     Evaluate the expression EXPR without displaying `void' returned
     values.

   You can use this variant of the `print' command if you want to
execute a function from your program, but without cluttering the output
with `void' returned values.  The result is printed and saved in the
value history, if it is not void.


File: gdb.info,  Node: Patching,  Prev: Calling,  Up: Altering

Patching your Program
=====================

   By default, GDB opens the file containing your program's executable
code (or the corefile) read-only.  This prevents accidental alterations
to machine code; but it also prevents you from intentionally patching
your program's binary.

   If you'd like to be able to patch the binary, you can specify that
explicitly with the `set write' command.  For example, you might want
to turn on internal debugging flags, or even to make emergency repairs.

`set write on'
`set write off'
     If you specify `set write on', GDB will open executable and core
     files for both reading and writing; if you specify `set write off'
     (the default), GDB will open them read-only.

     If you have already loaded a file, you must load it again (using
     the `exec-file' or `core-file' command) after changing `set
     write', for your new setting to take effect.

`show write'
     Display whether executable files and core files will be opened for
     writing as well as reading.


File: gdb.info,  Node: GDB Files,  Next: Targets,  Prev: Altering,  Up: Top

GDB's Files
***********

   GDB needs to know the file name of the program to be debugged, both
in order to read its symbol table and in order to start your program. 
To debug a core dump of a previous run, GDB must be told the file name
of the core dump.

* Menu:

* Files::                       Commands to Specify Files
* Symbol Errors::               Errors Reading Symbol Files


File: gdb.info,  Node: Files,  Next: Symbol Errors,  Prev: GDB Files,  Up: GDB Files

Commands to Specify Files
=========================

   The usual way to specify executable and core dump file names is with
the command arguments given when you start GDB, (*note Getting In and
Out of GDB: Invocation..

   Occasionally it is necessary to change to a different file during a
GDB session.  Or you may run GDB and forget to specify the files you
want to use.  In these situations the GDB commands to specify new files
are useful.

`file FILENAME'
     Use FILENAME as the program to be debugged.  It is read for its
     symbols and for the contents of pure memory.  It is also the
     program executed when you use the `run' command.  If you do not
     specify a directory and the file is not found in GDB's working
     directory, GDB uses the environment variable `PATH' as a list of
     directories to search, just as the shell does when looking for a
     program to run.  You can change the value of this variable, for
     both GDB and your program, using the `path' command.

     On systems with memory-mapped files, an auxiliary symbol table file
     `FILENAME.syms' may be available for FILENAME.  If it is, GDB will
     map in the symbol table from `FILENAME.syms', starting up more
     quickly.  See the descriptions of the options `-mapped' and
     `-readnow' (available on the command line, and with the commands
     `file', `symbol-file', or `add-symbol-file'), for more information.

`file'
     `file' with no argument makes GDB discard any information it has
     on both executable file and the symbol table.

`exec-file [ FILENAME ]'
     Specify that the program to be run (but not the symbol table) is
     found in FILENAME.  GDB will search the environment variable `PATH'
     if necessary to locate your program.  Omitting FILENAME means to
     discard information on the executable file.

`symbol-file [ FILENAME ]'
     Read symbol table information from file FILENAME.  `PATH' is
     searched when necessary.  Use the `file' command to get both symbol
     table and program to run from the same file.

     `symbol-file' with no argument clears out GDB's information on your
     program's symbol table.

     The `symbol-file' command causes GDB to forget the contents of its
     convenience variables, the value history, and all breakpoints and
     auto-display expressions.  This is because they may contain
     pointers to the internal data recording symbols and data types,
     which are part of the old symbol table data being discarded inside
     GDB.

     `symbol-file' will not repeat if you press RET again after
     executing it once.

     When GDB is configured for a particular environment, it will
     understand debugging information in whatever format is the standard
     generated for that environment; you may use either a GNU compiler,
     or other compilers that adhere to the local conventions.  Best
     results are usually obtained from GNU compilers; for example,
     using `gcc' you can generate debugging information for optimized
     code.

     On some kinds of object files, the `symbol-file' command does not
     normally read the symbol table in full right away.  Instead, it
     scans the symbol table quickly to find which source files and
     which symbols are present.  The details are read later, one source
     file at a time, as they are needed.

     The purpose of this two-stage reading strategy is to make GDB
     start up faster.  For the most part, it is invisible except for
     occasional pauses while the symbol table details for a particular
     source file are being read.  (The `set verbose' command can turn
     these pauses into messages if desired. *Note Optional Warnings and
     Messages: Messages/Warnings.)

     When the symbol table is stored in COFF format, `symbol-file' does
     read the symbol table data in full right away.  We have not
     implemented the two-stage strategy for COFF yet.

`symbol-file FILENAME [ -readnow ] [ -mapped ]'
`file FILENAME [ -readnow ] [ -mapped ]'
     You can override the GDB two-stage strategy for reading symbol
     tables by using the `-readnow' option with any of the commands that
     load symbol table information, if you want to be sure GDB has the
     entire symbol table available.

     If memory-mapped files are available on your system through the
     `mmap' system call, you can use another option, `-mapped', to
     cause GDB to write the symbols for your program into a reusable
     file.  Future GDB debugging sessions will map in symbol information
     from this auxiliary symbol file (if the program hasn't changed),
     rather than spending time reading the symbol table from the
     executable program.  Using the `-mapped' option has the same
     effect as starting GDB with the `-mapped' command-line option.

     You can use both options together, to make sure the auxiliary
     symbol file has all the symbol information for your program.

     The `.syms' file is specific to the host machine on which GDB is
     run. It holds an exact image of GDB's internal symbol table.  It
     cannot be shared across multiple host platforms.

     The auxiliary symbol file for a program called MYPROG is called
     `MYPROG.syms'.  Once this file exists (so long as it is newer than
     the corresponding executable), GDB will always attempt to use it
     when you debug MYPROG; no special options or commands are needed.

`core-file [ FILENAME ]'
     Specify the whereabouts of a core dump file to be used as the
     "contents of memory".  Traditionally, core files contain only some
     parts of the address space of the process that generated them; GDB
     can access the executable file itself for other parts.

     `core-file' with no argument specifies that no core file is to be
     used.

     Note that the core file is ignored when your program is actually
     running under GDB.  So, if you have been running your program and
     you wish to debug a core file instead, you must kill the
     subprocess in which the program is running.  To do this, use the
     `kill' command (*note Killing the Child Process: Kill Process.).

`load FILENAME'
     Depending on what remote debugging facilities are configured into
     GDB, the `load' command may be available.  Where it exists, it is
     meant to make FILENAME (an executable) available for debugging on
     the remote system--by downloading, or dynamic linking, for example.
     `load' also records FILENAME's symbol table in GDB, like the
     `add-symbol-file' command.

     If `load' is not available on your GDB, attempting to execute it
     gets the error message "`You can't do that when your target is
     ...'"

     On VxWorks, `load' will dynamically link FILENAME on the current
     target system as well as adding its symbols in GDB.

     With the Nindy interface to an Intel 960 board, `load' will
     download FILENAME to the 960 as well as adding its symbols in GDB.

     `load' will not repeat if you press RET again after using it.

`add-symbol-file FILENAME ADDRESS'
`add-symbol-file FILENAME ADDRESS [ -readnow ] [ -mapped ]'
     The `add-symbol-file' command reads additional symbol table
     information from the file FILENAME.  You would use this command
     when FILENAME has been dynamically loaded (by some other means)
     into the program that is running.  ADDRESS should be the memory
     address at which the file has been loaded; GDB cannot figure this
     out for itself.

     The symbol table of the file FILENAME is added to the symbol table
     originally read with the `symbol-file' command.  You can use the
     `add-symbol-file' command any number of times; the new symbol data
     thus read keeps adding to the old.  To discard all old symbol data
     instead, use the `symbol-file' command.

     `add-symbol-file' will not repeat if you press RET after using it.

     You can use the `-mapped' and `-readnow' options just as with the
     `symbol-file' command, to change how GDB manages the symbol tabl
     einformation for FILENAME.

`info files'
`info target'
     `info files' and `info target' are synonymous; both print the
     current targets (*note Specifying a Debugging Target: Targets.),
     including the names of the executable and core dump files
     currently in use by GDB, and the files from which symbols were
     loaded.  The command `help targets' lists all possible targets
     rather than current ones.

   All file-specifying commands allow both absolute and relative file
names as arguments.  GDB always converts the file name to an absolute
path name and remembers it that way.

   GDB supports SunOS, SVR4, and IBM RS/6000 shared libraries. GDB
automatically loads symbol definitions from shared libraries when you
use the `run' command, or when you examine a core file. (Before you
issue the `run' command, GDB will not understand references to a
function in a shared library, however--unless you are debugging a core
file).

`info share'
`info sharedlibrary'
     Print the names of the shared libraries which are currently loaded.

`sharedlibrary REGEX'
`share REGEX'
     This is an obsolescent command; you can use it to explicitly load
     shared object library symbols for files matching a UNIX regular
     expression, but as with files loaded automatically, it will only
     load shared libraries required by your program for a core file or
     after typing `run'.  If REGEX is omitted all shared libraries
     required by your program are loaded.


File: gdb.info,  Node: Symbol Errors,  Prev: Files,  Up: GDB Files

Errors Reading Symbol Files
===========================

   While reading a symbol file, GDB will occasionally encounter
problems, such as symbol types it does not recognize, or known bugs in
compiler output.  By default, GDB does not notify you of such problems,
since they are relatively common and primarily of interest to people
debugging compilers.  If you are interested in seeing information about
ill-constructed symbol tables, you can either ask GDB to print only one
message about each such type of problem, no matter how many times the
problem occurs; or you can ask GDB to print more messages, to see how
many times the problems occur, with the `set complaints' command (*note
Optional Warnings and Messages: Messages/Warnings.).

   The messages currently printed, and their meanings, are:

`inner block not inside outer block in SYMBOL'
     The symbol information shows where symbol scopes begin and end
     (such as at the start of a function or a block of statements). 
     This error indicates that an inner scope block is not fully
     contained in its outer scope blocks.

     GDB circumvents the problem by treating the inner block as if it
     had the same scope as the outer block.  In the error message,
     SYMBOL may be shown as "`(don't know)'" if the outer block is not a
     function.

`block at ADDRESS out of order'
     The symbol information for symbol scope blocks should occur in
     order of increasing addresses.  This error indicates that it does
     not do so.

     GDB does not circumvent this problem, and will have trouble
     locating symbols in the source file whose symbols being read. 
     (You can often determine what source file is affected by
     specifying `set verbose on'.  *Note Optional Warnings and
     Messages: Messages/Warnings.)

`bad block start address patched'
     The symbol information for a symbol scope block has a start address
     smaller than the address of the preceding source line.  This is
     known to occur in the SunOS 4.1.1 (and earlier) C compiler.

     GDB circumvents the problem by treating the symbol scope block as
     starting on the previous source line.

`bad string table offset in symbol N'
     Symbol number N contains a pointer into the string table which is
     larger than the size of the string table.

     GDB circumvents the problem by considering the symbol to have the
     name `foo', which may cause other problems if many symbols end up
     with this name.

`unknown symbol type `0xNN''
     The symbol information contains new data types that GDB does not
     yet know how to read.  `0xNN' is the symbol type of the
     misunderstood information, in hexadecimal.

     GDB circumvents the error by ignoring this symbol information. 
     This will usually allow your program to be debugged, though
     certain symbols will not be accessible.  If you encounter such a
     problem and feel like debugging it, you can debug `gdb' with
     itself, breakpoint on `complain', then go up to the function
     `read_dbx_symtab' and examine `*bufp' to see the symbol.

`stub type has NULL name'
     GDB could not find the full definition for a struct or class.

`const/volatile indicator missing (ok if using g++ v1.x), got...'
     The symbol information for a C++ member function is missing some
     information that recent versions of the compiler should have output
     for it.

`info mismatch between compiler and debugger'
     GDB could not parse a type specification output by the compiler.


File: gdb.info,  Node: Targets,  Next: Controlling GDB,  Prev: GDB Files,  Up: Top

Specifying a Debugging Target
*****************************

   A "target" is the execution environment occupied by your program.
Often, GDB runs in the same host environment as your program; in that
case, the debugging target is specified as a side effect when you use
the `file' or `core' commands.  When you need more flexibility--for
example, running GDB on a physically separate host, or controlling a
standalone system over a serial port or a realtime system over a TCP/IP
connection--you can use the `target' command to specify one of the
target types configured for GDB (*note Commands for Managing Targets:
Target Commands.).

* Menu:

* Active Targets::              Active Targets
* Target Commands::             Commands for Managing Targets
* Remote::                      Remote Debugging


File: gdb.info,  Node: Active Targets,  Next: Target Commands,  Prev: Targets,  Up: Targets

Active Targets
==============

   There are three classes of targets: processes, core files, and
executable files.  GDB can work concurrently on up to three active
targets, one in each class.  This allows you to (for example) start a
process and inspect its activity without abandoning your work on a core
file.

   If, for example, you execute `gdb a.out', then the executable file
`a.out' is the only active target.  If you designate a core file as
well--presumably from a prior run that crashed and coredumped--then GDB
has two active targets and will use them in tandem, looking first in
the corefile target, then in the executable file, to satisfy requests
for memory addresses.  (Typically, these two classes of target are
complementary, since core files contain only a program's read-write
memory--variables and so on--plus machine status, while executable
files contain only the program text and initialized data.)

   When you type `run', your executable file becomes an active process
target as well.  When a process target is active, all GDB commands
requesting memory addresses refer to that target; addresses in an active
core file or executable file target are obscured while the process
target is active.

   Use the `core-file' and `exec-file' commands to select a new core
file or executable target (*note Commands to Specify Files: Files.). 
To specify as a target a process that is already running, use the
`attach' command (*note Debugging an Already-Running Process: Attach..).


File: gdb.info,  Node: Target Commands,  Next: Remote,  Prev: Active Targets,  Up: Targets

Commands for Managing Targets
=============================

`target TYPE PARAMETERS'
     Connects the GDB host environment to a target machine or process. 
     A target is typically a protocol for talking to debugging
     facilities.  You use the argument TYPE to specify the type or
     protocol of the target machine.

     Further PARAMETERS are interpreted by the target protocol, but
     typically include things like device names or host names to connect
     with, process numbers, and baud rates.

     The `target' command will not repeat if you press RET again after
     executing the command.

`help target'
     Displays the names of all targets available.  To display targets
     currently selected, use either `info target' or `info files'
     (*note Commands to Specify Files: Files.).

`help target NAME'
     Describe a particular target, including any parameters necessary to
     select it.

   Here are some common targets (available, or not, depending on the GDB
configuration):

`target exec PROG'
     An executable file.  `target exec PROG' is the same as `exec-file
     PROG'.

`target core FILENAME'
     A core dump file.  `target core FILENAME' is the same as
     `core-file FILENAME'.

`target remote DEV'
     Remote serial target in GDB-specific protocol.  The argument DEV
     specifies what serial device to use for the connection (e.g.
     `/dev/ttya'). *Note Remote Debugging: Remote.

`target amd-eb DEV SPEED PROG'
     Remote PC-resident AMD EB29K board, attached over serial lines.
     DEV is the serial device, as for `target remote'; SPEED allows you
     to specify the linespeed; and PROG is the name of the program to
     be debugged, as it appears to DOS on the PC. *Note GDB with a
     Remote EB29K: EB29K Remote.

`target nindy DEVICENAME'
     An Intel 960 board controlled by a Nindy Monitor.  DEVICENAME is
     the name of the serial device to use for the connection, e.g.
     `/dev/ttya'.  *Note GDB with a Remote i960 (Nindy): i960-Nindy
     Remote.

`target vxworks MACHINENAME'
     A VxWorks system, attached via TCP/IP.  The argument MACHINENAME
     is the target system's machine name or IP address. *Note GDB and
     VxWorks: VxWorks Remote.

   Different targets are available on different configurations of GDB;
your configuration may have more or fewer targets.


File: gdb.info,  Node: Remote,  Prev: Target Commands,  Up: Targets

Remote Debugging
================

   If you are trying to debug a program running on a machine that
cannot run GDB in the usual way, it is often useful to use remote
debugging.  For example, you might use remote debugging on an operating
system kernel, or on a small system which does not have a general
purpose operating system powerful enough to run a full-featured
debugger.

   Some configurations of GDB have special serial or TCP/IP interfaces
to make this work with particular debugging targets.  In addition, GDB
comes with a generic serial protocol (specific to GDB, but not specific
to any particular target system) which you can use if you write the
remote stubs--the code that will run on the remote system to
communicate with GDB.

   To use the GDB remote serial protocol, the program to be debugged on
the remote machine needs to contain a debugging stub which talks to GDB
over the serial line.  Several working remote stubs are distributed
with GDB; see the `README' file in the GDB distribution for more
information.

   For details of this communication protocol, see the comments in the
GDB source file `remote.c'.

   To start remote debugging, first run GDB and specify as an
executable file the program that is running in the remote machine. 
This tells GDB how to find your program's symbols and the contents of
its pure text.  Then establish communication using the `target remote'
command with a device name as an argument.  For example:

     target remote /dev/ttyb

if the serial line is connected to the device named `/dev/ttyb'.  This
will stop the remote machine if it is not already stopped.

   Now you can use all the usual commands to examine and change data
and to step and continue the remote program.

   To resume the remote program and stop debugging it, use the `detach'
command.

   If you have trouble with the serial connection, you can use the
command `set remotedebug'.  This makes GDB report on all packets sent
back and forth across the serial line to the remote machine.  The
packet-debugging information is printed on the GDB standard output
stream.  `set remotedebug off' turns it off, and `show remotedebug'
will show you its current state.

   Other remote targets may be available in your configuration of GDB;
use `help targets' to list them.

* Menu:

* i960-Nindy Remote::		GDB with a Remote i960 (Nindy)
* EB29K Remote::		GDB with a Remote EB29K
* VxWorks Remote::		GDB and VxWorks


File: gdb.info,  Node: i960-Nindy Remote,  Next: EB29K Remote,  Prev: Remote,  Up: Remote

GDB with a Remote i960 (Nindy)
------------------------------

   "Nindy" is a ROM Monitor program for Intel 960 target systems.  When
GDB is configured to control a remote Intel 960 using Nindy, you can
tell GDB how to connect to the 960 in several ways:

   * Through command line options specifying serial port, version of the
     Nindy protocol, and communications speed;

   * By responding to a prompt on startup;

   * By using the `target' command at any point during your GDB
     session.  *Note Commands for Managing Targets: Target Commands.

* Menu:

* Nindy Startup::               Startup with Nindy
* Nindy Options::               Options for Nindy
* Nindy reset::                 Nindy Reset Command


File: gdb.info,  Node: Nindy Startup,  Next: Nindy Options,  Prev: i960-Nindy Remote,  Up: i960-Nindy Remote

Startup with Nindy
..................

   If you simply start `gdb' without using any command-line options,
you are prompted for what serial port to use, *before* you reach the
ordinary GDB prompt:

     Attach /dev/ttyNN -- specify NN, or "quit" to quit:

Respond to the prompt with whatever suffix (after `/dev/tty')
identifies the serial port you want to use.  You can, if you choose,
simply start up with no Nindy connection by responding to the prompt
with an empty line.  If you do this, and later wish to attach to Nindy,
use `target' (*note Commands for Managing Targets: Target Commands.).


File: gdb.info,  Node: Nindy Options,  Next: Nindy reset,  Prev: Nindy Startup,  Up: i960-Nindy Remote

Options for Nindy
.................

   These are the startup options for beginning your GDB session with a
Nindy-960 board attached:

`-r PORT'
     Specify the serial port name of a serial interface to be used to
     connect to the target system.  This option is only available when
     GDB is configured for the Intel 960 target architecture.  You may
     specify PORT as any of: a full pathname (e.g. `-r /dev/ttya'), a
     device name in `/dev' (e.g. `-r ttya'), or simply the unique
     suffix for a specific `tty' (e.g. `-r a').

`-O'
     (An uppercase letter "O", not a zero.)  Specify that GDB should use
     the "old" Nindy monitor protocol to connect to the target system.
     This option is only available when GDB is configured for the Intel
     960 target architecture.

          *Warning:* if you specify `-O', but are actually trying to
          connect to a target system that expects the newer protocol,
          the connection will fail, appearing to be a speed mismatch. 
          GDB will repeatedly attempt to reconnect at several different
          line speeds.  You can abort this process with an interrupt.

`-brk'
     Specify that GDB should first send a `BREAK' signal to the target
     system, in an attempt to reset it, before connecting to a Nindy
     target.

          *Warning:* Many target systems do not have the hardware that
          this requires; it only works with a few boards.

   The standard `-b' option controls the line speed used on the serial
port.


File: gdb.info,  Node: Nindy reset,  Prev: Nindy Options,  Up: i960-Nindy Remote

Nindy Reset Command
...................

`reset'
     For a Nindy target, this command sends a "break" to the remote
     target system; this is only useful if the target has been equipped
     with a circuit to perform a hard reset (or some other interesting
     action) when a break is detected.


File: gdb.info,  Node: EB29K Remote,  Next: VxWorks Remote,  Prev: i960-Nindy Remote,  Up: Remote

GDB with a Remote EB29K
-----------------------

   To use GDB from a Unix system to run programs on AMD's EB29K board
in a PC, you must first connect a serial cable between the PC and a
serial port on the Unix system.  In the following, we assume you've
hooked the cable between the PC's `COM1' port and `/dev/ttya' on the
Unix system.

* Menu:

* Comms (EB29K)::               Communications Setup
* gdb-EB29K::                   EB29K cross-debugging
* Remote Log::                  Remote Log


File: gdb.info,  Node: Comms (EB29K),  Next: gdb-EB29K,  Prev: EB29K Remote,  Up: EB29K Remote

Communications Setup
....................

   The next step is to set up the PC's port, by doing something like the
following in DOS on the PC:

     C:\> MODE com1:9600,n,8,1,none

This example--run on an MS DOS 4.0 system--sets the PC port to 9600
bps, no parity, eight data bits, one stop bit, and no "retry" action;
you must match the communications parameters when establishing the Unix
end of the connection as well.

   To give control of the PC to the Unix side of the serial line, type
the following at the DOS console:

     C:\> CTTY com1

(Later, if you wish to return control to the DOS console, you can use
the command `CTTY con'--but you must send it over the device that had
control, in our example over the `COM1' serial line).

   From the Unix host, use a communications program such as `tip' or
`cu' to communicate with the PC; for example,

     cu -s 9600 -l /dev/ttya

The `cu' options shown specify, respectively, the linespeed and the
serial port to use.  If you use `tip' instead, your command line may
look something like the following:

     tip -9600 /dev/ttya

Your system may define a different name where our example uses
`/dev/ttya' as the argument to `tip'.  The communications parameters,
including which port to use, are associated with the `tip' argument in
the "remote" descriptions file--normally the system table `/etc/remote'.

   Using the `tip' or `cu' connection, change the DOS working directory
to the directory containing a copy of your 29K program, then start the
PC program `EBMON' (an EB29K control program supplied with your board
by AMD).  You should see an initial display from `EBMON' similar to the
one that follows, ending with the `EBMON' prompt `#'--

     C:\> G:
     
     G:\> CD \usr\joe\work29k
     
     G:\USR\JOE\WORK29K> EBMON
     Am29000 PC Coprocessor Board Monitor, version 3.0-18
     Copyright 1990 Advanced Micro Devices, Inc.
     Written by Gibbons and Associates, Inc.
     
     Enter '?' or 'H' for help
     
     PC Coprocessor Type   = EB29K
     I/O Base              = 0x208
     Memory Base           = 0xd0000
     
     Data Memory Size      = 2048KB
     Available I-RAM Range = 0x8000 to 0x1fffff
     Available D-RAM Range = 0x80002000 to 0x801fffff
     
     PageSize              = 0x400
     Register Stack Size   = 0x800
     Memory Stack Size     = 0x1800
     
     CPU PRL               = 0x3
     Am29027 Available     = No
     Byte Write Available  = Yes
     
     # ~.

   Then exit the `cu' or `tip' program (done in the example by typing
`~.' at the `EBMON' prompt).  `EBMON' will keep running, ready for GDB
to take over.

   For this example, we've assumed what is probably the most convenient
way to make sure the same 29K program is on both the PC and the Unix
system: a PC/NFS connection that establishes "drive `G:'" on the PC as
a file system on the Unix host.  If you do not have PC/NFS or something
similar connecting the two systems, you must arrange some other
way--perhaps floppy-disk transfer--of getting the 29K program from the
Unix system to the PC; GDB will *not* download it over the serial line.


File: gdb.info,  Node: gdb-EB29K,  Next: Remote Log,  Prev: Comms (EB29K),  Up: EB29K Remote

EB29K cross-debugging
.....................

   Finally, `cd' to the directory containing an image of your 29K
program on the Unix system, and start GDB--specifying as argument the
name of your 29K program:

     cd /usr/joe/work29k
     gdb myfoo

   Now you can use the `target' command:

     target amd-eb /dev/ttya 9600 MYFOO

In this example, we've assumed your program is in a file called
`myfoo'.  Note that the filename given as the last argument to `target
amd-eb' should be the name of the program as it appears to DOS. In our
example this is simply `MYFOO', but in general it can include a DOS
path, and depending on your transfer mechanism may not resemble the
name on the Unix side.

   At this point, you can set any breakpoints you wish; when you are
ready to see your program run on the 29K board, use the GDB command
`run'.

   To stop debugging the remote program, use the GDB `detach' command.

   To return control of the PC to its console, use `tip' or `cu' once
again, after your GDB session has concluded, to attach to `EBMON'.  You
can then type the command `q' to shut down `EBMON', returning control
to the DOS command-line interpreter. Type `CTTY con' to return command
input to the main DOS console, and type `~.' to leave `tip' or `cu'.


File: gdb.info,  Node: Remote Log,  Prev: gdb-EB29K,  Up: EB29K Remote

Remote Log
..........

   The `target amd-eb' command creates a file `eb.log' in the current
working directory, to help debug problems with the connection. `eb.log'
records all the output from `EBMON', including echoes of the commands
sent to it.  Running `tail -f' on this file in another window often
helps to understand trouble with `EBMON', or unexpected events on the
PC side of the connection.


File: gdb.info,  Node: VxWorks Remote,  Prev: EB29K Remote,  Up: Remote

GDB and VxWorks
---------------

   GDB enables developers to spawn and debug tasks running on networked
VxWorks targets from a Unix host.  Already-running tasks spawned from
the VxWorks shell can also be debugged.  GDB uses code that runs on
both the UNIX host and on the VxWorks target.  The program `gdb' is
installed and executed on the UNIX host.

   The following information on connecting to VxWorks was current when
this manual was produced; newer releases of VxWorks may use revised
procedures.

   The remote debugging interface (RDB) routines are installed and
executed on the VxWorks target.  These routines are included in the
VxWorks library `rdb.a' and are incorporated into the system image when
source-level debugging is enabled in the VxWorks configuration.

   If you wish, you can define `INCLUDE_RDB' in the VxWorks
configuration file `configAll.h' to include the RDB interface routines
and spawn the source debugging task `tRdbTask' when VxWorks is booted. 
For more information on configuring and remaking VxWorks, see the
manufacturer's manual.

   Once you have included the RDB interface in your VxWorks system image
and set your Unix execution search path to find GDB, you are ready to
run GDB.  From your UNIX host, type:

     % gdb

   GDB will come up showing the prompt:

     (gdb)

* Menu:

* VxWorks connection::          Connecting to VxWorks
* VxWorks download::            VxWorks Download
* VxWorks attach::              Running Tasks


File: gdb.info,  Node: VxWorks connection,  Next: VxWorks download,  Prev: VxWorks Remote,  Up: VxWorks Remote

Connecting to VxWorks
.....................

   The GDB command `target' lets you connect to a VxWorks target on the
network.  To connect to a target whose host name is "`tt'", type:

     (gdb) target vxworks tt

   GDB will display a message similar to the following:

     Attaching remote machine across net... Success!

   GDB will then attempt to read the symbol tables of any object modules
loaded into the VxWorks target since it was last booted.  GDB locates
these files by searching the directories listed in the command search
path (*note Your Program's Environment: Environment.); if it fails to
find an object file, it will display a message such as:

     prog.o: No such file or directory.

   This will cause the `target' command to abort.  When this happens,
you should add the appropriate directory to the search path, with the
GDB command `path', and execute the `target' command again.


File: gdb.info,  Node: VxWorks download,  Next: VxWorks attach,  Prev: VxWorks connection,  Up: VxWorks Remote

VxWorks Download
................

   If you have connected to the VxWorks target and you want to debug an
object that has not yet been loaded, you can use the GDB `load' command
to download a file from UNIX to VxWorks incrementally.  The object file
given as an argument to the `load' command is actually opened twice:
first by the VxWorks target in order to download the code, then by GDB
in order to read the symbol table.  This can lead to problems if the
current working directories on the two systems differ. It is simplest
to set the working directory on both systems to the directory in which
the object file resides, and then to reference the file by its name,
without any path.  Thus, to load a program `prog.o', residing in
`wherever/vw/demo/rdb', on VxWorks type:

     -> cd "wherever/vw/demo/rdb"

   On GDB type:

     (gdb) cd wherever/vw/demo/rdb
     (gdb) load prog.o

   GDB will display a response similar to the following:

     Reading symbol data from wherever/vw/demo/rdb/prog.o... done.

   You can also use the `load' command to reload an object module after
editing and recompiling the corresponding source file.  Note that this
will cause GDB to delete all currently-defined breakpoints,
auto-displays, and convenience variables, and to clear the value
history.  (This is necessary in order to preserve the integrity of
debugger data structures that reference the target system's symbol
table.)


File: gdb.info,  Node: VxWorks attach,  Prev: VxWorks download,  Up: VxWorks Remote

Running Tasks
.............

   You can also attach to an existing task using the `attach' command as
follows:

     (gdb) attach TASK

where TASK is the VxWorks hexadecimal task ID.  The task can be running
or suspended when you attach to it.  If running, it will be suspended at
the time of attachment.


File: gdb.info,  Node: Controlling GDB,  Next: Sequences,  Prev: Targets,  Up: Top

Controlling GDB
***************

   You can alter many aspects of GDB's interaction with you by using
the `set' command.  For commands controlling how GDB displays data,
*note Print Settings: Print Settings.; other settings are described
here.

* Menu:

* Prompt::                      Prompt
* Editing::                     Command Editing
* History::                     Command History
* Screen Size::                 Screen Size
* Numbers::                     Numbers
* Messages/Warnings::           Optional Warnings and Messages


File: gdb.info,  Node: Prompt,  Next: Editing,  Prev: Controlling GDB,  Up: Controlling GDB

Prompt
======

   GDB indicates its readiness to read a command by printing a string
called the "prompt".  This string is normally `(gdb)'.  You can change
the prompt string with the `set prompt' command.  For instance, when
debugging GDB with GDB, it is useful to change the prompt in one of the
GDBs so that you can always tell which one you are talking to.

`set prompt NEWPROMPT'
     Directs GDB to use NEWPROMPT as its prompt string henceforth.

`show prompt'
     Prints a line of the form: `Gdb's prompt is: YOUR-PROMPT'


File: gdb.info,  Node: Editing,  Next: History,  Prev: Prompt,  Up: Controlling GDB

Command Editing
===============

   GDB reads its input commands via the "readline" interface.  This GNU
library provides consistent behavior for programs which provide a
command line interface to the user.  Advantages are `emacs'-style or
`vi'-style inline editing of commands, `csh'-like history substitution,
and a storage and recall of command history across debugging sessions.

   You may control the behavior of command line editing in GDB with the
command `set'.

`set editing'
`set editing on'
     Enable command line editing (enabled by default).

`set editing off'
     Disable command line editing.

`show editing'
     Show whether command line editing is enabled.


File: gdb.info,  Node: History,  Next: Screen Size,  Prev: Editing,  Up: Controlling GDB

Command History
===============

`set history filename FNAME'
     Set the name of the GDB command history file to FNAME.  This is
     the file from which GDB will read an initial command history list
     or to which it will write this list when it exits.  This list is
     accessed through history expansion or through the history command
     editing characters listed below.  This file defaults to the value
     of the environment variable `GDBHISTFILE', or to `./.gdb_history'
     if this variable is not set.

`set history save'
`set history save on'
     Record command history in a file, whose name may be specified with
     the `set history filename' command.  By default, this option is
     disabled.

`set history save off'
     Stop recording command history in a file.

`set history size SIZE'
     Set the number of commands which GDB will keep in its history list.
     This defaults to the value of the environment variable `HISTSIZE',
     or to 256 if this variable is not set.

   History expansion assigns special meaning to the character `!'.
Since `!' is also the logical not operator in C, history expansion is
off by default. If you decide to enable history expansion with the `set
history expansion on' command, you may sometimes need to follow `!'
(when it is used as logical not, in an expression) with a space or a
tab to prevent it from being expanded.  The readline history facilities
will not attempt substitution on the strings `!=' and `!(', even when
history expansion is enabled.

   The commands to control history expansion are:

`set history expansion on'
`set history expansion'
     Enable history expansion.  History expansion is off by default.

`set history expansion off'
     Disable history expansion.

     The readline code comes with more complete documentation of
     editing and history expansion features.  Users unfamiliar with
     `emacs' or `vi' may wish to read it.

`show history'
`show history filename'
`show history save'
`show history size'
`show history expansion'
     These commands display the state of the GDB history parameters.
     `show history' by itself displays all four states.

`show commands'
     Display the last ten commands in the command history.

`show commands N'
     Print ten commands centered on command number N.

`show commands +'
     Print ten commands just after the commands last printed.


File: gdb.info,  Node: Screen Size,  Next: Numbers,  Prev: History,  Up: Controlling GDB

Screen Size
===========

   Certain commands to GDB may produce large amounts of information
output to the screen.  To help you read all of it, GDB pauses and asks
you for input at the end of each page of output.  Type RET when you
want to continue the output.  GDB also uses the screen width setting to
determine when to wrap lines of output.  Depending on what is being
printed, it tries to break the line at a readable place, rather than
simply letting it overflow onto the following line.

   Normally GDB knows the size of the screen from the termcap data base
together with the value of the `TERM' environment variable and the
`stty rows' and `stty cols' settings. If this is not correct, you can
override it with the `set height' and `set width' commands:

`set height LPP'
`show height'
`set width CPL'
`show width'
     These `set' commands specify a screen height of LPP lines and a
     screen width of CPL characters.  The associated `show' commands
     display the current settings.

     If you specify a height of zero lines, GDB will not pause during
     output no matter how long the output is.  This is useful if output
     is to a file or to an editor buffer.


File: gdb.info,  Node: Numbers,  Next: Messages/Warnings,  Prev: Screen Size,  Up: Controlling GDB

Numbers
=======

   You can always enter numbers in octal, decimal, or hexadecimal in
GDB by the usual conventions: octal numbers begin with `0', decimal
numbers end with `.', and hexadecimal numbers begin with `0x'. Numbers
that begin with none of these are, by default, entered in base 10;
likewise, the default display for numbers--when no particular format is
specified--is base 10.  You can change the default base for both input
and output with the `set radix' command.

`set radix BASE'
     Set the default base for numeric input and display.  Supported
     choices for BASE are decimal 2, 8, 10, 16.  BASE must itself be
     specified either unambiguously or using the current default radix;
     for example, any of

          set radix 1010
          set radix 012
          set radix 10.
          set radix 0xa

     will set the base to decimal.  On the other hand, `set radix 10'
     will leave the radix unchanged no matter what it was.

`show radix'
     Display the current default base for numeric input and display.

