		      Release 5 Public Patch #9
			   MIT X Consortium

To apply this patch:

cd to the top of the source tree (to the directory containing the "mit"
and "contrib" subdirectories) and do:
	patch -p -s < ThisFile
Patch will work silently unless an error occurs.
If you want to watch patch do its thing, leave out the "-s" argument to patch.

If you are running SunOS 4.1.1 and you apply Sun's ld patch 100170-6,
then you will need to edit your site.def and add this line to the
AfterVendorCF section:

#define SunPost411FCSLd	  YES


Finally, to rebuild after applying this patch, cd to the "mit" subdirectory
and do (if you are on an HP system):
	make World >& world.log
or do (if you have set SunPost411FCSLd YES):
	make Everything >& every.log
otherwise do:
	make -k >& make.log
(Note: the "make World" on the HP system will "clean" your build tree and
regenerate it.  If you want something quicker you can try regenerating
Makefiles and forcing rebuilds of all libraries that depend on
Malloc0ReturnsNull, and then do a normal make.)

Brief notes on what this patch fixes:

config: HP-UX needs Malloc0ReturnsNull
config: handle problems introduced by SunOS ld patch 100170-06
Xlib: (Xsi) resource values fail with stateful encoding
Xlib: (Xsi) local IM can fail to move to convert off state
Xt: ANSI C prototypes needed when compiling shared library
Xt: undefined __XtInherit introduced by SunOS ld patch 100170-06
Xt: bombs destroying when parent is not a widget
fontlib: server can crash if it fails to read fonts.dir correctly
fontlib: font code leaks memory at every server reset
xdm: segmentation fault in getEnv
xauth: merge command deletes entries it should leave alone
xauth: should always keep MIT-MAGIC-COOKIE-1 first for R4 compatibility
xauth: intermittently fails due to locking bugs
xterm: orphaned shells on AIX if connection is lost
xterm: support SGI ptys
xinit: A/UX loses controlling terminal, breaks xterm
server: width-zero dashed lines drawn wrong

Prereq: public-patch-8

*** /tmp/,RCSt1003389	Thu Jan 23 17:19:21 1992
--- mit/bug-report	Thu Jan 23 17:19:33 1992
***************
*** 2,8 ****
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-8
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:
--- 2,8 ----
  Subject: [area]: [synopsis]   [replace with actual area and short description]
  
  VERSION:
!     R5, public-patch-9
      [MIT public patches will edit this line to indicate the patch level]
  
  CLIENT MACHINE and OPERATING SYSTEM:

*** /tmp/,RCSt1005235	Wed Dec 18 15:21:32 1991
--- mit/config/hp.cf	Wed Dec 18 09:44:48 1991
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: hp.cf,v 1.47 91/07/28 22:39:35 rws Exp $
  
  #define OSName                 HP-UX 7.0
  XCOMM operating system:  OSName
--- 1,4 ----
! XCOMM platform:  $XConsortium: hp.cf,v 1.48 91/12/18 09:43:08 rws Exp $
  
  #define OSName                 HP-UX 7.0
  XCOMM operating system:  OSName
***************
*** 6,11 ****
--- 6,12 ----
  #define OSMinorVersion         0
  
  #define SystemV                YES
+ #define Malloc0ReturnsNull     YES
  #ifdef hp9000s800
  #define OptimizedCDebugFlags   +O1
  #else

*** /tmp/,RCSt1024429	Mon Dec 23 13:20:39 1991
--- mit/config/sun.cf	Fri Dec 20 11:19:51 1991
***************
*** 1,4 ****
! XCOMM platform:  $XConsortium: sun.cf,v 1.69 91/09/09 18:23:59 rws Exp $
  
  #define OSName            SunOS 4.1.1
  XCOMM operating system:  OSName
--- 1,4 ----
! XCOMM platform:  $XConsortium: sun.cf,v 1.71 91/12/20 11:18:34 rws Exp $
  
  #define OSName            SunOS 4.1.1
  XCOMM operating system:  OSName
***************
*** 11,16 ****
--- 11,21 ----
  #define StandardDefines   -DNOSTDHDRS
  #endif
  
+ /* You ALSO need this if you have Sun ld patch 100170-06 to 4.1.1 */
+ #if OSMajorVersion == 4 && OSMinorVersion > 1
+ #define SunPost411FCSLd	  YES
+ #endif
+ 
  #define HasSaberC	  YES
  #define HasNdbm		  YES
  #define HasShm		  YES
***************
*** 20,25 ****
--- 25,31 ----
  #define XsunServer	  YES		/* has color and mono support */
  #define XsunMonoServer	  YES		/* monochrome only */
  #define BuildPexExt	  XsunServer
+ #define InstKmemFlags	  -g kmem -m 2755
  
  #ifdef sparc
  #undef sparc

*** /tmp/,RCSt1024429	Mon Dec 23 13:20:42 1991
--- mit/config/sunLib.tmpl	Fri Dec 20 11:20:38 1991
***************
*** 1,4 ****
! XCOMM $XConsortium: sunLib.tmpl,v 1.11 91/07/31 11:32:08 rws Exp $
  
  /*
   * SunOS shared library template
--- 1,4 ----
! XCOMM $XConsortium: sunLib.tmpl,v 1.14 91/12/20 11:19:05 rws Exp $
  
  /*
   * SunOS shared library template
***************
*** 25,30 ****
--- 25,33 ----
  #ifndef SharedXinputRev
  #define SharedXinputRev 4.10
  #endif
+ #ifndef SharedXTrapRev
+ #define SharedXTrapRev 1.0
+ #endif
  
  SHLIBLDFLAGS = SharedLibraryLoadFlags
  PICFLAGS = PositionIndependentCFlags
***************
*** 42,49 ****
               XLIB = $(EXTENSIONLIB) _Use(-lX11,-L$(XLIBSRC) -lX11)
  #endif
  #if SharedLibXmu
          DEPXMULIB = _UseCat($(USRLIBDIR),$(XMUSRC),/libXmu.sa.$(SOXMUREV))
!            XMULIB = _Use(-lXmu,-L$(XMUSRC) -lXmu)
  #endif
  #if SharedOldLibX
         DEPOLDXLIB = /* _UseCat($(USRLIBDIR),$(OLDXLIBSRC),/liboldX.sa.$(SOOLDXREV)) */
--- 45,57 ----
               XLIB = $(EXTENSIONLIB) _Use(-lX11,-L$(XLIBSRC) -lX11)
  #endif
  #if SharedLibXmu
+ /* Sun shared libraries are deficient in link semantics */
          DEPXMULIB = _UseCat($(USRLIBDIR),$(XMUSRC),/libXmu.sa.$(SOXMUREV))
!        XMULIBONLY = _Use(-lXmu,-L$(XMUSRC) -lXmu)
!            XMULIB = _Use(-lXmu,-L$(XMUSRC) -lXmu -L$(TOOLKITSRC))
! #if !defined(UseInstalled) && !defined(XawClientLibs)
! #define XawClientLibs $(XAWLIB) $(XMULIBONLY) $(XTOOLLIB) $(XLIB)
! #endif
  #endif
  #if SharedOldLibX
         DEPOLDXLIB = /* _UseCat($(USRLIBDIR),$(OLDXLIBSRC),/liboldX.sa.$(SOOLDXREV)) */

*** /tmp/,RCSt1024438	Mon Dec 23 13:20:55 1991
--- mit/config/sunLib.rules	Fri Dec 20 11:21:02 1991
***************
*** 1,4 ****
! XCOMM $XConsortium: sunLib.rules,v 1.6 91/03/24 17:55:58 rws Exp $
  
  /*
   * SunOS shared library rules
--- 1,4 ----
! XCOMM $XConsortium: sunLib.rules,v 1.7 91/12/20 11:19:47 rws Exp $
  
  /*
   * SunOS shared library rules
***************
*** 60,66 ****
  									@@\
  Concat(lib,libname.so.rev):  solist					@@\
  	$(RM) $@~							@@\
! 	(cd down; $(LD) -o up/$@~ $(SHLIBLDFLAGS) solist)		@@\
  	$(RM) $@ 							@@\
  	$(MV) $@~ $@							@@\
  									@@\
--- 60,66 ----
  									@@\
  Concat(lib,libname.so.rev):  solist					@@\
  	$(RM) $@~							@@\
! 	(cd down; $(LD) -o up/$@~ $(SHLIBLDFLAGS) solist $(REQUIREDLIBS)) @@\
  	$(RM) $@ 							@@\
  	$(MV) $@~ $@							@@\
  									@@\

*** /tmp/,RCSt1a03092	Mon Dec 16 19:59:19 1991
--- mit/lib/Xau/AuLock.c	Mon Dec 16 19:57:44 1991
***************
*** 1,7 ****
  /*
   * Xau - X Authorization Database Library
   *
!  * $XConsortium: AuLock.c,v 1.7 91/04/17 10:59:27 rws Exp $
   *
   * Copyright 1988 Massachusetts Institute of Technology
   *
--- 1,7 ----
  /*
   * Xau - X Authorization Database Library
   *
!  * $XConsortium: AuLock.c,v 1.8 91/12/16 19:56:07 gildea Exp $
   *
   * Copyright 1988 Massachusetts Institute of Technology
   *
***************
*** 21,32 ****
  #include <X11/Xauth.h>
  #include <sys/types.h>
  #include <sys/stat.h>
- #ifndef X_NOT_POSIX
  #include <errno.h>
- #else
- #include <sys/errno.h>
- #endif
  
  #if NeedFunctionPrototypes
  int
  XauLockAuth (
--- 21,30 ----
  #include <X11/Xauth.h>
  #include <sys/types.h>
  #include <sys/stat.h>
  #include <errno.h>
  
+ extern int errno;
+ 
  #if NeedFunctionPrototypes
  int
  XauLockAuth (
***************
*** 50,56 ****
      struct stat	statb;
      long	now;
      int		creat_fd = -1;
-     extern int	errno;
  
      if (strlen (file_name) > 1022)
  	return LOCK_ERROR;
--- 48,53 ----
***************
*** 82,87 ****
--- 79,88 ----
  	if (creat_fd != -1) {
  	    if (link (creat_name, link_name) != -1)
  		return LOCK_SUCCESS;
+ 	    if (errno == ENOENT) {
+ 		creat_fd = -1;	/* force re-creat next time around */
+ 		continue;
+ 	    }
  	    if (errno != EEXIST)
  		return LOCK_ERROR;
  	}

*** /tmp/,RCSt1003431	Thu Jan 23 17:34:36 1992
--- mit/lib/X/Xsi/XlcLoad.c	Mon Dec 23 11:39:04 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XlcLoad.c,v 1.38 91/11/17 16:12:06 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XlcLoad.c,v 1.40 91/12/23 11:37:03 rws Exp $
   */
  
  /*
***************
*** 59,64 ****
--- 59,65 ----
  #endif
  #ifndef PATH_MAX
  #include <sys/param.h>
+ #ifndef PATH_MAX
  #ifdef MAXPATHLEN
  #define PATH_MAX MAXPATHLEN
  #else
***************
*** 65,70 ****
--- 66,72 ----
  #define PATH_MAX 1024
  #endif
  #endif
+ #endif
  
  #ifndef XNLSPATHDEFAULT
  #define XNLSPATHDEFAULT "/usr/lib/X11/nls"
***************
*** 1030,1035 ****
--- 1032,1038 ----
      int cscode;
      int dlen;
  
+     csid = _Xmbcsid((XLocale)state, str);
      dlen = _Xmbdlen((XLocale)state, str);
      if (dlen > 0) {
  	for (*lenp = 0; ; ) {

*** /tmp/,RCSt1003436	Thu Jan 23 17:35:35 1992
--- mit/lib/X/Xsi/XLocalIM.c	Fri Dec 27 15:14:14 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: XLocalIM.c,v 1.6 91/11/17 15:59:05 rws Exp $
   */
  
  /*
--- 1,5 ----
  /*
!  * $XConsortium: XLocalIM.c,v 1.8 91/12/27 15:12:20 rws Exp $
   */
  
  /*
***************
*** 55,60 ****
--- 55,61 ----
  #endif
  #ifndef PATH_MAX
  #include <sys/param.h>
+ #ifndef PATH_MAX
  #ifdef MAXPATHLEN
  #define PATH_MAX MAXPATHLEN
  #else
***************
*** 61,66 ****
--- 62,68 ----
  #define PATH_MAX 1024
  #endif
  #endif
+ #endif
  
  #ifdef X_NOT_STDC_ENV
  extern char *getenv();
***************
*** 199,205 ****
  typedef struct {
      char *name;
      Bool (*func)();
!     Bool (*init_func)();
  } FuncTbl;
  
  static int convert_on();
--- 201,207 ----
  typedef struct {
      char *name;
      Bool (*func)();
!     int (*init_func)();
  } FuncTbl;
  
  static int convert_on();
***************
*** 414,419 ****
--- 416,436 ----
      return (0);
  }
  
+ static int
+ is_state_command(xcvt, f, t)
+ XipLocalCvt *xcvt;
+ char *f, *t;
+ {
+     if (!*f || !*t) return(0);
+     if (!strcmp(f, "InitialState"))
+ 	if (!strcmp(t, "OnState"))
+ 	    xcvt->off = False;
+ 	else if (!strcmp(t, "OffState"))
+ 	    xcvt->off = True;
+ 	else return(0);
+     return(1);
+ }
+ 
  static FuncTbl *
  get_command(name)
  char *name;
***************
*** 449,455 ****
      return(True);
  }
  
! static Bool
  convert_on_init(xcvt, tbl, len)
  XipLocalCvt *xcvt;
  XipLocalCvtTbl *tbl;
--- 466,472 ----
      return(True);
  }
  
! static int
  convert_on_init(xcvt, tbl, len)
  XipLocalCvt *xcvt;
  XipLocalCvtTbl *tbl;
***************
*** 458,464 ****
      register XipLocalKeySymTbl *to, *from, *p;
  
      p = (XipLocalKeySymTbl *) Xmalloc(sizeof(XipLocalKeySymTbl) * (len + 1));
!     if (!to) return(False);
      for (to = p, from = tbl->fromkey; len > 0; to++, from++, len--) {
  	to->keysym = from->keysym;
  	to->state = from->state;
--- 475,481 ----
      register XipLocalKeySymTbl *to, *from, *p;
  
      p = (XipLocalKeySymTbl *) Xmalloc(sizeof(XipLocalKeySymTbl) * (len + 1));
!     if (!p) return(-1);
      for (to = p, from = tbl->fromkey; len > 0; to++, from++, len--) {
  	to->keysym = from->keysym;
  	to->state = from->state;
***************
*** 468,477 ****
      xcvt->off_tbl.to.func = tbl->to.func;
      xcvt->off_tbl.com = True;
      xcvt->off_tbl.fromkey = p;
!     return(True);
  }
  
! static Bool
  no_filter(xcvt, tbl, len)
  XipLocalCvt *xcvt;
  XipLocalCvtTbl *tbl;
--- 485,494 ----
      xcvt->off_tbl.to.func = tbl->to.func;
      xcvt->off_tbl.com = True;
      xcvt->off_tbl.fromkey = p;
!     return(0);
  }
  
! static int
  no_filter(xcvt, tbl, len)
  XipLocalCvt *xcvt;
  XipLocalCvtTbl *tbl;
***************
*** 481,490 ****
  
      nested_keysym = (XipLocalNestedKeySym *)
        Xmalloc(sizeof(XipLocalNestedKeySym));
      nested_keysym->keysym = tbl->fromkey->keysym;
      nested_keysym->next = xcvt->no_filter;
      xcvt->no_filter = nested_keysym;
!     return(True);
  }
  
  static Bool
--- 498,508 ----
  
      nested_keysym = (XipLocalNestedKeySym *)
        Xmalloc(sizeof(XipLocalNestedKeySym));
+     if (!nested_keysym) return(-1);
      nested_keysym->keysym = tbl->fromkey->keysym;
      nested_keysym->next = xcvt->no_filter;
      xcvt->no_filter = nested_keysym;
!     return(1);
  }
  
  static Bool
***************
*** 552,557 ****
--- 570,576 ----
      KeySym bs;
      FuncTbl *func_tbl;
      int line = 0;
+     int ret;
  
      strcpy(tmp_buf, xlc->xlc_db->lc_name);
      for (p = tmp_buf; *p && *p != '@'; p++);
***************
*** 580,585 ****
--- 599,605 ----
      cnt = 0;
      cvt->nmax = 0;
      cvt->no_filter = NULL;
+     cvt->off = False;
      while(fgets(buf, BUFSIZ, fp)) {
  	line++;
  	if(is_comment(*buf) || 
***************
*** 589,595 ****
  	    goto _err_ret;
  	}
  	if(!(cvt->tbl[cnt].fromkey = get_keysym(frombuf, &len))){
! 	    goto _err_ret;
  	}
  	if (len > cvt->nmax) cvt->nmax = len;
  	if (is_command(*tobuf)) {
--- 609,617 ----
  	    goto _err_ret;
  	}
  	if(!(cvt->tbl[cnt].fromkey = get_keysym(frombuf, &len))){
! 	    if (!is_state_command(cvt, frombuf, tobuf))
! 		goto _err_ret;
! 	    continue;
  	}
  	if (len > cvt->nmax) cvt->nmax = len;
  	if (is_command(*tobuf)) {
***************
*** 599,606 ****
  	    cvt->tbl[cnt].to.func = func_tbl->func;
  	    cvt->tbl[cnt].com = True;
  	    if (func_tbl->init_func) {
! 		if ((*func_tbl->init_func)(cvt, &cvt->tbl[cnt], len) == False)
  		    goto _err_ret;
  	    }
  	} else {
  	    if (is_keysym(*tobuf)) {
--- 621,631 ----
  	    cvt->tbl[cnt].to.func = func_tbl->func;
  	    cvt->tbl[cnt].com = True;
  	    if (func_tbl->init_func) {
! 		if ((ret = (*func_tbl->init_func)(cvt, &cvt->tbl[cnt], len))
! 		     == -1)
  		    goto _err_ret;
+ 		else if (ret == 0)
+ 		    continue;
  	    }
  	} else {
  	    if (is_keysym(*tobuf)) {
***************
*** 627,633 ****
  					     * (cvt->nmax + 1));
      cvt->buf_cnt = 0;
      cvt->bs = ((bs = XStringToKeysym("BackSpace"))? bs: 0x8);
-     cvt->off = True;
      fclose(fp);
      return(cvt);
  _err_ret:
--- 652,657 ----
***************
*** 659,665 ****
      new->buf = (XipLocalKeySymTbl *) Xmalloc(sizeof(XipLocalKeySymTbl)
  					     * (new->nmax + 1));
      new->buf_cnt = 0;
!     new->off = True;
      return(new);
  }
  
--- 683,689 ----
      new->buf = (XipLocalKeySymTbl *) Xmalloc(sizeof(XipLocalKeySymTbl)
  					     * (new->nmax + 1));
      new->buf_cnt = 0;
!     new->off = cvt->off;
      return(new);
  }
  
*** /tmp/,RCSt1003247	Thu Jan 23 16:14:53 1992
--- mit/lib/Xt/sharedlib.c	Mon Jan  6 17:02:29 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: sharedlib.c,v 1.12 91/07/23 12:22:07 rws Exp $
   * 
   * Copyright 1989 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: sharedlib.c,v 1.14 92/01/06 17:01:45 gildea Exp $
   * 
   * Copyright 1989 Massachusetts Institute of Technology
   *
***************
*** 60,66 ****
--- 60,77 ----
      _XtToolkitInitialize();
  }
  
+ #if NeedFunctionPrototypes
  Widget 
+ XtInitialize(
+ _Xconst char* name,
+ _Xconst char* classname,
+ XrmOptionDescRec *options,
+ Cardinal num_options,
+ int *argc,
+ String *argv
+ )
+ #else
+ Widget 
  XtInitialize(name, classname, options, num_options, argc, argv)
  String name, classname;
  XrmOptionDescRec *options;
***************
*** 67,72 ****
--- 78,84 ----
  Cardinal num_options;
  String *argv;
  int *argc;
+ #endif
  {
      extern Widget _XtInitialize();
      VENDORINIT
***************
*** 73,79 ****
--- 85,105 ----
      return _XtInitialize (name, classname, options, num_options, argc, argv);
  }
  
+ #if NeedFunctionPrototypes
  Widget
+ XtAppInitialize(
+ XtAppContext * app_context_return,
+ _Xconst char* application_class,
+ XrmOptionDescRec *options,
+ Cardinal num_options,
+ int *argc_in_out,
+ String *argv_in_out,
+ String *fallback_resources,
+ ArgList args_in,
+ Cardinal num_args_in
+ )
+ #else
+ Widget
  XtAppInitialize(app_context_return, application_class, options, num_options,
  		argc_in_out, argv_in_out, fallback_resources, 
  		args_in, num_args_in)
***************
*** 84,89 ****
--- 110,116 ----
  int *argc_in_out;
  String *argv_in_out, * fallback_resources;     
  ArgList args_in;
+ #endif
  {
      extern Widget _XtAppInitialize();
      VENDORINIT
***************
*** 92,103 ****
  			     fallback_resources, args_in, num_args_in);
  }
  
! #if NeedFunctionPrototypes
  Widget
! XtVaAppInitialize(XtAppContext *app_context_return, String application_class,
! 		  XrmOptionDescList options, Cardinal num_options,
! 		  int *argc_in_out, String *argv_in_out,
! 		  String *fallback_resources, ...)
  #else
  Widget XtVaAppInitialize(app_context_return, application_class, options,
  			 num_options, argc_in_out, argv_in_out,
--- 119,135 ----
  			     fallback_resources, args_in, num_args_in);
  }
  
! #if NeedVarargsPrototypes
  Widget
! XtVaAppInitialize(
!     XtAppContext *app_context_return,
!     _Xconst char* application_class,
!     XrmOptionDescList options,
!     Cardinal num_options,
!     int *argc_in_out,
!     String *argv_in_out,
!     String *fallback_resources,
!     ...)
  #else
  Widget XtVaAppInitialize(app_context_return, application_class, options,
  			 num_options, argc_in_out, argv_in_out,

*** /tmp/,RCSt1024386	Mon Dec 23 13:18:28 1991
--- mit/lib/Xt/Initialize.c	Thu Dec 19 19:32:53 1991
***************
*** 1,4 ****
! /* $XConsortium: Initialize.c,v 1.199 91/07/23 12:16:38 rws Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Initialize.c,v 1.200 91/12/19 19:30:59 rws Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 53,61 ****
   * If used as a shared library, generate code under a different name so that
   * the stub routines in sharedlib.c get loaded into the application binary.
   */
- #ifdef SUNSHLIB
- #define _XtInherit __XtInherit
- #endif
  #define XtToolkitInitialize _XtToolkitInitialize
  #define XtAppInitialize _XtAppInitialize
  #define XtInitialize _XtInitialize
--- 53,58 ----
***************
*** 141,146 ****
--- 138,152 ----
      return len;
  }
  
+ 
+ #ifdef SUNSHLIB
+ void _XtInherit()
+ {
+     extern void __XtInherit();
+     __XtInherit();
+ }
+ #define _XtInherit __XtInherit
+ #endif
  
  void _XtInherit()
  {

*** /tmp/,RCSt1a00686	Fri Jan  3 18:25:24 1992
--- mit/lib/Xt/Destroy.c	Fri Jan  3 18:05:36 1992
***************
*** 1,4 ****
! /* $XConsortium: Destroy.c,v 1.43 91/06/30 17:02:46 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
--- 1,4 ----
! /* $XConsortium: Destroy.c,v 1.44 92/01/03 18:03:59 converse Exp $ */
  
  /***********************************************************
  Copyright 1987, 1988 by Digital Equipment Corporation, Maynard, Massachusetts,
***************
*** 124,130 ****
  
      parent = widget->core.parent;
  
!     if (parent && parent->core.num_popups) {
  	int i;
  	for (i = 0; i < parent->core.num_popups; i++) {
  	    if (parent->core.popup_list[i] == widget) {
--- 124,130 ----
  
      parent = widget->core.parent;
  
!     if (parent && XtIsWidget(parent) && parent->core.num_popups) {
  	int i;
  	for (i = 0; i < parent->core.num_popups; i++) {
  	    if (parent->core.popup_list[i] == widget) {

*** /tmp/,RCSt1003447	Thu Jan 23 17:38:32 1992
--- mit/lib/Xmu/Imakefile	Fri Dec 20 11:22:04 1991
***************
*** 1,4 ****
! XCOMM $XConsortium: Imakefile,v 1.73 91/09/18 14:29:12 rws Exp $
  XCOMM
  XCOMM This library contains miscellaneous utility routines and is not part
  XCOMM of the Xlib standard.
--- 1,4 ----
! XCOMM $XConsortium: Imakefile,v 1.74 91/12/20 11:20:22 rws Exp $
  XCOMM
  XCOMM This library contains miscellaneous utility routines and is not part
  XCOMM of the Xlib standard.
***************
*** 10,18 ****
  #define DoProfileLib ProfileLibXmu
  #include <Library.tmpl>
  
! #ifdef RsArchitecture
! REQUIREDLIBS = $(EXTENSIONSRC)/lib/libXext.a $(TOOLKITSRC)/libXt.a $(XLIBSRC)/libX11.a
  #endif
  
  /* Since people link in Xmu without Xt, we avoid references to string data. */
  #if HasSharedLibraries
--- 10,22 ----
  #define DoProfileLib ProfileLibXmu
  #include <Library.tmpl>
  
! #if defined(RsArchitecture) || SunPost411FCSLd
! #if DoNormalLib
! REQUIREDLIBS = -L../$(TOOLKITSRC) -lXt -L../$(EXTENSIONSRC)/lib -lXext -L../$(XLIBSRC) -lX11
! #else
! REQUIREDLIBS = -L$(TOOLKITSRC) -lXt -L$(EXTENSIONSRC)/lib -lXext -L$(XLIBSRC) -lX11
  #endif
+ #endif
  
  /* Since people link in Xmu without Xt, we avoid references to string data. */
  #if HasSharedLibraries
***************
*** 152,157 ****
--- 156,167 ----
  #endif
  
  #if DoSharedLib
+ #if SunPost411FCSLd
+ libXmu.so.$(SOXMUREV): $(EXTENSIONSRC)/lib/libXext.so.$(SOXEXTREV)
+ 
+ $(EXTENSIONSRC)/lib/libXext.so.$(SOXEXTREV):
+ 	cd $(EXTENSIONSRC)/lib; make libXext.so.$(SOXEXTREV)
+ #endif
  #if DoNormalLib
  SharedLibraryTarget(Xmu,$(SOXMUREV),$(OBJS),shared,..)
  #else

*** /tmp/,RCSt1008492	Fri Dec 27 15:13:39 1991
--- mit/lib/nls/Xsi/local_im_tbl/lt_LN.bit7	Fri Dec 27 15:12:27 1991
***************
*** 1,4 ****
! # $XConsortium: lt_LN.bit7,v 1.3 91/12/11 11:01:15 rws Exp $
  #
  #	Conversion file for Local Input Method
  #
--- 1,4 ----
! # $XConsortium: lt_LN.bit7,v 1.4 91/12/27 15:10:49 rws Exp $
  #
  #	Conversion file for Local Input Method
  #
***************
*** 7,17 ****
--- 7,20 ----
  #	<from>[<from>...]	[<to>[<to>...]]	[{to_string}[{to_string}...]
  #  or
  #	<from>[<from>...]	Command
+ #  or
+ #	InitialState		OnState/OffState
  #
  #  from : Input keysym
  #  to_keysym : Output keysym
  #  to_string : Output string
  #  Command : Special commad (NoFilter/ConvertOn/ConvertOff)
+ #  InitialState : Initial state (default is OnState)
  
  <Shift_L>			NoFilter
  <Shift_R>			NoFilter
*** /tmp/,RCSt1008492	Fri Dec 27 15:13:42 1991
--- mit/lib/nls/Xsi/local_im_tbl/lt_LN.bit8	Fri Dec 27 15:12:31 1991
***************
*** 1,4 ****
! # $XConsortium: lt_LN.bit8,v 1.3 91/12/11 11:01:22 rws Exp $
  #
  #	Conversion file for Local Input Method
  #
--- 1,4 ----
! # $XConsortium: lt_LN.bit8,v 1.4 91/12/27 15:11:10 rws Exp $
  #
  #	Conversion file for Local Input Method
  #
***************
*** 7,17 ****
--- 7,20 ----
  #	<from>[<from>...]	[<to>[<to>...]]	[{to_string}[{to_string}...]
  #  or
  #	<from>[<from>...]	Command
+ #  or
+ #	InitialState		OnState/OffState
  #
  #  from : Input keysym
  #  to_keysym : Output keysym
  #  to_string : Output string
  #  Command : Special commad (NoFilter/ConvertOn/ConvertOff)
+ #  InitialState : Initial state (default is OnState)
  
  <Shift_L>			NoFilter
  <Shift_R>			NoFilter

*** /tmp/,RCSt1K_wBIj	Wed Dec 11 19:51:50 1991
--- mit/fonts/lib/font/fontfile/dirfile.c	Wed Dec 11 19:49:40 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: dirfile.c,v 1.4 91/07/25 18:05:10 rws Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: dirfile.c,v 1.5 91/12/11 19:49:06 eswu Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
***************
*** 69,77 ****
--- 69,82 ----
  	    return BadFontPath;
  	}
  	dir = FontFileMakeDir(directory, i);
+ 	if (dir == NULL) {
+ 	    fclose(file);
+ 	    return BadFontPath;
+ 	}
  	dir->dir_mtime = statb.st_mtime;
  	while ((count = fscanf(file, "%s %[^\n]\n", file_name, font_name)) != EOF) {
  	    if (count != 2) {
+ 		FontFileFreeDir (dir);
  		fclose(file);
  		return BadFontPath;
  	    }
***************
*** 78,83 ****
--- 83,89 ----
  	    if (!FontFileAddFontFile (dir, font_name, file_name))
  	    {
  		FontFileFreeDir (dir);
+ 		fclose(file);
  		return BadFontPath;
  	    }
  	}
*** /tmp/,RCSt1K%YCKs	Wed Dec 11 19:51:52 1991
--- mit/fonts/lib/font/fontfile/fontdir.c	Wed Dec 11 19:49:30 1991
***************
*** 1,5 ****
  /*
!  * $XConsortium: fontdir.c,v 1.5 91/07/16 20:13:27 keith Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: fontdir.c,v 1.6 91/12/11 19:46:47 eswu Exp $
   *
   * Copyright 1991 Massachusetts Institute of Technology
   *
***************
*** 50,55 ****
--- 50,58 ----
  {
      FontScalableExtraPtr   extra;
  
+     if (entry->name.name)
+ 	xfree(entry->name.name);
+ 
      switch (entry->type)
      {
      case FONT_ENTRY_SCALABLE:
***************
*** 122,127 ****
--- 125,131 ----
  {
      FontFileFreeTable (&dir->scalable);
      FontFileFreeTable (&dir->nonScalable);
+     xfree(dir);
  }
  
  FontEntryPtr

*** /tmp/,RCSt1a07990	Tue Jan 21 15:40:32 1992
--- mit/clients/xdm/util.c	Tue Jan 21 15:40:04 1992
***************
*** 1,7 ****
  /*
   * xdm - display manager daemon
   *
!  * $XConsortium: util.c,v 1.13 91/04/17 10:06:32 rws Exp $
   *
   * Copyright 1988 Massachusetts Institute of Technology
   *
--- 1,7 ----
  /*
   * xdm - display manager daemon
   *
!  * $XConsortium: util.c,v 1.14 92/01/21 15:38:28 gildea Exp $
   *
   * Copyright 1988 Massachusetts Institute of Technology
   *
***************
*** 62,67 ****
--- 62,69 ----
  	char	*name;
  {
  	int	l = strlen (name);
+ 
+ 	if (!e) return 0;
  
  	while (*e) {
  		if ((int)strlen (*e) > l && !strncmp (*e, name, l) &&

*** /tmp/,RCSt1003252	Thu Jan 23 16:16:17 1992
--- mit/clients/xauth/process.c	Wed Jan 22 23:39:36 1992
***************
*** 1,5 ****
  /*
!  * $XConsortium: process.c,v 1.35 91/02/28 09:21:52 rws Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
--- 1,5 ----
  /*
!  * $XConsortium: process.c,v 1.41 92/01/22 23:39:12 gildea Exp $
   *
   * Copyright 1989 Massachusetts Institute of Technology
   *
***************
*** 42,48 ****
  
  #define SECURERPC "SUN-DES-1"
  
! #define XAUTH_DEFAULT_RETRIES 2		/* just a few times */
  #define XAUTH_DEFAULT_TIMEOUT 2		/* in seconds, be quick */
  #define XAUTH_DEFAULT_DEADTIME 600L	/* 10 minutes in seconds */
  
--- 42,48 ----
  
  #define SECURERPC "SUN-DES-1"
  
! #define XAUTH_DEFAULT_RETRIES 10	/* number of competitors we expect */
  #define XAUTH_DEFAULT_TIMEOUT 2		/* in seconds, be quick */
  #define XAUTH_DEFAULT_DEADTIME 600L	/* 10 minutes in seconds */
  
***************
*** 88,94 ****
  static int do_help(), do_source(), do_info(), do_exit();
  static int do_quit(), do_questionmark();
  
! CommandTable command_table[] = {	/* table of known commands */
      { "add",      2, 3, do_add,
  	"add dpyname protoname hexkey   add entry" },
      { "exit",     3, 4, do_exit,
--- 88,94 ----
  static int do_help(), do_source(), do_info(), do_exit();
  static int do_quit(), do_questionmark();
  
! static CommandTable command_table[] = {	/* table of known commands */
      { "add",      2, 3, do_add,
  	"add dpyname protoname hexkey   add entry" },
      { "exit",     3, 4, do_exit,
***************
*** 192,202 ****
  static char *skip_space (s)
      register char *s;
  {
-     register char c;
- 
      if (!s) return NULL;
  
!     for (; (c = *s) && isascii(c) && isspace(c); s++) ;
      return s;
  }
  
--- 192,201 ----
  static char *skip_space (s)
      register char *s;
  {
      if (!s) return NULL;
  
!     for ( ; *s && isascii(*s) && isspace(*s); s++)
! 	;
      return s;
  }
  
***************
*** 204,215 ****
  static char *skip_nonspace (s)
      register char *s;
  {
-     register char c;
- 
      if (!s) return NULL;
  
      /* put quoting into loop if need be */
!     for (; (c = *s) && isascii(c) && !isspace(c); s++) ;
      return s;
  }
  
--- 203,213 ----
  static char *skip_nonspace (s)
      register char *s;
  {
      if (!s) return NULL;
  
      /* put quoting into loop if need be */
!     for ( ; *s && isascii(*s) && !isspace(*s); s++)
! 	;
      return s;
  }
  
***************
*** 591,596 ****
--- 589,595 ----
  #define _signal_t void
  #endif
  
+ /* ARGSUSED */
  static _signal_t die (sig)
      int sig;
  {
***************
*** 609,615 ****
      if (sig > 0) signal (sig, die);	/* re-establish signal handler */
  #endif
      if (verbose && xauth_modified) printf ("\r\n");
!     die ();
      /* NOTREACHED */
  #ifdef SIGNALRETURNSINT
      return -1;				/* for picky compilers */
--- 608,614 ----
      if (sig > 0) signal (sig, die);	/* re-establish signal handler */
  #endif
      if (verbose && xauth_modified) printf ("\r\n");
!     die (sig);
      /* NOTREACHED */
  #ifdef SIGNALRETURNSINT
      return -1;				/* for picky compilers */
***************
*** 657,670 ****
      hexvalues['e'] = hexvalues['E'] = 0xe;
      hexvalues['f'] = hexvalues['F'] = 0xf;
  
-     exists = (access (authfilename, F_OK) == 0);
-     if (exists && access (authfilename, W_OK) != 0) {
- 	fprintf (stderr,
- 	 "%s:  %s not writable, changes will be ignored\n",
- 		 ProgramName, authfilename);
- 	xauth_allowed = False;
-     }
- 
      if (break_locks && verbose) {
  	printf ("Attempting to break locks on authority file %s\n",
  		authfilename);
--- 656,661 ----
***************
*** 692,697 ****
--- 683,697 ----
  	}
      }
  
+     /* these checks can only be done reliably after the file is locked */
+     exists = (access (authfilename, F_OK) == 0);
+     if (exists && access (authfilename, W_OK) != 0) {
+ 	fprintf (stderr,
+ 	 "%s:  %s not writable, changes will be ignored\n",
+ 		 ProgramName, authfilename);
+ 	xauth_allowed = False;
+     }
+ 
      original_umask = umask (0077);	/* disallow non-owner access */
  
      authfp = fopen (authfilename, "r");
***************
*** 750,758 ****
  	return -1;
      } 
  
      for (list = xauth_head; list; list = list->next) {
! 	XauWriteAuth (fp, list->auth);
      }
  
      (void) fclose (fp);
      return 0;
--- 750,773 ----
  	return -1;
      } 
  
+     /*
+      * Write MIT-MAGIC-COOKIE-1 first, because R4 Xlib knows
+      * only that and uses the first authorization it finds.
+      */
      for (list = xauth_head; list; list = list->next) {
! 	if (list->auth->name_length == 18
! 	    && strncmp(list->auth->name, "MIT-MAGIC-COOKIE-1", 18) == 0)
! 	{
! 	    XauWriteAuth (fp, list->auth);
! 	}
      }
+     for (list = xauth_head; list; list = list->next) {
+ 	if (list->auth->name_length != 18
+ 	    || strncmp(list->auth->name, "MIT-MAGIC-COOKIE-1", 18) != 0)
+ 	{
+ 	    XauWriteAuth (fp, list->auth);
+ 	}
+     }
  
      (void) fclose (fp);
      return 0;
***************
*** 829,835 ****
  
  static void fprintfhex (fp, len, cp)
      register FILE *fp;
!     int len;
      char *cp;
  {
      unsigned char *ucp = (unsigned char *) cp;
--- 844,850 ----
  
  static void fprintfhex (fp, len, cp)
      register FILE *fp;
!     unsigned int len;
      char *cp;
  {
      unsigned char *ucp = (unsigned char *) cp;
***************
*** 859,864 ****
--- 874,880 ----
      return;
  }
  
+ /* ARGSUSED */
  static int dump_entry (inputfilename, lineno, auth, data)
      char *inputfilename;
      int lineno;
***************
*** 933,939 ****
  }
  
  
! static int match_auth (a, b)
      register Xauth *a, *b;
  {
      return ((a->family == b->family &&
--- 949,955 ----
  }
  
  
! static int match_auth_dpy (a, b)
      register Xauth *a, *b;
  {
      return ((a->family == b->family &&
***************
*** 943,949 ****
--- 959,975 ----
  	     bcmp (a->number, b->number, a->number_length) == 0) ? 1 : 0);
  }
  
+ /* return non-zero iff display and authorization type are the same */
  
+ static int match_auth (a, b)
+     register Xauth *a, *b;
+ {
+     return ((match_auth_dpy(a, b)
+ 	     && a->name_length == b->name_length
+ 	     && bcmp(a->name, b->name, a->name_length) == 0) ? 1 : 0);
+ }
+ 
+ 
  static int merge_entries (firstp, second, nnewp, nreplp)
      AuthList **firstp, *second;
      int *nnewp, *nreplp;
***************
*** 977,983 ****
  	AuthList *next = b->next;	/* in case we free it */
  
  	a = first;
! 	while (1) {
  	    if (match_auth (a->auth, b->auth)) {  /* found a duplicate */
  		AuthList tmp;		/* swap it in for old one */
  		tmp = *a;
--- 1003,1009 ----
  	AuthList *next = b->next;	/* in case we free it */
  
  	a = first;
! 	for (;;) {
  	    if (match_auth (a->auth, b->auth)) {  /* found a duplicate */
  		AuthList tmp;		/* swap it in for old one */
  		tmp = *a;
***************
*** 1024,1030 ****
      int status;
      int errors = 0;
      Xauth proto;
!     AuthList *l;
  
      /*
       * iterate
--- 1050,1056 ----
      int status;
      int errors = 0;
      Xauth proto;
!     AuthList *l, *next;
  
      /*
       * iterate
***************
*** 1039,1046 ****
  	    continue;
  	}
  	status = 0;
! 	for (l = xauth_head; l; l = l->next) {
! 	    if (match_auth (&proto, l->auth)) {
  		if (yfunc) {
  		    status = (*yfunc) (inputfilename, lineno,
  				       l->auth, data);
--- 1065,1073 ----
  	    continue;
  	}
  	status = 0;
! 	for (l = xauth_head; l; l = next) {
! 	    next = l->next;
! 	    if (match_auth_dpy (&proto, l->auth)) {
  		if (yfunc) {
  		    status = (*yfunc) (inputfilename, lineno,
  				       l->auth, data);
***************
*** 1065,1070 ****
--- 1092,1098 ----
      return errors;
  }
  
+ /* ARGSUSED */
  static int remove_entry (inputfilename, lineno, auth, data)
      char *inputfilename;
      int lineno;
***************
*** 1073,1114 ****
  {
      int *nremovedp = (int *) data;
      AuthList **listp = &xauth_head;
!     AuthList *prev = NULL, *list = (*listp);
!     int removed = 0, notremoved = 0;
  
-     if (!list) {
- 	*nremovedp = 0;
- 	return 1;			/* if nothing to remove */
-     }
- 
      /*
!      * run through list removing any records that match
       */
!     while (list) {
! 	if (match_auth (list->auth, auth)) {
! 	    AuthList *next = list->next;	      /* next one to look at */
! 	    if (prev) {
! 		prev->next = next;		       /* unlink current one */
! 	    } else {
! 		*listp = next;			       /* bump start of list */
! 	    }
! 	    XauDisposeAuth (list->auth);                    /* free the auth */
! 	    free (list);				    /* free the link */
! 	    list = next;			  /* go look at the next one */
! 	    removed++;
! 	    xauth_modified = True;
! 	} else {
! 	    notremoved++;
! 	    prev = list;
! 	    list = list->next;
! 	}
!     }
! 
!     if (notremoved == 0) {		/* if nothing left */
! 	*listp = NULL;			/* then null out list */
!     }
!     *nremovedp = removed;
!     return 0;
  }
  
  /*
--- 1101,1119 ----
  {
      int *nremovedp = (int *) data;
      AuthList **listp = &xauth_head;
!     AuthList *list;
  
      /*
!      * unlink the auth we were asked to
       */
!     while ((list = *listp)->auth != auth)
! 	listp = &list->next;
!     *listp = list->next;
!     XauDisposeAuth (list->auth);                    /* free the auth */
!     free (list);				    /* free the link */
!     xauth_modified = True;
!     (*nremovedp)++;
!     return 1;
  }
  
  /*
***************
*** 1179,1184 ****
--- 1184,1190 ----
  /*
   * questionmark
   */
+ /* ARGSUSED */
  static int do_questionmark (inputfilename, lineno, argc, argv)
      char *inputfilename;
      int lineno;
***************
*** 1524,1529 ****
--- 1530,1536 ----
   */
  static Bool alldone = False;
  
+ /* ARGSUSED */
  static int do_exit (inputfilename, lineno, argc, argv)
      char *inputfilename;
      int lineno;
***************
*** 1538,1543 ****
--- 1545,1551 ----
  /*
   * quit
   */
+ /* ARGSUSED */
  static int do_quit (inputfilename, lineno, argc, argv)
      char *inputfilename;
      int lineno;
***************
*** 1547,1555 ****
      /* allow bogus stuff */
      die (0);
      /* NOTREACHED */
- #ifdef SIGNALRETURNSINT
      return -1;				/* for picky compilers */
- #endif
  }
  
  
--- 1555,1561 ----

*** /tmp/,RCSt1003259	Thu Jan 23 16:18:38 1992
--- mit/clients/xterm/main.c	Mon Dec 23 17:03:02 1991
***************
*** 1,5 ****
  #ifndef lint
! static char *rid="$XConsortium: main.c,v 1.195 91/07/22 12:23:31 gildea Exp $";
  #endif /* lint */
  
  /*
--- 1,5 ----
  #ifndef lint
! static char *rid="$XConsortium: main.c,v 1.199 91/12/23 17:02:24 gildea Exp $";
  #endif /* lint */
  
  /*
***************
*** 745,751 ****
  	register TScreen *screen;
  	register int i, pty;
  	int Xsocket, mode;
! 	char *basename();
  	int xerror(), xioerror();
  
  	ProgramName = argv[0];
--- 745,751 ----
  	register TScreen *screen;
  	register int i, pty;
  	int Xsocket, mode;
! 	char *base_name();
  	int xerror(), xioerror();
  
  	ProgramName = argv[0];
***************
*** 1022,1028 ****
  
  	    if (!resource.title) {
  		if (command_to_exec) {
! 		    resource.title = basename (command_to_exec[0]);
  		} /* else not reached */
  	    }
  
--- 1022,1028 ----
  
  	    if (!resource.title) {
  		if (command_to_exec) {
! 		    resource.title = base_name (command_to_exec[0]);
  		} /* else not reached */
  	    }
  
***************
*** 1092,1097 ****
--- 1092,1115 ----
  	}
  	screen->inhibit = inhibit;
  
+ #ifdef AIXV3
+ 	/* In AIXV3, xterms started from /dev/console have CLOCAL set.
+ 	 * This means we need to clear CLOCAL so that SIGHUP gets sent
+ 	 * to the slave-pty process when xterm exits. 
+ 	 */
+ 
+ 	{
+ 	    struct termio tio;
+ 
+ 	    if(ioctl(pty, TCGETA, &tio) == -1)
+ 		SysError(ERROR_TIOCGETP);
+ 
+ 	    tio.c_cflag &= ~(CLOCAL);
+ 
+ 	    if (ioctl (pty, TCSETA, &tio) == -1)
+ 		SysError(ERROR_TIOCSETP);
+ 	}
+ #endif
  #ifdef USE_SYSV_TERMIO
  	if (0 > (mode = fcntl(pty, F_GETFL, 0)))
  		Error();
***************
*** 1125,1131 ****
  	}
  }
  
! char *basename(name)
  char *name;
  {
  	register char *cp;
--- 1143,1149 ----
  	}
  }
  
! char *base_name(name)
  char *name;
  {
  	register char *cp;
***************
*** 1183,1188 ****
--- 1201,1224 ----
  #endif
  	return 0;
  #else /* ATT else */
+ #ifdef AIXV3
+ 	if ((*pty = open ("/dev/ptc", O_RDWR)) < 0) {
+ 	    return 1;
+ 	}
+ 	strcpy(ttydev, ttyname(*pty));
+ 	return 0;
+ #endif
+ #ifdef sgi
+ 	{
+ 	    char    *tty_name;
+ 
+ 	    tty_name = _getpty (pty, O_RDWR, 0622, 0);
+ 	    if (tty_name == 0)
+ 		return 1;
+ 	    strcpy (ttydev, tty_name);
+ 	    return 0;
+ 	}
+ #endif
  #ifdef __convex__
          {
  	    char *pty_name, *getpty();
***************
*** 1201,1207 ****
  #ifdef USE_GET_PSEUDOTTY
  	return ((*pty = getpseudotty (&ttydev, &ptydev)) >= 0 ? 0 : 1);
  #else
! #if defined(sgi) || (defined(umips) && defined (SYSTYPE_SYSV))
  	struct stat fstat_buf;
  
  	*pty = open ("/dev/ptc", O_RDWR);
--- 1237,1243 ----
  #ifdef USE_GET_PSEUDOTTY
  	return ((*pty = getpseudotty (&ttydev, &ptydev)) >= 0 ? 0 : 1);
  #else
! #if (defined(umips) && defined (SYSTYPE_SYSV))
  	struct stat fstat_buf;
  
  	*pty = open ("/dev/ptc", O_RDWR);
***************
*** 1532,1539 ****
  			if (tty_got_hung || errno == ENXIO || errno == EIO ||
  			    errno == ENOTTY) {
  				no_dev_tty = TRUE;
- #ifdef USE_SYSV_TERMIO
- 				tio = d_tio;
  #ifdef TIOCSLTC
  				ltc = d_ltc;
  #endif	/* TIOCSLTC */
--- 1568,1573 ----
***************
*** 1540,1554 ****
  #ifdef TIOCLSET
  				lmode = d_lmode;
  #endif	/* TIOCLSET */
  #else	/* not USE_SYSV_TERMIO */
  				sg = d_sg;
  				tc = d_tc;
  				discipline = d_disipline;
- 				ltc = d_ltc;
- 				lmode = d_lmode;
  #ifdef sony
- 				jtc = d_jtc;
  				jmode = d_jmode;
  #endif /* sony */
  #endif	/* USE_SYSV_TERMIO */
  			} else {
--- 1574,1588 ----
  #ifdef TIOCLSET
  				lmode = d_lmode;
  #endif	/* TIOCLSET */
+ #ifdef USE_SYSV_TERMIO
+ 				tio = d_tio;
  #else	/* not USE_SYSV_TERMIO */
  				sg = d_sg;
  				tc = d_tc;
  				discipline = d_disipline;
  #ifdef sony
  				jmode = d_jmode;
+ 				jtc = d_jtc;
  #endif /* sony */
  #endif	/* USE_SYSV_TERMIO */
  			} else {
***************
*** 1555,1605 ****
  			    SysError(ERROR_OPDEVTTY);
  			}
  		} else {
! 			/* get a copy of the current terminal's state */
! 
! #ifdef USE_SYSV_TERMIO
! 		        /* SVR4 fails here if xterm started
! 			   from twm from xdm from /etc/rc.
! 			   Hence the protection for the next 3 ioctl's.
! 			   Something about not having a controlling tty. */
! 		        if(ioctl(tty, TCGETA, &tio) == -1)
! #ifndef SVR4
! 				SysError(ERROR_TIOCGETP);
! #else /* SVR4 */
! 			        tio = d_tio;
! #endif /* SVR4 */
  #ifdef TIOCSLTC
  			if(ioctl(tty, TIOCGLTC, &ltc) == -1)
- #ifndef SVR4
- 				SysError(ERROR_TIOCGLTC);
- #else /* SVR4 */
  				ltc = d_ltc;
- #endif /* SVR4 */
  #endif	/* TIOCSLTC */
  #ifdef TIOCLSET
  			if(ioctl(tty, TIOCLGET, &lmode) == -1)
- #ifndef SVR4
- 				SysError(ERROR_TIOCLGET);
- #else /* SVR4 */
  				lmode = d_lmode;
- #endif /* SVR4 */
  #endif	/* TIOCLSET */
  #else	/* not USE_SYSV_TERMIO */
  			if(ioctl(tty, TIOCGETP, (char *)&sg) == -1)
! 				SysError (ERROR_TIOCGETP);
  			if(ioctl(tty, TIOCGETC, (char *)&tc) == -1)
! 				SysError (ERROR_TIOCGETC);
  			if(ioctl(tty, TIOCGETD, (char *)&discipline) == -1)
! 				SysError (ERROR_TIOCGETD);
! 			if(ioctl(tty, TIOCGLTC, (char *)&ltc) == -1)
! 				SysError (ERROR_TIOCGLTC);
! 			if(ioctl(tty, TIOCLGET, (char *)&lmode) == -1)
! 				SysError (ERROR_TIOCLGET);
  #ifdef sony
  			if(ioctl(tty, TIOCKGET, (char *)&jmode) == -1)
! 				SysError (ERROR_TIOCKGET);
  			if(ioctl(tty, TIOCKGETC, (char *)&jtc) == -1)
! 				SysError (ERROR_TIOCKGETC);
  #endif /* sony */
  #endif	/* USE_SYSV_TERMIO */
  			close (tty);
--- 1589,1624 ----
  			    SysError(ERROR_OPDEVTTY);
  			}
  		} else {
! 			/* Get a copy of the current terminal's state,
! 			 * if we can.  Some systems (e.g., SVR4 and MacII)
! 			 * may not have a controlling terminal at this point
! 			 * if started directly from xdm or xinit,     
! 			 * in which case we just use the defaults as above.
! 			 */
  #ifdef TIOCSLTC
  			if(ioctl(tty, TIOCGLTC, &ltc) == -1)
  				ltc = d_ltc;
  #endif	/* TIOCSLTC */
  #ifdef TIOCLSET
  			if(ioctl(tty, TIOCLGET, &lmode) == -1)
  				lmode = d_lmode;
  #endif	/* TIOCLSET */
+ #ifdef USE_SYSV_TERMIO
+ 		        if(ioctl(tty, TCGETA, &tio) == -1)
+ 			        tio = d_tio;
+ 
  #else	/* not USE_SYSV_TERMIO */
  			if(ioctl(tty, TIOCGETP, (char *)&sg) == -1)
! 			        sg = d_sg;
  			if(ioctl(tty, TIOCGETC, (char *)&tc) == -1)
! 			        tc = d_tc;
  			if(ioctl(tty, TIOCGETD, (char *)&discipline) == -1)
! 			        discipline = d_disipline;
  #ifdef sony
  			if(ioctl(tty, TIOCKGET, (char *)&jmode) == -1)
! 			        jmode = d_jmode;
  			if(ioctl(tty, TIOCKGETC, (char *)&jtc) == -1)
! 				jtc = d_jtc;
  #endif /* sony */
  #endif	/* USE_SYSV_TERMIO */
  			close (tty);

*** /tmp/,RCSt1a24265	Mon Dec 23 17:27:16 1991
--- mit/clients/xinit/xinit.c	Mon Dec 23 17:27:00 1991
***************
*** 1,6 ****
! #ifndef lint
! static char *rcsid_xinit_c = "$XConsortium: xinit.c,v 11.52 91/11/29 15:20:35 rws Exp $";
! #endif /* lint */
  
  /* Copyright    Massachusetts Institute of Technology    1986	*/
  
--- 1,4 ----
! /* $XConsortium: xinit.c,v 11.54 91/12/23 17:26:08 gildea Exp $ */
  
  /* Copyright    Massachusetts Institute of Technology    1986	*/
  
***************
*** 49,55 ****
  #define vfork() fork()
  #endif /* SYSV and not hpux */
  
! #ifndef X_NOT_POSIX
  #define setpgrp setpgid
  #endif
  
--- 47,55 ----
  #define vfork() fork()
  #endif /* SYSV and not hpux */
  
! /* A/UX setpgid incorrectly removes the controlling terminal.
!    Per Posix, only setsid should do that. */
! #if !defined(X_NOT_POSIX) && !defined(macII)
  #define setpgrp setpgid
  #endif
  

*** /tmp/,RCSt1000618	Thu Dec 26 15:01:42 1991
--- mit/server/ddx/cfb/cfbbresd.c	Thu Dec 26 15:01:43 1991
***************
*** 21,27 ****
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: cfbbresd.c,v 1.10 91/07/10 14:53:50 keith Exp $ */
  #include "X.h"
  #include "misc.h"
  #include "cfb.h"
--- 21,27 ----
  SOFTWARE.
  
  ******************************************************************/
! /* $XConsortium: cfbbresd.c,v 1.11 91/12/26 14:32:45 rws Exp $ */
  #include "X.h"
  #include "misc.h"
  #include "cfb.h"
***************
*** 66,72 ****
      andFg = rrops[0].and;
      xorBg = rrops[1].xor;
      andBg = rrops[1].and;
!     if ((thisDash = dashRemaining) > len)
      {
  	thisDash = len;
  	dashRemaining -= len;
--- 66,72 ----
      andFg = rrops[0].and;
      xorBg = rrops[1].xor;
      andBg = rrops[1].and;
!     if ((thisDash = dashRemaining) >= len)
      {
  	thisDash = len;
  	dashRemaining -= len;
***************
*** 80,86 ****
      if (dashIndex == numInDashList) \
  	dashIndex = 0; \
      dashRemaining = pDash[dashIndex]; \
!     if ((thisDash = dashRemaining) > len) \
      { \
  	dashRemaining -= len; \
  	thisDash = len; \
--- 80,86 ----
      if (dashIndex == numInDashList) \
  	dashIndex = 0; \
      dashRemaining = pDash[dashIndex]; \
!     if ((thisDash = dashRemaining) >= len) \
      { \
  	dashRemaining -= len; \
  	thisDash = len; \

*** /tmp/,RCSt1008508	Fri Dec 27 15:13:55 1991
--- mit/doc/I18N/Xsi/Xim/LocalIM.man	Fri Dec 27 15:13:20 1991
***************
*** 1,4 ****
! .\" $XConsortium: LocalIM.man,v 1.3 91/12/11 15:57:44 rws Exp $
  .\" Copyright 1991 by OMRON Corp.  All Rights Reserved.
  .TH LocalIM 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
  .SH NAME
--- 1,4 ----
! .\" $XConsortium: LocalIM.man,v 1.4 91/12/27 15:11:47 rws Exp $
  .\" Copyright 1991 by OMRON Corp.  All Rights Reserved.
  .TH LocalIM 3X11 "Release 5" "X Version 11" "XSI FUNCTIONS"
  .SH NAME
***************
*** 18,23 ****
--- 18,27 ----
  or
  .br
  <from>[<from>...]  Command
+ .br
+ or
+ .br
+ InitialState  OnState/OffState
  .sp
  .RE
  .IP \fBfrom\fP 1i
***************
*** 37,47 ****
  .IP ConvertOn 1i
  If the input keysym(s) (from) is(are) pressed, the input method
  move in a conversion \fBon\fP state.
! .IP ConvertOn 1i
  If the input keysym(s) (from) is(are) pressed, the input method
  move in a conversion \fBoff\fP state.
  .sp
  .RE
  .PP
  It is possible to omit \fIto\fP or \fIstr\fP. But either must be set.
  .PP
--- 41,55 ----
  .IP ConvertOn 1i
  If the input keysym(s) (from) is(are) pressed, the input method
  move in a conversion \fBon\fP state.
! .IP ConvertOff 1i
  If the input keysym(s) (from) is(are) pressed, the input method
  move in a conversion \fBoff\fP state.
  .sp
  .RE
+ .IP InitialState 1i
+ Specifies the initial state. The second argument is OnState or
+ OffState. The default state is OnState.
+ .sp
  .PP
  It is possible to omit \fIto\fP or \fIstr\fP. But either must be set.
  .PP
***************
*** 72,77 ****
--- 80,87 ----
  .SH EXAMPLE
  .sp
  .RS
+ InitialState            OffState
+ .br
  <Meta_L>                NoFilter
  .br
  <Execute>               ConvertOn

