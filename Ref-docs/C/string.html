<HTML><HEAD><TITLE>&lt;string.h&gt;</TITLE></HEAD><BODY BGCOLOR="#FFFFFF">

<H1><A NAME="&lt;string.h&gt;"><CODE>&lt;string.h&gt;</CODE></A></H1><HR>

<P><B><CODE><A HREF="#NULL">NULL</A>
&#183; <A HREF="#memchr">memchr</A>
&#183; <A HREF="#memchr">memchr</A>
&#183; <A HREF="#memchr">memchr</A>
&#183; <A HREF="#memcmp">memcmp</A>
&#183; <A HREF="#memcpy">memcpy</A>
&#183; <A HREF="#memmove">memmove</A>
&#183; <A HREF="#memset">memset</A>
&#183; <A HREF="#size_t">size_t</A>
&#183; <A HREF="#strcat">strcat</A>
&#183; <A HREF="#strchr">strchr</A>
&#183; <A HREF="#strchr">strchr</A>
&#183; <A HREF="#strchr">strchr</A>
&#183; <A HREF="#strcmp">strcmp</A>
&#183; <A HREF="#strcoll">strcoll</A>
&#183; <A HREF="#strcpy">strcpy</A>
&#183; <A HREF="#strcspn">strcspn</A>
&#183; <A HREF="#strerror">strerror</A>
&#183; <A HREF="#strlen">strlen</A>
&#183; <A HREF="#strncat">strncat</A>
&#183; <A HREF="#strncmp">strncmp</A>
&#183; <A HREF="#strncpy">strncpy</A>
&#183; <A HREF="#strpbrk">strpbrk</A>
&#183; <A HREF="#strpbrk">strpbrk</A>
&#183; <A HREF="#strpbrk">strpbrk</A>
&#183; <A HREF="#strrchr">strrchr</A>
&#183; <A HREF="#strrchr">strrchr</A>
&#183; <A HREF="#strrchr">strrchr</A>
&#183; <A HREF="#strspn">strspn</A>
&#183; <A HREF="#strstr">strstr</A>
&#183; <A HREF="#strstr">strstr</A>
&#183; <A HREF="#strstr">strstr</A>
&#183; <A HREF="#strtok">strtok</A>
&#183; <A HREF="#strxfrm">strxfrm</A>
</CODE></B></P>
<HR>

<P><CODE>
#define <A HREF="#NULL"><B>NULL</B></A>
<I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B><BR>
void *<A HREF="#memchr"><B>memchr</B></A>(const void *s,
int c, size_t n); <B>[not in C++]</B><BR>
const void *<A HREF="#memchr"><B>memchr</B></A>(const void *s,
int c, size_t n); <B>[C++ only]</B><BR>
void *<A HREF="#memchr"><B>memchr</B></A>(void *s,
int c, size_t n); <B>[C++ only]</B><BR>
int <A HREF="#memcmp"><B>memcmp</B></A>(const void *s1,
const void *s2, size_t n);<BR>
void *<A HREF="#memcpy"><B>memcpy</B></A>(void *s1,
const void *s2, size_t n);<BR>
void *<A HREF="#memmove"><B>memmove</B></A>(void *s1,
const void *s2, size_t n);<BR>
void *<A HREF="#memset"><B>memset</B></A>(void *s,
int c, size_t n);<BR>
typedef <I>ui-type</I> <A HREF="#size_t"><B>size_t</B></A>;<BR>
char *<A HREF="#strcat"><B>strcat</B></A>(char *s1,
const char *s2);<BR>
char *<A HREF="#strchr"><B>strchr</B></A>(const char *s,
int c); <B>[not in C++]</B><BR>
const char *<A HREF="#strchr"><B>strchr</B></A>(const char *s,
int c); <B>[C++ only]</B><BR>
char *<A HREF="#strchr"><B>strchr</B></A>(char *s,
int c); <B>[C++ only]</B><BR>
int <A HREF="#strcmp"><B>strcmp</B></A>(const char *s1,
const char *s2);<BR>
int <A HREF="#strcoll"><B>strcoll</B></A>(const char *s1,
const char *s2);<BR>
char *<A HREF="#strcpy"><B>strcpy</B></A>(char *s1,
const char *s2);<BR>
size_t <A HREF="#strcspn"><B>strcspn</B></A>(const char *s1,
const char *s2);<BR>
char *<A HREF="#strerror"><B>strerror</B></A>(int errcode);<BR>
size_t <A HREF="#strlen"><B>strlen</B></A>(const char *s);<BR>
char *<A HREF="#strncat"><B>strncat</B></A>(char *s1,
const char *s2, size_t n);<BR>
int <A HREF="#strncmp"><B>strncmp</B></A>(const char *s1,
const char *s2, size_t n);<BR>
char *<A HREF="#strncpy"><B>strncpy</B></A>(char *s1,
const char *s2, size_t n);<BR>
char *<A HREF="#strpbrk"><B>strpbrk</B></A>(const char *s1,
const char *s2); <B>[not in C++]</B><BR>
const char *<A HREF="#strpbrk"><B>strpbrk</B></A>(const char *s1,
const char *s2); <B>[C++ only]</B><BR>
char *<A HREF="#strpbrk"><B>strpbrk</B></A>(char *s1,
const char *s2); <B>[C++ only]</B><BR>
char *<A HREF="#strrchr"><B>strrchr</B></A>(const char *s,
int c); <B>[not in C++]</B><BR>
const char *<A HREF="#strrchr"><B>strrchr</B></A>(const char *s,
int c); <B>[C++ only]</B><BR>
char *<A HREF="#strrchr"><B>strrchr</B></A>(char *s,
int c); <B>[C++ only]</B><BR>
size_t <A HREF="#strspn"><B>strspn</B></A>(const char *s1,
const char *s2);<BR>
char *<A HREF="#strstr"><B>strstr</B></A>(const char *s1,
const char *s2); <B>[not in C++]</B><BR>
const char *<A HREF="#strstr"><B>strstr</B></A>(const char *s1,
const char *s2); <B>[C++ only]</B><BR>
char *<A HREF="#strstr"><B>strstr</B></A>(char *s1,
const char *s2); <B>[C++ only]</B><BR>
char *<A HREF="#strtok"><B>strtok</B></A>(char *s1,
const char *s2);<BR>
size_t <A HREF="#strxfrm"><B>strxfrm</B></A>(char *s1,
const char *s2, size_t n);<BR>
</CODE></P>

<P>Include the standard header <B><CODE>&lt;string.h&gt;</CODE></B> to declare a 
number of functions that help you manipulate
<A HREF="lib_over.html#C string" tppabs="http://ccs.ucsd.edu/c/lib_over.html#C string">C strings</A> and other arrays of 
characters.</P>

<H2><A NAME="NULL"><CODE>NULL</CODE></A></H2>

<P><CODE>
#define <B>NULL</B> <I>&lt;either 0, 0L, or (void *)0&gt;</I> <B>[0 in C++]</B>
</CODE></P>

<P>The macro yields a null pointer constant that is usable as an 
<A HREF="express.html#address constant expression" tppabs="http://ccs.ucsd.edu/c/express.html#address constant expression">
address constant expression</A>.</P>

<H2><A NAME="memchr"><CODE>memchr</CODE></A></H2>

<P><CODE>
void *<B>memchr</B>(const void *s, int c, size_t n); <B>[not in C++]</B><BR>
const void *memchr(const void *s, int c, size_t n); <B>[C++ only]</B><BR>
void *memchr(void *s, int c, size_t n); <B>[C++ only]</B>
</CODE></P>

<P>The function searches for the first element of an array of <I>unsigned 
char,</I> beginning at the address <CODE>s</CODE> with size <CODE>n</CODE>, 
that equals <CODE>(unsigned char)c</CODE>. If successful, it returns the 
address of the matching element; otherwise, it returns a null pointer.</P>

<H2><A NAME="memcmp"><CODE>memcmp</CODE></A></H2>

<P><CODE>
int <B>memcmp</B>(const void *s1, const void *s2, size_t n);
</CODE></P>

<P>The function compares successive elements from two arrays of <I>unsigned 
char,</I> beginning at the addresses <CODE>s1</CODE> and <CODE>s2</CODE> 
(both of size <CODE>n</CODE>),
until it finds elements that are not equal:</P>

<UL>
<LI>If all elements are equal, the function returns zero.

<LI>If the differing element from <CODE>s1</CODE> is greater than the 
element from <CODE>s2</CODE>, the function returns a positive number.

<LI>Otherwise, the function returns a negative number.
</UL>

<H2><A NAME="memcpy"><CODE>memcpy</CODE></A></H2>

<P><CODE>
void *<B>memcpy</B>(void *s1, const void *s2, size_t n);
</CODE></P>

<P>The function copies the array of <I>char</I> beginning at the address 
<CODE>s2</CODE> to the array of <I>char</I> beginning at the address 
<CODE>s1</CODE> (both of size <CODE>n</CODE>). It returns 
<CODE>s1</CODE>. The elements of the arrays can be accessed and stored in any 
order.</P>

<H2><A NAME="memmove"><CODE>memmove</CODE></A></H2>

<P><CODE>
void *<B>memmove</B>(void *s1, const void *s2, size_t n);
</CODE></P>

<P>The function copies the array of <I>char</I> beginning at 
<CODE>s2</CODE> to the array of <I>char</I> beginning at <CODE>s1</CODE> 
(both of size <CODE>n</CODE>). It returns <CODE>s1</CODE>. If the arrays 
overlap, the function accesses each of the element values from 
<CODE>s2</CODE> before it stores a new value in that element, so the copy is 
not corrupted.</P>

<H2><A NAME="memset"><CODE>memset</CODE></A></H2>

<P><CODE>
void *<B>memset</B>(void *s, int c, size_t n);
</CODE></P>

<P>The function stores <CODE>(unsigned char)c</CODE> in each of the 
elements of the array of <I>unsigned char</I> beginning at <CODE>s</CODE>, 
with size <CODE>n</CODE>. It returns <CODE>s</CODE>.</P>

<H2><A NAME="size_t"><CODE>size_t</CODE></A></H2>

<P><CODE>
typedef <I>ui-type</I> <B>size_t</B>;
</CODE></P>

<P>The type is the unsigned integer type <CODE><I>ui-type</I></CODE>
of an object that you declare to store the result of the
<A HREF="express.html#sizeof operator" tppabs="http://ccs.ucsd.edu/c/express.html#sizeof operator"><I>sizeof</I></A> operator.</P>

<H2><A NAME="strcat"><CODE>strcat</CODE></A></H2>

<P><CODE>
char *<B>strcat</B>(char *s1, const char *s2);
</CODE></P>

<P>The function copies the string <CODE>s2</CODE>, including its 
terminating null character, to successive elements
of the array of <I>char</I> that stores the string <CODE>s1</CODE>,
beginning with the element that stores
the terminating null character of <CODE>s1</CODE>. It returns 
<CODE>s1</CODE>.</P>

<H2><A NAME="strchr"><CODE>strchr</CODE></A></H2>

<P><CODE>
char *<B>strchr</B>(const char *s, int c); <B>[not in C++]</B><BR>
const char *strchr(const char *s, int c); <B>[C++ only]</B><BR>
char *strchr(char *s, int c); <B>[C++ only]</B>
</CODE></P>

<P>The function searches for the first element of the string 
<CODE>s</CODE> that equals <CODE>(char)c</CODE>. It considers the 
terminating null character as part of the string. If successful, the function 
returns the address of the matching element; otherwise, it returns a null 
pointer.</P>

<H2><A NAME="strcmp"><CODE>strcmp</CODE></A></H2>

<P><CODE>
int <B>strcmp</B>(const char *s1, const char *s2);
</CODE></P>

<P>The function compares successive elements from two strings, 
<CODE>s1</CODE> and <CODE>s2</CODE>, until it finds elements that are not 
equal.</P>

<UL>
<LI>If all elements are equal, the function returns zero.

<LI>If the differing element from <CODE>s1</CODE> is greater than the 
element from <CODE>s2</CODE> (both taken as <I>unsigned char</I>), the 
function returns a positive number.

<LI>Otherwise, the function returns a negative number.
</UL>

<H2><A NAME="strcoll"><CODE>strcoll</CODE></A></H2>

<P><CODE>
int <B>strcoll</B>(const char *s1, const char *s2);
</CODE></P>

<P>The function compares two strings, <CODE>s1</CODE> and 
<CODE>s2</CODE>, using a comparison rule that depends on the current
<A HREF="locale.html#locale" tppabs="http://ccs.ucsd.edu/c/locale.html#locale">locale</A>. If <CODE>s1</CODE>
compares greater than <CODE>s2</CODE> by this rule, the function returns a 
positive number. If the two strings compare equal,
it returns zero. Otherwise, it returns a negative number.</P>

<H2><A NAME="strcpy"><CODE>strcpy</CODE></A></H2>

<P><CODE>
char *<B>strcpy</B>(char *s1, const char *s2);
</CODE></P>

<P>The function copies the string <CODE>s2</CODE>, including its 
terminating null character, to successive elements
of the array of <I>char</I> 
whose first element has the address <CODE>s1</CODE>. It returns 
<CODE>s1</CODE>.</P>

<H2><A NAME="strcspn"><CODE>strcspn</CODE></A></H2>

<P><CODE>
size_t <B>strcspn</B>(const char *s1, const char *s2);
</CODE></P>

<P>The function searches for the first element 
<CODE>s1[i]</CODE> in the string <CODE>s1</CODE> that 
equals <I>any one</I> of the elements of the string <CODE>s2</CODE> and 
returns <CODE>i</CODE>. Each terminating null character
is considered part of its string.</P>

<H2><A NAME="strerror"><CODE>strerror</CODE></A></H2>

<P><CODE>
char *<B>strerror</B>(int errcode);
</CODE></P>

<P>The function returns a pointer to an internal static-duration object 
containing the message string corresponding to the error code 
<CODE>errcode</CODE>. The program must not alter any of the values stored in 
this object. A later call to <CODE>strerror</CODE> can alter the value stored 
in this object.</P>

<H2><A NAME="strlen"><CODE>strlen</CODE></A></H2>

<P><CODE>
size_t <B>strlen</B>(const char *s);
</CODE></P>

<P>The function returns the number of characters in the string 
<CODE>s</CODE>, <I>not</I> including its terminating null character.</P>

<H2><A NAME="strncat"><CODE>strncat</CODE></A></H2>

<P><CODE>
char *<B>strncat</B>(char *s1, const char *s2, size_t n);
</CODE></P>

<P>The function copies the string <CODE>s2</CODE>, <I>not</I> including 
its terminating null character, to successive elements of the array of 
<I>char</I> that stores the string <CODE>s1</CODE>, beginning with the 
element that stores the terminating null character of <CODE>s1</CODE>. The 
function copies no more than <CODE>n</CODE> characters from 
<CODE>s2</CODE>. It then stores a null character, in the next element to be 
altered in <CODE>s1</CODE>, and returns <CODE>s1</CODE>.</P>

<H2><A NAME="strncmp"><CODE>strncmp</CODE></A></H2>

<P><CODE>
int <B>strncmp</B>(const char *s1, const char *s2, size_t n);
</CODE></P>

<P>The function compares successive elements from two strings, 
<CODE>s1</CODE> and <CODE>s2</CODE>, until it finds elements that are not 
equal or until it has compared the first <CODE>n</CODE> elements of the two 
strings.</P>

<UL>
<LI>If all elements are equal, the function returns zero.

<LI>If the differing element from <CODE>s1</CODE> is greater than the 
element from <CODE>s2</CODE> (both taken as <I>unsigned char</I>), the 
function returns a positive number.

<LI>Otherwise, it returns a negative number.
</UL>

<H2><A NAME="strncpy"><CODE>strncpy</CODE></A></H2>

<P><CODE>
char *<B>strncpy</B>(char *s1, const char *s2, size_t n);
</CODE></P>

<P>The function copies the string <CODE>s2</CODE>, <I>not</I> including 
its terminating null character, to successive elements of the array of 
<I>char</I> whose first element has the address <CODE>s1</CODE>. It copies no 
more than <CODE>n</CODE> characters from <CODE>s2</CODE>. The function then 
stores zero or more null characters in the next elements to be altered in 
<CODE>s1</CODE> until it stores a total of <CODE>n</CODE> characters. It 
returns <CODE>s1</CODE>.</P>

<H2><A NAME="strpbrk"><CODE>strpbrk</CODE></A></H2>

<P><CODE>
char *<B>strpbrk</B>(const char *s1, const char *s2); <B>[not in C++]</B><BR>
const char *strpbrk(const char *s1, const char *s2); <B>[C++ only]</B><BR>
char *strpbrk(char *s1, const char *s2); <B>[C++ only]</B>
</CODE></P>

<P>The function searches for the first element 
<CODE>s1[i]</CODE> in the string <CODE>s1</CODE> that 
equals <I>any one</I> of the elements of the string <CODE>s2</CODE>. It 
considers each terminating null character as part of its string. If 
<CODE>s1[i]</CODE> is not the terminating null character, the 
function returns <CODE>&amp;s1[i]</CODE>; otherwise, it returns a 
null pointer.</P>

<H2><A NAME="strrchr"><CODE>strrchr</CODE></A></H2>

<P><CODE>
char *<B>strrchr</B>(const char *s, int c); <B>[not in C++]</B><BR>
const char *strrchr(const char *s, int c); <B>[C++ only]</B><BR>
char *strrchr(char *s, int c); <B>[C++ only]</B>
</CODE></P>

<P>The function searches for the last element of the string <CODE>s</CODE> 
that equals <CODE>(char)c</CODE>. It considers the terminating null character 
as part of the string. If successful, the function returns the address of the 
matching element; otherwise, it returns a null pointer.</P>

<H2><A NAME="strspn"><CODE>strspn</CODE></A></H2>

<P><CODE>
size_t <B>strspn</B>(const char *s1, const char *s2);
</CODE></P>

<P>The function searches for the first element 
<CODE>s1[i]</CODE> in the string <CODE>s1</CODE> that 
equals <I>none</I> of the elements of the string <CODE>s2</CODE> and returns 
<CODE>i</CODE>. It considers the terminating null character
as part of the string <CODE>s1</CODE> only.</P>

<H2><A NAME="strstr"><CODE>strstr</CODE></A></H2>

<P><CODE>
char *<B>strstr</B>(const char *s1, const char *s2); <B>[not in C++]</B><BR>
const char *strstr(const char *s1, const char *s2); <B>[C++ only]</B><BR>
char *strstr(char *s1, const char *s2); <B>[C++ only]</B>
</CODE></P>

<P>The function searches for the first sequence of elements in the string 
<CODE>s1</CODE> that matches the sequence of elements in the string 
<CODE>s2</CODE>, <I>not</I> including its terminating null character. If 
successful, the function returns the address of the matching first element; 
otherwise, it returns a null pointer.</P>

<H2><A NAME="strtok"><CODE>strtok</CODE></A></H2>

<P><CODE>
char *<B>strtok</B>(char *s1, const char *s2);
</CODE></P>

<P>If <CODE>s1</CODE> is not a null pointer, the function begins a search 
of the string <CODE>s1</CODE>. Otherwise, it begins a search of the string 
whose address was last stored in an internal static-duration object on an 
earlier call to the function, as described below. The search proceeds as 
follows:</P>

<OL>
<LI>The function searches the string for <CODE>begin</CODE>,
the address of the first element that equals
<I>none</I> of the elements of the string 
<CODE>s2</CODE> (a set of token separators). It considers the terminating 
null character as part of the search string only.

<LI>If the search does not find an element, the function stores the address 
of the terminating null character in the internal static-duration object (so 
that a subsequent search beginning with that address will fail) and returns a 
null pointer. Otherwise, the function searches from <CODE>begin</CODE> for 
<CODE>end</CODE>, the address of the first element
that equals <I>any one</I> of the elements of the string <CODE>s2</CODE>.
It again considers the terminating 
null character as part of the search string only.

<LI>If the search does not find an element, the function stores the address 
of the terminating null character in the internal static-duration object. 
Otherwise, it stores a null character in the element whose address is 
<CODE>end</CODE>. Then it stores the address
of the next element after <CODE>end</CODE> in 
the internal static-duration object
(so that a subsequent search beginning with 
that address will continue with the remaining elements of the string) and 
returns <CODE>begin</CODE>.
</OL>

<H2><A NAME="strxfrm"><CODE>strxfrm</CODE></A></H2>

<P><CODE>
size_t <B>strxfrm</B>(char *s1, const char *s2, size_t n);
</CODE></P>

<P>The function stores a string in the array of <I>char</I> whose first 
element has the address <CODE>s1</CODE>. It stores no more than 
<CODE>n</CODE> characters, <I>including</I> the terminating null character, 
and returns the number of characters needed to represent the entire string, 
<I>not</I> including the terminating null character. If the value returned is 
<CODE>n</CODE> or greater, the values stored in the array are indeterminate. 
(If <CODE>n</CODE> is zero, <CODE>s1</CODE> can be a null pointer.)</P>

<P><CODE>strxfrm</CODE> generates the string it stores from the string 
<CODE>s2</CODE> by using a transformation rule that depends on the current 
<A HREF="locale.html#locale" tppabs="http://ccs.ucsd.edu/c/locale.html#locale">locale</A>.
For example, if <CODE>x</CODE> is a transformation
of <CODE>s1</CODE> and <CODE>y</CODE> is a transformation
of <CODE>s2</CODE>, then
<CODE><A HREF="#strcmp">strcmp</A>(x, y)</CODE>
returns the same value as 
<CODE><A HREF="#strcoll">strcoll</A>(s1, s2)</CODE>.</P>

<HR>
<P>See also the
<B><A HREF="index.html#Table of Contents" tppabs="http://ccs.ucsd.edu/c/index.html#Table of Contents">Table of Contents</A></B> and the
<B><A HREF="_index.html" tppabs="http://ccs.ucsd.edu/c/_index.html">Index</A></B>.</P>

<P><I>
<A HREF="crit_pb.html" tppabs="http://ccs.ucsd.edu/c/crit_pb.html">Copyright</A> &#169; 1989-1996
by P.J. Plauger and Jim Brodie. All rights reserved.</I></P>

</BODY></HTML>
