<html>
<head>
<title>
C Guide--2.12 stdio.h
</title>
<!-- Changed by: eric huss, 12-Mar-1997 -->
</head>
<body text="#000000" bgcolor="#FFFFFF">

<center>
<table border=0 width=100%>
<tr>
<td align=left width=20% valign=top>
<a href="2.11.html">
<img src="left.gif" border=0>
Previous Section<br>
2.11 stddef.h</a></td>
<td align=center width=60% valign=top>
| <a href="index.html">Table of Contents</a> | 
<a href="index2.html">Index</a> |</td>
<td align=right width=20% valign=top>
<a href="2.13.html">
Next Section
<img src="right.gif" border=0><br>
2.13 stdlib.h</a></td>
</tr>
</table>
</center>
<hr>


<h1> 2.12 stdio.h</h1>
<p>
     The stdio header provides functions for performing input and output.
<p>
Macros:
<blockquote><b><code>
     NULL<br>
     _IOFBF<br>
     _IOLBF<br>
     _IONBF<br>
     BUFSIZ<br>
     EOF<br>
     FOPEN_MAX<br>
     FILENAME_MAX<br>
     L_tmpnam<br>
     SEEK_CUR<br>
     SEEK_END<br>
     SEEK_SET<br>
     TMP_MAX<br>
     stderr<br>
     stdin<br>
     stdout<br>
</code></b></blockquote>
<p>
Functions:
<blockquote><b><code>
     clearerr();<br>
     fclose();<br>
     feof();<br>
     ferror();<br>
     fflush();<br>
     fgetpos();<br>
     fopen();<br>
     fread();<br>
     freopen();<br>
     fseek();<br>
     fsetpos();<br>
     ftell();<br>
     fwrite();<br>
     remove();<br>
     rename();<br>
     rewind();<br>
     setbuf();<br>
     setvbuf();<br>
     tmpfile();<br>
     tmpnam();<br>
     fprintf();<br>
     fscanf();<br>
     printf();<br>
     scanf();<br>
     sprintf();<br>
     sscanf();<br>
     vfprintf();<br>
     vprintf();<br>
     vsprintf();<br>
     fgetc();<br>
     fgets();<br>
     fputc();<br>
     fputs();<br>
     getc();<br>
     getchar();<br>
     gets();<br>
     putc();<br>
     putchar();<br>
     puts();<br>
     ungetc(); <br>
     perror(); <br>
</code></b></blockquote>
Variables:
<blockquote><b><code>
     typedef size_t<br>
     typedef FILE<br>
     typedef fpos_t<br>
</code></b></blockquote>
<a name="variables"></a>
<h2>2.12.1    Variables and Definitions</h2>
<p>
<blockquote>
     <code><b>size_t</b></code> is the unsigned integer result of the sizeof keyword.<br>
     <code><b>FILE</b></code> is a type suitable for storing information for a file stream.<br>
     <code><b>fpos_t</b></code> is a type suitable for storing any position in a file.<br>
<br>
     <code><b>NULL</b></code> is the value of a null pointer constant.<br>
     <code><b>_IOFBF</b></code>, <code><b>_IOLBF</b></code>, and <code><b>_IONBF</b></code> are used in the setvbuf function.<br>
     <code><b>BUFSIZ</b></code> is an integer which represents the size of the buffer used by the setbuf function.<br>
     <code><b>EOF</b></code> is a negative integer which indicates an end-of-file has been reached.<br>
     <code><b>FOPEN_MAX</b></code> is an integer which represents the maximum number of files that the
system can guarantee that can be opened simultaneously.<br>
     <code><b>FILENAME_MAX</b></code> is an integer which represents the longest length of a char array
suitable for holding the longest possible filename.  If the implementation imposes no limit, then
this value should be the recommended maximum value.<br>
     <code><b>L_tmpnam</b></code> is an integer which represents the longest length of a char array suitable for
holding the longest possible temporary filename created by the tmpnam function. <br>
     <code><b>SEEK_CUR</b></code>, <code><b>SEEK_END</b></code>, and <code><b>SEEK_SET </b></code>are used in the fseek function.<br>
     <code><b>TMP_MAX</b></code> is the maximum number of unique filenames that the function tmpnam can
generate.<br>
     <code><b>stderr</b></code>, <code><b>stdin</b></code>, and <code><b>stdout</b></code> are pointers to <code><b>FILE</b></code> types which correspond to the standard
error, standard input, and standard output streams.<br>
</blockquote>
<a name="streams"></a>
<h2>2.12.2    Streams and Files</h2>
<p>
     Streams facilitate a way to create a level of abstraction between the program and an
input/output device.  This allows a common method of sending and receiving data amongst the
various types of devices available.  There are two types of streams: text and binary.
<p>
     Text streams are composed of lines.  Each line has zero or more characters and are
terminated by a new-line character which is the last character in a line.  Conversions may occur
on text streams during input and output.  Text streams consist of only printable characters, the
tab character, and the new-line character.  Spaces cannot appear before a newline character,
although it is implementation-defined whether or not reading a text stream removes these
spaces.  An implementation must support lines of up to at least 254 characters including the
new-line character.
<p>
     Binary streams input and output data in an exactly 1:1 ratio.  No conversion exists and all
characters may be transferred.
<p>
     When a program begins, there are already three available streams: standard input,
standard output, and standard error.
<p>
     Files are associated with streams and must be opened to be used.  The point of I/O within
a file is determined by the file position.  When a file is opened, the file position points to the
beginning of the file unless the file is opened for an append operation in which case the position
points to the end of the file.  The file position follows read and write operations to indicate
where the next operation will occur.
<p>
     When a file is closed, no more actions can be taken on it until it is opened again.  Exiting
from the main function causes all open files to be closed.

<h2> 2.12.3    File Functions</h2>
<a name="clearerr"></a>
<h2>2.12.3.1  clearerr</h2>
<p>
Declaration:
<blockquote><code><b>
     void clearerr(FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Clears the end-of-file and error indicators for the given stream.  As long as the error
indicator is set, all stream operations will return an error until <ocde><b>clearerr</b></code> or <code><b>rewind</b></code> is called.
<p>
<a name="fclose"></a>
<h2>2.12.3.2  fclose</h2>
<p>
Declaration:
<blockquote><code><b>
     int fclose(FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>
     Closes the stream.  All buffers are flushed.
<p>
     If successful, it returns zero.  On error it returns <code><b>EOF</b></code>.

<a name="feof"></a>
<h2>2.12.3.3  feof</h2>
<p>
Declaration:
<blockquote><code><b>
     int feof(FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Tests the end-of-file indicator for the given stream.  If the stream is at the end-of-file,
then it returns a nonzero value.  If it is not at the end of the file, then it returns zero.

<a name="ferror"></a>
<h2>2.12.3.4  ferror</h2>
<p>
Declaration:
<blockquote><code><b>
     int ferror(FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Tests the error indicator for the given stream.  If the error indicator is set, then it returns a
nonzero value.  If the error indicator is not set, then it returns zero.

<a name="fflush"></a>
<h2>2.12.3.5  fflush</h2>
<p>
Declaration:
<blockquote><code><b>
     int fflush(FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Flushes the output buffer of a stream.  If stream is a null pointer, then all output buffers
are flushed.
<p>
     If successful, it returns zero.  On error it returns <code><b>EOF</b></code>.

<a name="fgetpos"></a>
<h2>2.12.3.6  fgetpos</h2>
<p>
Declaration:
<blockquote><code><b>
     int fgetpos(FILE *</b></code><i>stream</i><b><code>, fpos_t *</b></code><i>pos</i><b><code>);
</b></code></blockquote>

     Gets the current file position of the stream and writes it to <i>pos</i>.
<p>
     If successful, it returns zero.  On error it returns a nonzero value and stores the error
number in the variable <code><b>errno</b></code>.

<a name="fopen"></a>
<h2>2.12.3.7  fopen</h2>
<p>
Declaration:
<blockquote><code><b>
     FILE *fopen(const char *</b></code><i>filename</i><b><code>, const char *</b></code><i>mode</i><b><code>);
</b></code></blockquote>
<p>
     Opens the filename pointed to by filename.  The mode argument may be one of the
following constant strings:
<table border=0>
<tr><td><code><b>r</b></code></td><td>         read text mode</td></tr>
<tr><td><code><b>w</b></code></td><td>         write text mode (truncates file to zero length or creates new file)</td></tr>
<tr><td><code><b>a </b></code></td><td>        append text mode for writing (opens or creates file and sets file pointer to the
end-of-file)</td></tr>
<tr><td><code><b>rb</b></code></td><td>        read binary mode</td></tr>
<tr><td><code><b>wb </b></code></td><td>       write binary mode (truncates file to zero length or creates new file)</td></tr>
<tr><td><code><b>ab </b></code></td><td>       append binary mode for writing (opens or creates file and sets file pointer to the
end-of-file)</td></tr>
<tr><td><code><b>r+</b></code></td><td>        read and write text mode</td></tr>
<tr><td><code><b>w+</b></code></td><td>        read and write text mode (truncates file to zero length or creates new file)</td></tr>
<tr><td><code><b>a+ </b></code></td><td>       read and write text mode (opens or creates file and sets file pointer to the
end-of-file)</td></tr>
<tr><td><code><b>r+b</b></code> or<code><b> rb+</b></code></td><td>     read and write binary mode</td></tr>
<tr><td><code><b>w+b</b></code> or<code><b> wb+</b></code></td><td>     read and write binary mode (truncates file to zero length or creates new file)</td></tr>
<tr><td><code><b>a+b</b></code> or<code><b> ab+</b></code></td><td>     read and write binary mode (opens or creates file and sets file pointer to the
end-of-file)</td></tr>
</table>
<p>
     If the file does not exist and it is opened with read mode (<code><b>r</b></code>), then the open fails.
<p>
     If the file is opened with append mode (<code><b>a</b></code>), then all write operations occur at the end of
the file regardless of the current file position.
<p>
     If the file is opened in the update mode (<code><b>+</b></code>), then output cannot be directly followed by
input and input cannot be directly followed by output without an intervening fseek, fsetpos,
rewind, or fflush.
<p>
     On success a pointer to the file stream is returned.  On failure a null pointer is returned.

<a name="fread"></a>
<h2>2.12.3.8  fread</h2>
<p>
Declaration:
<blockquote><code><b>
     size_t fread(void *</b></code><i>ptr</i><b><code>, size_t </b></code><i>size</i><b><code>, size_t</b></code><i> nmemb</i><b><code>, FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Reads data from the given stream into the array pointed to by <i>ptr</i>.  It reads <i>nmemb</i>
number of elements of size <i>size</i>.  The total number of bytes read is (<code><b>size*nmemb</b></code>).
<p>
     On success the number of elements read is returned.  On error or end-of-file the total
number of elements successfully read (which may be zero) is returned.

<a name="freopen"></a>
<h2>2.12.3.9  freopen</h2>
<p>
Declaration:
<blockquote><code><b>
     FILE *freopen(const char *</b></code><i>filename</i><b><code>, const char *</b></code><i>mode</i><b><code>, FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Associates a new filename with the given open stream.  The old file in stream is closed. 
If an error occurs while closing the file, the error is ignored.  The mode argument is the same as
described in the fopen command.  Normally used for reassociating stdin, stdout, or stderr.
<p>
     On success the pointer to the stream is returned.  On error a null pointer is returned.

<a name="fseek"></a>
<h2>2.12.3.10 fseek</h2>
<p>
Declaration:
<blockquote><code><b>
     int fseek(FILE *</b></code><i>stream</i><b><code>, long int </b></code><i>offset</i><b><code>, int</b></code><i> whence</i><b><code>);
</b></code></blockquote>

     Sets the file position of the stream to the given offset.  The argument <i>offset</i> signifies the
number of bytes to seek from the given whence position.  The argument <i>whence</i> can be:
<table border=0>
<tr><td><code><b>SEEK_SET</b></code></td><td>  Seeks from the beginning of the file.</td></tr>
<tr><td><code><b>SEEK_CUR</b></code></td><td>  Seeks from the current position.</td></tr>
<tr><td><code><b>SEEK_END</b></code></td><td>  Seeks from the end of the file.</td></tr>
</table>
<p>
     On a text stream, whence should be <code><b>SEEK_SET</b></code> and <i>offset</i> should be either zero or a
value returned from <code><b>ftell</b></code>.
<p>
     The end-of-file indicator is reset.  The error indicator is NOT reset.
<p>
     On success zero is returned.  On error a nonzero value is returned.

<a name="fsetpos"></a>
<h2>2.12.3.11 fsetpos</h2>
<p>
Declaration:
<blockquote><code><b>
     int fsetpos(FILE *</b></code><i>stream</i><b><code>, const fpos_t *</b></code><i>pos</i><b><code>);
</b></code></blockquote>

     Sets the file position of the given stream to the given position.  The argument <i>pos</i> is a
position given by the function <code><b>fgetpos</b></code>.  The end-of-file indicator is cleared.
<p>
     On success zero is returned.  On error a nonzero value is returned and the variable <code><b>errno</b></code>
is set.

<a name="ftell"></a>
<h2>2.12.3.12 ftell</h2>
<p>
Declaration:
<blockquote><code><b>
     long int ftell(FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Returns the current file position of the given stream.  If it is a binary stream, then the
value is the number of bytes from the beginning of the file.  If it is a text stream, then the value
is a value useable by the fseek function to return the file position to the current position.
<p>
     On success the current file position is returned.  On error a value of <code><b>-1L</b></code> is returned and
<code><b>errno</b></code> is set.

<a name="fwrite"></a>
<h2>2.12.3.13 fwrite</h2>
<p>
Declaration:
<blockquote><code><b>
     size_t fwrite(const void *</b></code><i>ptr</i><b><code>, size_t</b></code><i> size</i><b><code>, size_t</b></code><i> nmemb</i><b><code>, FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Writes data from the array pointed to by <i>ptr</i> to the given stream.  It writes <i>nmemb</i>
number of elements of size <i>size</i>.  The total number of bytes written is (<code><b>size*nmemb</b></code>).
<p>
     On success the number of elements writen is returned.  On error the total number of
elements successfully writen (which may be zero) is returned.

<a name="remove"></a>
<h2>2.12.3.14 remove</h2>
<p>
Declaration:
<blockquote><code><b>
     int remove(const char *</b></code><i>filename</i><b><code>);
</b></code></blockquote>

     Deletes the given filename so that it is no longer accessible (unlinks the file).  If the file
is currently open, then the result is implementation-defined.
<p>
     On success zero is returned.  On failure a nonzero value is returned.

<a name="rename"></a>
<h2>2.12.3.15 rename</h2>
<p>
Declaration:
<blockquote><code><b>
     int rename(const char *</b></code><i>old_filename</i><b><code>, const char *</b></code><i>new_filename</i><b><code>);
</b></code></blockquote>

     Causes the filename referred to by <i>old_filename</i> to be changed to <i>new_filename</i>.  If the
filename pointed to by <i>new_filename</i> exists, the result is implementation-defined.
<p>
     On success zero is returned.  On error a nonzero value is returned and the file is still
accessible by its old filename.

<a name="rewind"></a>
<h2>2.12.3.16 rewind</h2>
<p>
Declaration:
<blockquote><code><b>
     void rewind(FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Sets the file position to the beginning of the file of the given stream.  The error and
end-of-file indicators are reset.

<a name="setbuf"></a>
<h2>2.12.3.17 setbuf</h2>
<p>
Declaration:
<blockquote><code><b>
     void setbuf(FILE *</b></code><i>stream</i><b><code>, char *</b></code><i>buffer</i><b><code>);
</b></code></blockquote>

     Defines how a stream should be buffered.  This should be called after the stream has
been opened but before any operation has been done on the stream.  Input and output is fully
buffered.  The default <b><code>BUFSIZ</code></b> is the size of the buffer.  The argument <i>buffer</i> points to an array
to be used as the buffer.  If <i>buffer</i> is a null pointer, then the stream is unbuffered.

<a name="setvbuf"></a>
<h2>2.12.3.18 setvbuf</h2>
<p>
Declaration:
<blockquote><code><b>
     int setvbuf(FILE *</b></code><i>stream</i><b><code>, char *</b></code><i>buffer</i><b><code>, int</b></code><i> mode</i><b><code>, size_t </b></code><i>size</i><b><code>);
</b></code></blockquote>

     Defines how a stream should be buffered.  This should be called after the stream has
been opened but before any operation has been done on the stream.  The argument <i>mode</i> defines
how the stream should be buffered as follows:
<table border=0>
<tr><td valign=top><code><b>_IOFBF</b></code></td><td>    Input and output is fully buffered.
          If the buffer is empty, an input operation attempts to fill the buffer.
          On output the buffer will be completely filled before any information is written to
the file (or the         stream is closed). </td></tr>
<tr><td valign=top><code><b>_IOLBF</b></code></td><td>    Input and output is line buffered.
          If the buffer is empty, an input operation attempts to fill the buffer.
          On output the buffer will be flushed whenever a newline character is written.</td></tr>
<tr><td valign=top><code><b>_IONBF</b></code></td><td>    Input and output is not buffered.
          No buffering is performed.</td></tr>
</table>
<p>
     The argument <i>buffer</i> points to an array to be used as the buffer.  If <i>buffer</i> is a null
pointer, then <code><b>setvbuf</b></code> uses <code><b>malloc</b></code> to create its own buffer.
<p>
     The argument <i>size</i> determines the size of the array.
<p>
     On success zero is returned.  On error a nonzero value is returned.

<a name="tmpfile"></a>
<h2>2.12.3.19 tmpfile</h2>
<p>
Declaration:
<blockquote><code><b>
     FILE *tmpfile(void);
</b></code></blockquote>

     Creates a temporary file in binary update mode (wb+).  The tempfile is removed when
the program terminates or the stream is closed.
<p>
     On success a pointer to a file stream is returned.  On error a null pointer is returned.

<a name="tmpnam"></a>
<h2>2.12.3.20 tmpnam</h2>
<p>
Declaration:
<blockquote><code><b>
     char *tmpnam(char *</b></code><i>str</i><b><code>);
</b></code></blockquote>

     Generates and returns a valid temporary filename which does not exist.  Up to
<code><b>TMP_MAX</b></code> different filenames can be generated.
<p>
     If the argument <i>str</i> is a null pointer, then the function returns a pointer to a valid
filename.  If the argument <i>str</i> is a valid pointer to an array, then the filename is written to the
array and a pointer to the same array is returned.  The filename may be up to <code><b>L_tmpnam</b></code>
characters long.
<h2> 2.12.4    Formatted I/O Functions</h2>
<a name="fprintf"></a>
<a name="printf"></a>
<a name="sprintf"></a>
<a name="vfprintf"></a>
<a name="vprintf"></a>
<a name="vsprintf"></a>
<h2>2.12.4.1  ..printf Functions</h2>
<p>
Declarations:
<blockquote><code><b>
     int fprintf(FILE *</b></code><i>stream</i><b><code>, const char *</b></code><i>format</i><b><code>, ...);<br>
     int printf(const char *</b></code><i>format</i><b><code>, ...);<br>
     int sprintf(char *</b></code><i>st</i><b><code>r, const char *</b></code><i>format</i><b><code>, ...);<br>
     int vfprintf(FILE *</b></code><i>stream</i><b><code>, const char *</b></code><i>format</i><b><code>, va_list </b></code><i>arg</i><b><code>);<br>
     int vprintf(const char *</b></code><i>format</i><b><code>, va_list</b></code><i> arg</i><b><code>);<br>
     int vsprintf(char *</b></code><i>str</i><b><code>, const char *</b></code><i>format</i><b><code>, va_list</b></code><i> arg</i><b><code>);<br>
</b></code></blockquote>
<p>
     The ..printf functions provide a means to output formatted information to a stream.
<p>
<table border=0>
<tr><td><code><b>fprintf</b></code></td><td>   sends formatted output to a stream</td></tr>
<tr><td><code><b>printf</b></code></td><td>    sends formatted output to stdout</td></tr>
<tr><td><code><b>sprintf</b></code></td><td>   sends formatted output to a string</td></tr>
<tr><td><code><b>vfprintf</b></code></td><td>  sends formatted output to a stream using an argument list</td></tr>
<tr><td><code><b>vprintf</b></code></td><td>   sends formatted output to stdout using an argument list</td></tr>
<tr><td><code><b>vsprintf </b></code></td><td> sends formatted output to a string using an argument list</td></tr>
</table>
<p>
     These functions take the format string specified by the <i>format</i> argument and apply each
following argument to the format specifiers in the string in a left to right fashion.  Each character
in the format string is copied to the stream except for conversion characters which specify a
format specifier.
<p>
     The string commands (<code><b>sprintf</b></code> and <code><b>vsprintf</b></code>) append a null character to the end of the
string.  This null character is not counted in the character count.
<p>
     The argument list commands (<code><b>vfprintf</b></code>, <code><b>vprintf</b></code>, and <code><b>vsprintf</b></code>) use an argument list which
is prepared by <code><b>va_start</b></code>.  These commands do not call <code><b>va_end</b></code> (the caller must call it).
<p>
     A conversion specifier begins with the <code><b>%</b></code> character.  After the <code><b>%</b></code> character come the
following in this order:
<table border=0>
<tr><td>[<b>flags</b>]</td><td>        Control the conversion (optional).</td></tr>
<tr><td>[<b>width</b>]</td><td>        Defines the number of characters to print (optional).</td></tr>
<tr><td>[<b>.precision</b>]</td><td>   Defines the amount of precision to print for a number type (optional).</td></tr>
<tr><td>[<b>modifier</b>]</td><td>     Overrides the size (type) of the argument (optional).</td></tr>
<tr><td>[<b>type</b>]</td><td>         The type of conversion to be applied (required).</td></tr>
</table>
<p>
<b>Flags</b>:<br>
<table border=0>
<tr><td valign=top><code><b>-</b></code></td><td>    Value is left justified (default is right justified).  Overrides the 0 flag.</td></tr>
<tr><td valign=top><code><b>+</b></code></td><td>    Forces the sign (+ or -) to always be shown.  Default is to just show the - sign.  Overrides
the space flag.</td></tr>
<tr><td valign=top><code><b>space</b></code></td><td>     Causes a positive value to display a space for the sign.  Negative values still show the -
sign.</td></tr>
<tr><td valign=top><code><b>#</b></code></td><td>    Alternate form:
<table border=0>
<tr><th>     Conversion Character</th><th>     Result</th><tr>
<tr><td><code><b>     o</b></code></td><td>              Precision is increased to make the first digit a zero.</td></tr>
<tr><td><code><b>     X or x </b></code></td><td>             Nonzero value will have 0x or 0X prefixed to it.</td></tr>
<tr><td><code><b>     E, e, f, g, or G  </b></code></td><td>       Result will always have a decimal point.</td></tr>
<tr><td><code><b>     G or g </b></code></td><td>             Trailing zeros will not be removed.</td></tr>
</table>
</td></tr>
<tr><td valign=top><code><b>0 </b></code></td><td>   For d, i, o, u, x, X, e, E, f, g, and G leading zeros are used to pad the field width instead
of spaces.     This is useful only with a width specifier.  Precision overrides this flag.</td></tr>
</table>
<p>
<b>Width</b>:<br>
     The width of the field is specified here with a decimal value.  If the value is not large
enough to fill the width, then the rest of the field is padded with spaces (unless the 0 flag is
specified).  If the value overflows the width of the field, then the field is expanded to fit the
value.  If a <code><b>*</b></code> is used in place of the width specifer, then the next argument (which must be an <code><b>int</b></code>
type) specifies the width of the field.  Note: when using the <code><b>*</b></code> with the width and/or precision
specifier, the width argument comes first, then the precision argument, then the value to be
converted.
<p>
<b>Precision</b>:<br>
     The precision begins with a dot (.) to distinguish itself from the width specifier.  The
precision can be given as a decimal value or as an asterisk (<code><b>*</b></code>).  If a <code><b>*</b></code> is used, then the next
argument (which is an <code><b>int</b></code> type) specifies the precision.  Note: when using the <code><b>*</b></code> with the width
and/or precision specifier, the width argument comes first, then the precision argument, then the
value to be converted.  Precision does not affect the c type.
<table border=0>
<tr><th>[.precision]</th><th>   Result</th></tr>
<tr><td valign=top>(<i>none</i>)</td><td>         Default precision values:<br>
          1 for <code><b>d</b></code>, <code><b>i</b></code>, <code><b>o</b></code>, <code><b>u</b></code>, <code><b>x</b></code>, <code><b>X</b></code> types.  The minimum number of digits to appear.<br>
          6 for <code><b>f</b></code>, <code><b>e</b></code>, <code><b>E</b></code> types.  Specifies the number of digits after the decimal point.<br>
          For <code><b>g</b></code> or <code><b>G</b></code> types all significant digits are shown.<br>
          For <code><b>s</b></code> type all characters in string are print up to but not including the null
character.</td></tr>

<tr><td valign=top><code><b>.</b></code> <i>or</i> <code><b>.0</b></code></td><td>        For <code><b>d</b></code>, <code><b>i</b></code>, <code><b>o</b></code>, <code><b>u</b></code>, <code><b>x</b></code>, <code><b>X</b></code> types the default precis








ion value is used unless the value is zero
in which case no         characters are printed.<br>
          For <code><b>f</b></code>, <code><b>e</b></code>, <code><b>E</b></code> types no decimal point character or digits are printed.<br>
          For <code><b>g</b></code> or <code><b>G</b></code> types the precision is assumed to be 1.<br>
</td></tr>
<tr><td valign=top><code><b>.</b></code><i>n</i> </td><td>       For <code><b>d</b></code>, <code><b>i</b></code>, <code><b>o</b></code>, <code><b>u</b></code>, <code><b>x</b></code>, <code><b>X</b></code> types then at least n digits are printed (padding








 with zeros if
necessary).<br>
          For <code><b>f</b></code>, <code><b>e</b></code>, <code><b>E</b></code> types specifies the number of digits after the decimal point.<br>
          For <code><b>g</b></code> or <code><b>G</b></code> types specifies the number of significant digits to print.<br>
          For<code><b> s</b></code> type specifies the maximum number of characters to print.<br>
</td></tr>
</table>
<p>
<b>Modifier</b>:<br>
     A modifier changes the way a conversion specifier type is interpreted.
<table broder=0>
<tr><td><b>[modifier]</b></td><td><b>     [type]</b></td><td>         <b>Effect</b></td></tr>
<tr><td><code><b>h</b></code></td><td>         <code><b>d</b></code>, <code><b>i</b></code>, <code><b>o</b></code>, <code><b>u</b></code>, <code><b>x</b></code>, <code><b>X</b></code></td><td>    Value is first converted to a short int or unsigned short i








nt.</td></tr>
<tr><td><code><b>h</b></code></td><td>         <code><b>n</b></code> </td><td>        Specifies that the pointer points to a short int.</td></tr>
<tr><td><code><b>l</b></code></td><td>         <code><b>d</b></code>, <code><b>i</b></code>, <code><b>o</b></code>, <code><b>u</b></code>, <code><b>x</b></code>, <code><b>X</b></code> </td><td>   Value is first converted to a long int or unsigned long int








.</td></tr>
<tr><td><code><b>l</b></code></td><td>         <code><b>n</b></code></td><td>         Specifies that the pointer points to a long int.</td></tr>
<tr><td><code><b>L</b></code></td><td>         <code><b>e</b></code>, <code><b>E</b></code>, <code><b>f</b></code>, <code><b>g</b></code>, <code><b>G</b></code></td><td>  Value is first converted to a long double.</td></tr>
</table>
<p>
<b>Conversion specifier type</b>:<br>
     The conversion specifier specifies what type the argument is to be treated as.
<table border=0>
<tr><th>[type] </th><th>        Output</th></tr>
<tr><td valign=top><code><b>d</b></code>, <code><b>i</b></code></td><td>      Type <code><b>signed int</b></code>.</td></tr>
<tr><td valign=top><code><b>o</b></code></td><td>         Type <code><b>unsigned int</b></code> printed in octal.</td></tr>
<tr><td valign=top><code><b>u</b></code> </td><td>        Type <code><b>unsigned int</b></code> printed in decimal.</td></tr>
<tr><td valign=top><code><b>x</b></code> </td><td>        Type <code><b>unsigned int</b></code> printed in hexadecimal as dddd using a, b, c, d, e, f.</td></tr>
<tr><td valign=top><code><b>X</b></code> </td><td>        Type <code><b>unsigned int</b></code> printed in hexadecimal as dddd using A, B, C, D, E, F.</td></tr>
<tr><td valign=top><code><b>f</b></code> </td><td>        Type <code><b>double</b></code> printed as [-]ddd.ddd.</td></tr>
<tr><td valign=top><code><b>e</b></code>, <code><b>E</b></code> </td><td>     Type <code><b>double</b></code> printed as [-]d.dddeñdd where there is one digit printed before the
decimal (zero       only if the value is zero).  The exponent contains at least two
digits.  If type is E then the exponent is        printed with a capital E.</td></tr>
<tr><td valign=top><code><b>g</b></code>, <code><b>G</b></code> </td><td>     Type <code><b>double</b></code> printed as type e or E if the exponent is less than -4 or greater than
or equal to the          precision.  Otherwise printed as type f.  Trailing zeros are
removed.  Decimal point character       appears only if there is a nonzero decimal digit.</td></tr>
<tr><td valign=top><code><b>c</b></code></td><td>         Type <code><b>char</b></code>.  Single character is printed.</td></tr>
<tr><td valign=top><code><b>s</b></code></td><td>         Type pointer to array.  String is printed according to precision (no precision prints
entire string).</td></tr>
<tr><td valign=top><code><b>p</b></code> </td><td>        Prints the value of a pointer (the memory location it holds).</td></tr>
<tr><td valign=top><code><b>n</b></code> </td><td>        The argument must be a pointer to an <code><b>int</b></code>.  Stores the number of characters printed
thus far in the          int.  No characters are printed.</td></tr>
<tr><td valign=top><code><b>%</b></code> </td><td>        A <code><b>%</b></code> sign is printed.</td></tr>
</table>
<p>
     The number of characters printed are returned.  If an error occurred, -1 is returned.

<a name="fscanf"></a>
<a name="scanf"></a>
<a name="sscanf"></a>
<h2>2.12.4.2  ..scanf Functions</h2>
<p>
Declarations:
<blockquote><code><b>
     int fscanf(FILE *</b></code><i>stream</i><b><code>, const char *</b></code><i>format</i><b><code>, ...);<br>
     int scanf(const char *</b></code><i>format</i><b><code>, ...);<br>
     int sscanf(const char *</b></code><i>str</i><b><code>, const char *</b></code><i>format</i><b><code>, ...);<br>
</b></code></blockquote>
<p>
     The ..scanf functions provide a means to input formatted information from a stream.
<table border=0>
<tr><td><code><b>fscanf</b></code></td><td>    reads formatted input from a stream</td></tr>
<tr><td><code><b>scanf</b></code></td><td>          reads formatted input from stdin</td></tr>
<tr><td><code><b>sscanf</b></code></td><td>    reads formatted input from a string</td></tr>
</table>
<p>
     These functions take input in a manner that is specified by the format argument and store
each input field into the following arguments in a left to right fashion.
<p>
     Each input field is specified in the format string with a conversion specifier which
specifies how the input is to be stored in the appropriate variable.  Other characters in the format
string specify characters that must be matched from the input, but are not stored in any of the
following arguments.  If the input does not match then the function stops scanning and returns. 
A whitespace character may match with any whitespace character (space, tab, carriage return,
new line, vertical tab, or formfeed) or the next incompatible character.
<p>
     An input field is specified with a conversion specifer which begins with the <code><b>%</b></code> character. 
After the <code><b>%</b></code> character come the following in this order:
<table border=0>
<tr><td><b>[*]</b></td><td>       Assignment suppressor (optional).</td></tr>
<tr><td><b>[width]</b></td><td>        Defines the maximum number of characters to read (optional).</td></tr>
<tr><td><b>[modifier]</b></td><td>     Overrides the size (type) of the argument (optional).</td></tr>
<tr><td><b>[type] </b></td><td>        The type of conversion to be applied (required).</td></tr>
</table>
<p>
<b>Assignment suppressor:</b><br>
     Causes the input field to be scanned but not stored in a variable.
<p>
<b>Width:</b><br>
     The maximum width of the field is specified here with a decimal value.  If the input is
smaller than the width specifier (i.e. it reaches a nonconvertible character), then what was read
thus far is converted and stored in the variable.
<p>
<b>Modifier:</b><br>
     A modifier changes the way a conversion specifier type is interpreted.
<table border=0>
<tr><td><b>[modifier]</b></td><td><b>     [type]</b></td><td><b>         Effect</b><td></tr>
<tr><td><b><code>h</code></b></td><td>  <b><code>d</code></b>, <b><code>i</code></b>, <b><code>o</code></b>, <b><code>u</code></b>, <b><code>x</code></b> </td><td> The argument is a <b><code>short int</code></b> or <b><code>unsigned short int</code></b>.<








/td></tr>
<tr><td><b><code>h</code></b></td><td>         <b><code>n</code></b>      </td><td>    Specifies that the pointer points to a <b><code>short int</code></b>.</td></tr>
<tr><td><b><code>l</code></b></td><td>         <b><code>d</code></b>, <b><code>i</code></b>, <b><code>o</code></b>, <b><code>u</code></b>, <b><code>x</code></b>  </td><td> The argument is a <b><code>long int</code></b> or <b><code>unsigned long int</code>








</b>.</td></tr>
<tr><td><b><code>l</code></b></td><td>         <b><code>n</code></b>     </td><td>     Specifies that the pointer points to a <b><code>long int</code></b>.</td></tr>
<tr><td><b><code>l</code></b></td><td>         <b><code>e</code></b>, <b><code>f</code></b>, <b><code>g</code></b>   </td><td>      The argument is a <b><code>double</code></b>.</td></tr>
<tr><td><b><code>L</code></b></td><td>         <b><code>e</code></b>, <b><code>f</code></b>, <b><code>g</code></b>   </td><td>      The argument is a <b><code>long double</code></b>.</td></tr>
</table>
<p>
<b>Conversion specifier type:</b><br>
     The conversion specifier specifies what type the argument is.  It also controls what a
valid convertible character is (what kind of characters it can read so it can convert to something
compatible).
<table border=0>
<tr><td><b>[type]</b></td><td><b>         Input</b></td></tr>
<tr><td valign=top><code><b>d</b></code></td><td>         Type <code><b>signed int</b></code> represented in base 10.  Digits 0 through 9 and the sign (+ or -).</td></tr>
<tr><td valign=top><code><b>i</b></code></td><td>         Type <code><b>signed int</b></code>.  The base (radix) is dependent on the first two characters.  If the
first character          is a digit from 1 to 9, then it is base 10.  If the first digit is a zero
and the second digit is a digit from         1 to 7, then it is base 8 (octal).  If the first digit is a
zero and the second character is an x or X, then it         is base 16 (hexadecimal).</td></tr>
<tr><td valign=top><code><b>o</b></code></td><td>         Type <code><b>unsigned int</b></code>.  The input must be in base 8 (octal).  Digits 0 through 7 only.</td></tr>
<tr><td valign=top><code><b>u</b></code></td><td>         Type <code><b>unsigned int</b></code>.  The input must be in base 10 (decimal).  Digits 0 through 9
only.</td></tr>
<tr><td valign=top><code><b>x, X</b></code></td><td>      Type <code><b>unsigned int</b></code>.  The input must be in base 16 (hexadecimal).  Digits 0 through 9 or A  through Z or a through z.  The characters 0x or 0X may be optionally
prefixed to the value.</td></tr>
<tr><td valign=top><code><b>e</b></code>, <code><b>E</b></code>, <code><b>f</b></code>, <code><b>g</b></code>,<code><b> G</b></code></b></code></td><td>  Type <code><b>float</b></code>.  Begins with an optional sign.  Then one or more digits, followed by
an optional         decimal-point and decimal value.  Finally ended with an optional signed
exponent value designated          with an e or E.</td></tr>
<tr><td valign=top><code><b>s</b></code></td><td>         Type character array.  Inputs a sequence of non-whitespace characters (space, tab,
carriage return,         new line, vertical tab, or formfeed).  The array must be large
enough to hold the sequence plus a null           character appended to the end.</td></tr>
<tr><td valign=top><code><b>[...]</b></code></td><td>          Type character array.  Allows a search set of characters.  Allows input of only
those character          encapsulated in the brackets (the scanset).  If the first character is a
carrot (^), then the scanset is         inverted and allows any ASCII character except
those specified between the brackets.  On some         systems a range can be specified
with the dash character (-).  By specifying the beginning character,       a dash, and an
ending character a range of characters can be included in the scanset.  A null character       is appended to the end of the array.</td></tr>
<tr><td valign=top><code><b>c</b></code></td><td>         Type character array.  Inputs the number of characters specified in the width
field.  If no width field          is specified, then 1 is assumed.  No null character is
appended to the array.</td></tr>
<tr><td valign=top><code><b>p</b></code></td><td>         Pointer to a pointer.  Inputs a memory address in the same fashion of the <code><b>%p</b></code> type
produced by the          printf function.</td></tr>
<tr><td valign=top><code><b>n </b></code></td><td>        The argument must be a pointer to an <code><b>int</b></code>. Stores the number of characters read
thus far in the <code><b>int</b></code>.          No characters are read from the input stream.</td></tr>
<tr><td valign=top><code><b>% </b></code></td><td>        Requires a matching <code><b>%</b></code> sign from the input.</td></tr>
</table>
<p>
     Reading an input field (designated with a conversion specifier) ends when an
incompatible character is met, or the width field is satisfied.
<p>
     On success the number of input fields converted and stored are returned.  If an input
failure occurred, then EOF is returned.
<h2> 2.12.5    Character I/O Functions</h2>
<a name="fgetc"></a>
<h2>2.12.5.1  fgetc</h2>
<p>
Declaration:
<blockquote><code><b>
     int fgetc(FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Gets the next character (an <code><b>unsigned char</b></code>) from the specified stream and advances the
position indicator for the stream.
<p>
     On success the character is returned.  If the end-of-file is encountered, then <code><b>EOF</b></code> is
returned and the end-of-file indicator is set.  If an error occurs then the error indicator for the
stream is set and <code><b>EOF</b></code> is returned.

<a name="fgets"></a>
<h2>2.12.5.2  fgets</h2>
<p>
Declaration:
<blockquote><code><b>
     char *fgets(char *</b></code><i>str</i><b><code>, int </b></code><i>n</i><b><code>, FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Reads a line from the specified stream and stores it into the string pointed to by <i>str</i>.  It
stops when either (n-1) characters are read, the newline character is read, or the end-of-file is
reached, whichever comes first.  The newline character is copied to the string.  A null character
is appended to the end of the string.
<p>
     On success a pointer to the string is returned.  On error a null pointer is returned.  If the
end-of-file occurs before any characters have been read, the string remains unchanged.

<a name="fputc"></a>
<h2>2.12.5.3  fputc</h2>
<p>
Declaration:
<blockquote><code><b>
     int fputc(int</b></code><i> char</i><b><code>, FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Writes a character (an <code><b>unsigned char</b></code>) specified by the argument <i>char</i> to the specified
stream and advances the position indicator for the stream.
<p>
     On success the character is returned.  If an error occurs, the error indicator for the stream
is set and <code><b>EOF</b></code> is returned.

<a name="fputs"></a>
<h2>2.12.5.4  fputs</h2>
<p>
Declaration:
<blockquote><code><b>
     int fputs(const char *</b></code><i>str</i><b><code>, FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Writes a string to the specified stream up to but not including the null character.
<p>
     On success a nonnegative value is returned.  On error <code><b>EOF</b></code> is returned.

<a name="getc"></a>
<h2>2.12.5.5  getc</h2>
<p>
Declaration:
<blockquote><code><b>
     int getc(FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Gets the next character (an <code><b>unsigned char</b></code>) from the specified stream and advances the
position indicator for the stream.
<p>
     This may be a macro version of <code><b>fgetc</b></code>.
<p>
     On success the character is returned.  If the end-of-file is encountered, then <code><b>EOF</b></code> is
returned and the end-of-file indicator is set.  If an error occurs then the error indicator for the
stream is set and <code><b>EOF</b></code> is returned.

<a name="getchar"></a>
<h2>2.12.5.6  getchar</h2>
<p>
Declaration:
<blockquote><code><b>
     int getchar(void);
</b></code></blockquote>


     Gets a character (an <code><b>unsigned char</b></code>) from <code><b>stdin</b></code>.
<p>
     On success the character is returned.  If the end-of-file is encountered, then <code><b>EOF</b></code> is
returned and the end-of-file indicator is set.  If an error occurs then the error indicator for the
stream is set and <code><b>EOF</b></code> is returned.

<a name="gets"></a>
<h2>2.12.5.7  gets</h2>
<p>
Declaration:
<blockquote><code><b>
     char *gets(char *</b></code><i>str</i><b><code>);
</b></code></blockquote>

     Reads a line from <code><b>stdin</b></code> and stores it into the string pointed to by <i>str</i>.  It stops when either
the newline character is read or when the end-of-file is reached, whichever comes first.  The
newline character is not copied to the string. A null character is appended to the end of the
string.
<p>
     On success a pointer to the string is returned.  On error a null pointer is returned.  If the
end-of-file occurs before any characters have been read, the string remains unchanged.

<a name="putc"></a>
<h2>2.12.5.8  putc</h2>
<p>
Declaration:
<blockquote><code><b>
     int putc(int</b></code><i> char</i><b><code>, FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Writes a character (an<code><b> unsigned char</b></code>) specified by the argument <i>char</i> to the specified
stream and advances the position indicator for the stream.
<p>
     This may be a macro version of<code><b> fputc</b></code>.
<p>
     On success the character is returned.  If an error occurs, the error indicator for the stream
is set and<code><b> EOF</b></code> is returned.

<a name="putchar"></a>
<h2>2.12.5.9  putchar</h2>
<p>
Declaration:
<blockquote><code><b>
     int putchar(int</b></code><i> char</i><b><code>);
</b></code></blockquote>

     Writes a character (an <code><b>unsigned char</b></code>) specified by the argument <i>char</i> to <code><b>stdout</b></code>.
<p>
     On success the character is returned.  If an error occurs, the error indicator for the stream
is set and <code><b>EOF</b></code> is returned.

<a name="puts"></a>
<h2>2.12.5.10 puts</h2>
<p>
Declaration:
<blockquote><code><b>
     int puts(const char *</b></code><i>str</i><b><code>);
</b></code></blockquote>

     Writes a string to <code><b>stdout</b></code> up to but not including the null character.  A newline character
is appended to the output.
<p>
     On success a nonnegative value is returned.  On error <code><b>EOF</b></code> is returned.

<a name="ungetc"></a>
<h2>2.12.5.11 ungetc</h2>
<p>
Declaration:
<blockquote><code><b>
     int ungetc(int </b></code><i>char</i><b><code>, FILE *</b></code><i>stream</i><b><code>);
</b></code></blockquote>

     Pushes the character <i>char</i> (an <code><b>unsigned char</b></code>) onto the specified stream so that the this is
the next character read.  The functions <code><b>fseek</b></code>, <code><b>fsetpos</b></code>, and <code><b>rewind</b></code> discard any characters pushed
onto the stream.
<p>
     Multiple characters pushed onto the stream are read in a FIFO manner (first in, first out).
<p>
     On success the character pushed is returned.  On error <code><b>EOF</b></code> is returned.
<h2> 2.12.7         Error Functions</h2>
<a name="perror"></a>
<h2>2.12.7.1  perror</h2>
<p>
Declaration:
<blockquote><code><b>
     void perror(const char *</b></code><i>str</i><b><code>);

</b></code></blockquote>
     Prints a descriptive error message to stderr.  First the string <i>str</i> is printed followed by a
colon then a space.  Then an error message based on the current setting of the variable <code><b>errno</b></code> is
printed.
<hr>
<center>
<table border=0 width=100%>
<tr>
<td align=left width=20% valign=top>
<a href="2.11.html">
<img src="left.gif" border=0>
Previous Section<br>
2.11 stddef.h</a></td>
<td align=center width=60% valign=top>
| <a href="index.html">Table of Contents</a> | 
<a href="index2.html">Index</a> |</td>
<td align=right width=20% valign=top>
<a href="2.13.html">
Next Section
<img src="right.gif" border=0><br>
2.13 stdlib.h</a></td>
</tr>
</table>
</center>

</body>
</html>
