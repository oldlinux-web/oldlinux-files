<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group's rhtm tool v1.2.1 -->
<!-- Copyright (c) 2001 The Open Group, All Rights Reserved -->
<title>sigaltstack</title>
</head>
<body bgcolor="white">
<script type="text/javascript" language="JavaScript" src="../jscript/codes.js">
</script>

<basefont size="3"> <a name="sigaltstack"></a> <a name="tag_03_682"></a><!-- sigaltstack -->
 <!--header start-->
<center><font size="2">The Open Group Base Specifications Issue 6<br>
IEEE Std 1003.1-2001<br>
Copyright &copy; 2001 The IEEE and The Open Group, All Rights reserved.</font></center>

<!--header end-->
<hr size="2" noshade>
<h4><a name="tag_03_682_01"></a>NAME</h4>

<blockquote>sigaltstack - set and get signal alternate stack context</blockquote>

<h4><a name="tag_03_682_02"></a>SYNOPSIS</h4>

<blockquote class="synopsis">
<div class="box"><code><tt><sup>[<a href="javascript:open_code('XSI')">XSI</a>]</sup> <img src="../images/opt-start.gif" alt=
"[Option Start]" border="0"> #include &lt;<a href="../basedefs/signal.h.html">signal.h</a>&gt;<br>
<br>
 int sigaltstack(const stack_t *restrict</tt> <i>ss</i><tt>, stack_t *restrict</tt> <i>oss</i><tt>); <img src=
"../images/opt-end.gif" alt="[Option End]" border="0"></tt></code></div>

<tt><br>
</tt></blockquote>

<h4><a name="tag_03_682_03"></a>DESCRIPTION</h4>

<blockquote>
<p>The <i>sigaltstack</i>() function allows a process to define and examine the state of an alternate stack for signal handlers.
Signals that have been explicitly declared to execute on the alternate stack shall be delivered on the alternate stack.</p>

<p>If <i>ss</i> is not a null pointer, it points to a <b>stack_t</b> structure that specifies the alternate signal stack that shall
take effect upon return from <i>sigaltstack</i>(). The <i>ss_flags</i> member specifies the new stack state. If it is set to
SS_DISABLE, the stack is disabled and <i>ss_sp</i> and <i>ss_size</i> are ignored. Otherwise, the stack shall be enabled, and the
<i>ss_sp</i> and <i>ss_size</i> members specify the new address and size of the stack.</p>

<p>The range of addresses starting at <i>ss_sp</i> up to but not including <i>ss_sp</i>+ <i>ss_size</i> is available to the
implementation for use as the stack. This function makes no assumptions regarding which end is the stack base and in which
direction the stack grows as items are pushed.</p>

<p>If <i>oss</i> is not a null pointer, on successful completion it shall point to a <b>stack_t</b> structure that specifies the
alternate signal stack that was in effect prior to the call to <i>sigaltstack</i>(). The <i>ss_sp</i> and <i>ss_size</i> members
specify the address and size of that stack. The <i>ss_flags</i> member specifies the stack's state, and may contain one of the
following values:</p>

<dl compact>
<dt>SS_ONSTACK</dt>

<dd>The process is currently executing on the alternate signal stack. Attempts to modify the alternate signal stack while the
process is executing on it fail. This flag shall not be modified by processes.</dd>

<dt>SS_DISABLE</dt>

<dd>The alternate signal stack is currently disabled.</dd>
</dl>

<p>The value SIGSTKSZ is a system default specifying the number of bytes that would be used to cover the usual case when manually
allocating an alternate stack area. The value MINSIGSTKSZ is defined to be the minimum stack size for a signal handler. In
computing an alternate stack size, a program should add that amount to its stack requirements to allow for the system
implementation overhead. The constants SS_ONSTACK, SS_DISABLE, SIGSTKSZ, and MINSIGSTKSZ are defined in <a href=
"../basedefs/signal.h.html"><i>&lt;signal.h&gt;</i></a>.</p>

<p>After a successful call to one of the <i><a href="../functions/exec.html">exec</a></i> functions, there are no alternate signal
stacks in the new process image.</p>

<p>In some implementations, a signal (whether or not indicated to execute on the alternate stack) shall always execute on the
alternate stack if it is delivered while another signal is being caught using the alternate stack.</p>

<p>Use of this function by library threads that are not bound to kernel-scheduled entities results in undefined behavior.</p>
</blockquote>

<h4><a name="tag_03_682_04"></a>RETURN VALUE</h4>

<blockquote>
<p>Upon successful completion, <i>sigaltstack</i>() shall return 0; otherwise, it shall return -1 and set <i>errno</i> to indicate
the error.</p>
</blockquote>

<h4><a name="tag_03_682_05"></a>ERRORS</h4>

<blockquote>
<p>The <i>sigaltstack</i>() function shall fail if:</p>

<dl compact>
<dt>[EINVAL]</dt>

<dd>The <i>ss</i> argument is not a null pointer, and the <i>ss_flags</i> member pointed to by <i>ss</i> contains flags other than
SS_DISABLE.</dd>

<dt>[ENOMEM]</dt>

<dd>The size of the alternate stack area is less than MINSIGSTKSZ.</dd>

<dt>[EPERM]</dt>

<dd>An attempt was made to modify an active stack.</dd>
</dl>
</blockquote>

<hr>
<div class="box"><em>The following sections are informative.</em></div>

<h4><a name="tag_03_682_06"></a>EXAMPLES</h4>

<blockquote>
<h5><a name="tag_03_682_06_01"></a>Allocating Memory for an Alternate Stack</h5>

<p>The following example illustrates a method for allocating memory for an alternate stack.</p>

<pre>
<tt>#include &lt;signal.h&gt;
...
if ((sigstk.ss_sp = malloc(SIGSTKSZ)) == NULL)
    /* Error return. */
sigstk.ss_size = SIGSTKSZ;
sigstk.ss_flags = 0;
if (sigaltstack(&amp;sigstk,(stack_t *)0) &lt; 0)
    perror("sigaltstack");
</tt>
</pre>
</blockquote>

<h4><a name="tag_03_682_07"></a>APPLICATION USAGE</h4>

<blockquote>
<p>On some implementations, stack space is automatically extended as needed. On those implementations, automatic extension is
typically not available for an alternate stack. If the stack overflows, the behavior is undefined.</p>
</blockquote>

<h4><a name="tag_03_682_08"></a>RATIONALE</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4><a name="tag_03_682_09"></a>FUTURE DIRECTIONS</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4><a name="tag_03_682_10"></a>SEE ALSO</h4>

<blockquote>
<p><a href="xsh_chap02_04.html#tag_02_04"><i>Signal Concepts</i></a> , <a href="sigaction.html"><i>sigaction</i>()</a> , <a href=
"sigsetjmp.html"><i>sigsetjmp</i>()</a> , the Base Definitions volume of IEEE&nbsp;Std&nbsp;1003.1-2001, <a href=
"../basedefs/signal.h.html"><i>&lt;signal.h&gt;</i></a></p>
</blockquote>

<h4><a name="tag_03_682_11"></a>CHANGE HISTORY</h4>

<blockquote>
<p>First released in Issue 4, Version 2.</p>
</blockquote>

<h4><a name="tag_03_682_12"></a>Issue 5</h4>

<blockquote>
<p>Moved from X/OPEN UNIX extension to BASE.</p>

<p>The last sentence of the DESCRIPTION was included as an APPLICATION USAGE note in previous issues.</p>
</blockquote>

<h4><a name="tag_03_682_13"></a>Issue 6</h4>

<blockquote>
<p>The DESCRIPTION is updated to avoid use of the term &quot;must&quot; for application requirements.</p>

<p>The <b>restrict</b> keyword is added to the <i>sigaltstack</i>() prototype for alignment with the ISO/IEC&nbsp;9899:1999
standard.</p>
</blockquote>

<div class="box"><em>End of informative text.</em></div>

<hr>
<hr size="2" noshade>
<center><font size="2"><!--footer start-->
UNIX &reg; is a registered Trademark of The Open Group.<br>
POSIX &reg; is a registered Trademark of The IEEE.<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../utilities/contents.html">XCU</a> | <a href="../functions/contents.html">XSH</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>

<!--footer end-->
<hr size="2" noshade>
</body>
</html>

