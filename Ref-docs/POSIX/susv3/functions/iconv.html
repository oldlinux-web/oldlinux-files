<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group's rhtm tool v1.2.1 -->
<!-- Copyright (c) 2001 The Open Group, All Rights Reserved -->
<title>iconv</title>
</head>
<body bgcolor="white">
<script type="text/javascript" language="JavaScript" src="../jscript/codes.js">
</script>

<basefont size="3"> <a name="iconv"></a> <a name="tag_03_267"></a><!-- iconv -->
 <!--header start-->
<center><font size="2">The Open Group Base Specifications Issue 6<br>
IEEE Std 1003.1-2001<br>
Copyright &copy; 2001 The IEEE and The Open Group, All Rights reserved.</font></center>

<!--header end-->
<hr size="2" noshade>
<h4><a name="tag_03_267_01"></a>NAME</h4>

<blockquote>iconv - codeset conversion function</blockquote>

<h4><a name="tag_03_267_02"></a>SYNOPSIS</h4>

<blockquote class="synopsis">
<div class="box"><code><tt><sup>[<a href="javascript:open_code('XSI')">XSI</a>]</sup> <img src="../images/opt-start.gif" alt=
"[Option Start]" border="0"> #include &lt;<a href="../basedefs/iconv.h.html">iconv.h</a>&gt;<br>
<br>
 size_t iconv(iconv_t</tt> <i>cd</i><tt>, char **restrict</tt> <i>inbuf</i><tt>,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t *restrict</tt> <i>inbytesleft</i><tt>, char **restrict</tt> <i>outbuf</i><tt>,<br>
 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size_t *restrict</tt> <i>outbytesleft</i><tt>); <img src="../images/opt-end.gif" alt=
"[Option End]" border="0"></tt></code></div>

<tt><br>
</tt></blockquote>

<h4><a name="tag_03_267_03"></a>DESCRIPTION</h4>

<blockquote>
<p>The <i>iconv</i>() function shall convert the sequence of characters from one codeset, in the array specified by <i>inbuf</i>,
into a sequence of corresponding characters in another codeset, in the array specified by <i>outbuf</i>. The codesets are those
specified in the <a href="../functions/iconv_open.html"><i>iconv_open</i>()</a> call that returned the conversion descriptor,
<i>cd</i>. The <i>inbuf</i> argument points to a variable that points to the first character in the input buffer and
<i>inbytesleft</i> indicates the number of bytes to the end of the buffer to be converted. The <i>outbuf</i> argument points to a
variable that points to the first available byte in the output buffer and <i>outbytesleft</i> indicates the number of the available
bytes to the end of the buffer.</p>

<p>For state-dependent encodings, the conversion descriptor <i>cd</i> is placed into its initial shift state by a call for which
<i>inbuf</i> is a null pointer, or for which <i>inbuf</i> points to a null pointer. When <i>iconv</i>() is called in this way, and
if <i>outbuf</i> is not a null pointer or a pointer to a null pointer, and <i>outbytesleft</i> points to a positive value,
<i>iconv</i>() shall place, into the output buffer, the byte sequence to change the output buffer to its initial shift state. If
the output buffer is not large enough to hold the entire reset sequence, <i>iconv</i>() shall fail and set <i>errno</i> to [E2BIG].
Subsequent calls with <i>inbuf</i> as other than a null pointer or a pointer to a null pointer cause the conversion to take place
from the current state of the conversion descriptor.</p>

<p>If a sequence of input bytes does not form a valid character in the specified codeset, conversion shall stop after the previous
successfully converted character. If the input buffer ends with an incomplete character or shift sequence, conversion shall stop
after the previous successfully converted bytes. If the output buffer is not large enough to hold the entire converted input,
conversion shall stop just prior to the input bytes that would cause the output buffer to overflow. The variable pointed to by
<i>inbuf</i> shall be updated to point to the byte following the last byte successfully used in the conversion. The value pointed
to by <i>inbytesleft</i> shall be decremented to reflect the number of bytes still not converted in the input buffer. The variable
pointed to by <i>outbuf</i> shall be updated to point to the byte following the last byte of converted output data. The value
pointed to by <i>outbytesleft</i> shall be decremented to reflect the number of bytes still available in the output buffer. For
state-dependent encodings, the conversion descriptor shall be updated to reflect the shift state in effect at the end of the last
successfully converted byte sequence.</p>

<p>If <i>iconv</i>() encounters a character in the input buffer that is valid, but for which an identical character does not exist
in the target codeset, <i>iconv</i>() shall perform an implementation-defined conversion on this character.</p>
</blockquote>

<h4><a name="tag_03_267_04"></a>RETURN VALUE</h4>

<blockquote>
<p>The <i>iconv</i>() function shall update the variables pointed to by the arguments to reflect the extent of the conversion and
return the number of non-identical conversions performed. If the entire string in the input buffer is converted, the value pointed
to by <i>inbytesleft</i> shall be 0. If the input conversion is stopped due to any conditions mentioned above, the value pointed to
by <i>inbytesleft</i> shall be non-zero and <i>errno</i> shall be set to indicate the condition. If an error occurs, <i>iconv</i>()
shall return (<b>size_t</b>)-1 and set <i>errno</i> to indicate the error.</p>
</blockquote>

<h4><a name="tag_03_267_05"></a>ERRORS</h4>

<blockquote>
<p>The <i>iconv</i>() function shall fail if:</p>

<dl compact>
<dt>[EILSEQ]</dt>

<dd>Input conversion stopped due to an input byte that does not belong to the input codeset.</dd>

<dt>[E2BIG]</dt>

<dd>Input conversion stopped due to lack of space in the output buffer.</dd>

<dt>[EINVAL]</dt>

<dd>Input conversion stopped due to an incomplete character or shift sequence at the end of the input buffer.</dd>
</dl>

<p>The <i>iconv</i>() function may fail if:</p>

<dl compact>
<dt>[EBADF]</dt>

<dd>The <i>cd</i> argument is not a valid open conversion descriptor.</dd>
</dl>
</blockquote>

<hr>
<div class="box"><em>The following sections are informative.</em></div>

<h4><a name="tag_03_267_06"></a>EXAMPLES</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4><a name="tag_03_267_07"></a>APPLICATION USAGE</h4>

<blockquote>
<p>The <i>inbuf</i> argument indirectly points to the memory area which contains the conversion input data. The <i>outbuf</i>
argument indirectly points to the memory area which is to contain the result of the conversion. The objects indirectly pointed to
by <i>inbuf</i> and <i>outbuf</i> are not restricted to containing data that is directly representable in the ISO&nbsp;C standard
language <b>char</b> data type. The type of <i>inbuf</i> and <i>outbuf</i>, <b>char **</b>, does not imply that the objects pointed
to are interpreted as null-terminated C strings or arrays of characters. Any interpretation of a byte sequence that represents a
character in a given character set encoding scheme is done internally within the codeset converters. For example, the area pointed
to indirectly by <i>inbuf</i> and/or <i>outbuf</i> can contain all zero octets that are not interpreted as string terminators but
as coded character data according to the respective codeset encoding scheme. The type of the data ( <b>char</b>, <b>short</b>,
<b>long</b>, and so on) read or stored in the objects is not specified, but may be inferred for both the input and output data by
the converters determined by the <i>fromcode</i> and <i>tocode</i> arguments of <a href=
"../functions/iconv_open.html"><i>iconv_open</i>()</a>.</p>

<p>Regardless of the data type inferred by the converter, the size of the remaining space in both input and output objects (the
<i>intbytesleft</i> and <i>outbytesleft</i> arguments) is always measured in bytes.</p>

<p>For implementations that support the conversion of state-dependent encodings, the conversion descriptor must be able to
accurately reflect the shift-state in effect at the end of the last successful conversion. It is not required that the conversion
descriptor itself be updated, which would require it to be a pointer type. Thus, implementations are free to implement the
descriptor as a handle (other than a pointer type) by which the conversion information can be accessed and updated.</p>
</blockquote>

<h4><a name="tag_03_267_08"></a>RATIONALE</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4><a name="tag_03_267_09"></a>FUTURE DIRECTIONS</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4><a name="tag_03_267_10"></a>SEE ALSO</h4>

<blockquote>
<p><a href="iconv_open.html"><i>iconv_open</i>()</a> , <a href="iconv_close.html"><i>iconv_close</i>()</a> , the Base Definitions
volume of IEEE&nbsp;Std&nbsp;1003.1-2001, <a href="../basedefs/iconv.h.html"><i>&lt;iconv.h&gt;</i></a></p>
</blockquote>

<h4><a name="tag_03_267_11"></a>CHANGE HISTORY</h4>

<blockquote>
<p>First released in Issue 4. Derived from the HP-UX Manual.</p>
</blockquote>

<h4><a name="tag_03_267_12"></a>Issue 6</h4>

<blockquote>
<p>The SYNOPSIS has been corrected to align with the <a href="../basedefs/iconv.h.html"><i>&lt;iconv.h&gt;</i></a> reference
page.</p>

<p>The <b>restrict</b> keyword is added to the <i>iconv</i>() prototype for alignment with the ISO/IEC&nbsp;9899:1999 standard.</p>
</blockquote>

<div class="box"><em>End of informative text.</em></div>

<hr>
<hr size="2" noshade>
<center><font size="2"><!--footer start-->
UNIX &reg; is a registered Trademark of The Open Group.<br>
POSIX &reg; is a registered Trademark of The IEEE.<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../utilities/contents.html">XCU</a> | <a href="../functions/contents.html">XSH</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>

<!--footer end-->
<hr size="2" noshade>
</body>
</html>

