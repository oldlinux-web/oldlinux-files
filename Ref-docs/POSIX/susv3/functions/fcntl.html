<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<meta name="generator" content="HTML Tidy, see www.w3.org">
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<link type="text/css" rel="stylesheet" href="style.css"><!-- Generated by The Open Group's rhtm tool v1.2.1 -->
<!-- Copyright (c) 2001 The Open Group, All Rights Reserved -->
<title>fcntl</title>
</head>
<body bgcolor="white">
<script type="text/javascript" language="JavaScript" src="../jscript/codes.js">
</script>

<basefont size="3"> <a name="fcntl"></a> <a name="tag_03_141"></a><!-- fcntl -->
 <!--header start-->
<center><font size="2">The Open Group Base Specifications Issue 6<br>
IEEE Std 1003.1-2001<br>
Copyright &copy; 2001 The IEEE and The Open Group, All Rights reserved.</font></center>

<!--header end-->
<hr size="2" noshade>
<h4><a name="tag_03_141_01"></a>NAME</h4>

<blockquote>fcntl - file control</blockquote>

<h4><a name="tag_03_141_02"></a>SYNOPSIS</h4>

<blockquote class="synopsis">
<div class="box"><code><tt><sup>[<a href="javascript:open_code('OH')">OH</a>]</sup> <img src="../images/opt-start.gif" alt=
"[Option Start]" border="0"> #include &lt;unistd.h&gt; <img src="../images/opt-end.gif" alt="[Option End]" border="0"></tt></code></div>

<tt><br>
 #include &lt;<a href="../basedefs/fcntl.h.html">fcntl.h</a>&gt;<br>
<br>
 int fcntl(int</tt> <i>fildes</i><tt>, int</tt> <i>cmd</i><tt>, ...);<br>
</tt></blockquote>

<h4><a name="tag_03_141_03"></a>DESCRIPTION</h4>

<blockquote>
<p>The <i>fcntl</i>() function shall perform the operations described below on open files. The <i>fildes</i> argument is a file
descriptor.</p>

<p>The available values for <i>cmd</i> are defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a> and are as
follows:</p>

<dl compact>
<dt>F_DUPFD</dt>

<dd>Return a new file descriptor which shall be the lowest numbered available (that is, not already open) file descriptor greater
than or equal to the third argument, <i>arg</i>, taken as an integer of type <b>int</b>. The new file descriptor shall refer to the
same open file description as the original file descriptor, and shall share any locks. The FD_CLOEXEC flag associated with the new
file descriptor shall be cleared to keep the file open across calls to one of the <i><a href="../functions/exec.html">exec</a></i>
functions.</dd>

<dt>F_GETFD</dt>

<dd>Get the file descriptor flags defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a> that are associated with
the file descriptor <i>fildes</i>. File descriptor flags are associated with a single file descriptor and do not affect other file
descriptors that refer to the same file.</dd>

<dt>F_SETFD</dt>

<dd>Set the file descriptor flags defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>, that are associated
with <i>fildes</i>, to the third argument, <i>arg</i>, taken as type <b>int</b>. If the FD_CLOEXEC flag in the third argument is 0,
the file shall remain open across the <i><a href="../functions/exec.html">exec</a></i> functions; otherwise, the file shall be
closed upon successful execution of one of the <i><a href="../functions/exec.html">exec</a></i> functions.</dd>

<dt>F_GETFL</dt>

<dd>Get the file status flags and file access modes, defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>, for
the file description associated with <i>fildes</i>. The file access modes can be extracted from the return value using the mask
O_ACCMODE, which is defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>. File status flags and file access
modes are associated with the file description and do not affect other file descriptors that refer to the same file with different
open file descriptions.</dd>

<dt>F_SETFL</dt>

<dd>Set the file status flags, defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>, for the file description
associated with <i>fildes</i> from the corresponding bits in the third argument, <i>arg</i>, taken as type <b>int</b>. Bits
corresponding to the file access mode and the file creation flags, as defined in <a href=
"../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>, that are set in <i>arg</i> shall be ignored. If any bits in <i>arg</i> other
than those mentioned here are changed by the application, the result is unspecified.</dd>

<dt>F_GETOWN</dt>

<dd>If <i>fildes</i> refers to a socket, get the process or process group ID specified to receive SIGURG signals when out-of-band
data is available. Positive values indicate a process ID; negative values, other than -1, indicate a process group ID. If
<i>fildes</i> does not refer to a socket, the results are unspecified.</dd>

<dt>F_SETOWN</dt>

<dd>If <i>fildes</i> refers to a socket, set the process or process group ID specified to receive SIGURG signals when out-of-band
data is available, using the value of the third argument, <i>arg</i>, taken as type <b>int</b>. Positive values indicate a process
ID; negative values, other than -1, indicate a process group ID. If <i>fildes</i> does not refer to a socket, the results are
unspecified.</dd>
</dl>

<p>The following values for <i>cmd</i> are available for advisory record locking. Record locking shall be supported for regular
files, and may be supported for other files.</p>

<dl compact>
<dt>F_GETLK</dt>

<dd>Get the first lock which blocks the lock description pointed to by the third argument, <i>arg</i>, taken as a pointer to type
<b>struct flock</b>, defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>. The information retrieved shall
overwrite the information passed to <i>fcntl</i>() in the structure <b>flock</b>. If no lock is found that would prevent this lock
from being created, then the structure shall be left unchanged except for the lock type which shall be set to F_UNLCK.</dd>

<dt>F_SETLK</dt>

<dd>Set or clear a file segment lock according to the lock description pointed to by the third argument, <i>arg</i>, taken as a
pointer to type <b>struct flock</b>, defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>. F_SETLK can
establish shared (or read) locks (F_RDLCK) or exclusive (or write) locks (F_WRLCK), as well as to remove either type of lock
(F_UNLCK). F_RDLCK, F_WRLCK, and F_UNLCK are defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>. If a shared
or exclusive lock cannot be set, <i>fcntl</i>() shall return immediately with a return value of -1.</dd>

<dt>F_SETLKW</dt>

<dd>This command shall be equivalent to F_SETLK except that if a shared or exclusive lock is blocked by other locks, the thread
shall wait until the request can be satisfied. If a signal that is to be caught is received while <i>fcntl</i>() is waiting for a
region, <i>fcntl</i>() shall be interrupted. Upon return from the signal handler, <i>fcntl</i>() shall return -1 with <i>errno</i>
set to [EINTR], and the lock operation shall not be done.</dd>
</dl>

<p>Additional implementation-defined values for <i>cmd</i> may be defined in <a href=
"../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>. Their names shall start with F_.</p>

<p>When a shared lock is set on a segment of a file, other processes shall be able to set shared locks on that segment or a portion
of it. A shared lock prevents any other process from setting an exclusive lock on any portion of the protected area. A request for
a shared lock shall fail if the file descriptor was not opened with read access.</p>

<p>An exclusive lock shall prevent any other process from setting a shared lock or an exclusive lock on any portion of the
protected area. A request for an exclusive lock shall fail if the file descriptor was not opened with write access.</p>

<p>The structure <b>flock</b> describes the type ( <i>l_type</i>), starting offset ( <i>l_whence</i>), relative offset (
<i>l_start</i>), size ( <i>l_len</i>), and process ID ( <i>l_pid</i>) of the segment of the file to be affected.</p>

<p>The value of <i>l_whence</i> is SEEK_SET, SEEK_CUR, or SEEK_END, to indicate that the relative offset <i>l_start</i> bytes shall
be measured from the start of the file, current position, or end of the file, respectively. The value of <i>l_len</i> is the number
of consecutive bytes to be locked. The value of <i>l_len</i> may be negative (where the definition of <b>off_t</b> permits negative
values of <i>l_len</i>). The <i>l_pid</i> field is only used with F_GETLK to return the process ID of the process holding a
blocking lock. After a successful F_GETLK request, when a blocking lock is found, the values returned in the <b>flock</b> structure
shall be as follows:</p>

<dl compact>
<dt><i>l_type</i></dt>

<dd>Type of blocking lock found.</dd>

<dt><i>l_whence</i></dt>

<dd>SEEK_SET.</dd>

<dt><i>l_start</i></dt>

<dd>Start of the blocking lock.</dd>

<dt><i>l_len</i></dt>

<dd>Length of the blocking lock.</dd>

<dt><i>l_pid</i></dt>

<dd>Process ID of the process that holds the blocking lock.</dd>
</dl>

<p>If the command is F_SETLKW and the process must wait for another process to release a lock, then the range of bytes to be locked
shall be determined before the <i>fcntl</i>() function blocks. If the file size or file descriptor seek offset change while
<i>fcntl</i>() is blocked, this shall not affect the range of bytes locked.</p>

<p>If <i>l_len</i> is positive, the area affected shall start at <i>l_start</i> and end at <i>l_start</i>+ <i>l_len</i>-1. If
<i>l_len</i> is negative, the area affected shall start at <i>l_start</i>+ <i>l_len</i> and end at <i>l_start</i>-1. Locks may
start and extend beyond the current end of a file, but shall not extend before the beginning of the file. A lock shall be set to
extend to the largest possible value of the file offset for that file by setting <i>l_len</i> to 0. If such a lock also has
<i>l_start</i> set to 0 and <i>l_whence</i> is set to SEEK_SET, the whole file shall be locked.</p>

<p>There shall be at most one type of lock set for each byte in the file. Before a successful return from an F_SETLK or an F_SETLKW
request when the calling process has previously existing locks on bytes in the region specified by the request, the previous lock
type for each byte in the specified region shall be replaced by the new lock type. As specified above under the descriptions of
shared locks and exclusive locks, an F_SETLK or an F_SETLKW request (respectively) shall fail or block when another process has
existing locks on bytes in the specified region and the type of any of those locks conflicts with the type specified in the
request.</p>

<p>All locks associated with a file for a given process shall be removed when a file descriptor for that file is closed by that
process or the process holding that file descriptor terminates. Locks are not inherited by a child process.</p>

<p>A potential for deadlock occurs if a process controlling a locked region is put to sleep by attempting to lock another process'
locked region. If the system detects that sleeping until a locked region is unlocked would cause a deadlock, <i>fcntl</i>() shall
fail with an [EDEADLK] error.</p>

<p>An unlock (F_UNLCK) request in which <i>l_len</i> is non-zero and the offset of the last byte of the requested segment is the
maximum value for an object of type <b>off_t</b>, when the process has an existing lock in which <i>l_len</i> is 0 and which
includes the last byte of the requested segment, shall be treated as a request to unlock from the start of the requested segment
with an <i>l_len</i> equal to 0. Otherwise, an unlock (F_UNLCK) request shall attempt to unlock only the requested segment.</p>

<p><sup>[<a href="javascript:open_code('SHM')">SHM</a>]</sup> <img src="../images/opt-start.gif" alt="[Option Start]" border="0">
When the file descriptor <i>fildes</i> refers to a shared memory object, the behavior of <i>fcntl</i>() shall be the same as for a
regular file except the effect of the following values for the argument <i>cmd</i> shall be unspecified: F_SETFL, F_GETLK, F_SETLK,
and F_SETLKW. <img src="../images/opt-end.gif" alt="[Option End]" border="0"></p>

<p><sup>[<a href="javascript:open_code('TYM')">TYM</a>]</sup> <img src="../images/opt-start.gif" alt="[Option Start]" border="0">
If <i>fildes</i> refers to a typed memory object, the result of the <i>fcntl</i>() function is unspecified. <img src=
"../images/opt-end.gif" alt="[Option End]" border="0"></p>
</blockquote>

<h4><a name="tag_03_141_04"></a>RETURN VALUE</h4>

<blockquote>
<p>Upon successful completion, the value returned shall depend on <i>cmd</i> as follows:</p>

<dl compact>
<dt>F_DUPFD</dt>

<dd>A new file descriptor.</dd>

<dt>F_GETFD</dt>

<dd>Value of flags defined in <a href="../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>. The return value shall not be
negative.</dd>

<dt>F_SETFD</dt>

<dd>Value other than -1.</dd>

<dt>F_GETFL</dt>

<dd>Value of file status flags and access modes. The return value is not negative.</dd>

<dt>F_SETFL</dt>

<dd>Value other than -1.</dd>

<dt>F_GETLK</dt>

<dd>Value other than -1.</dd>

<dt>F_SETLK</dt>

<dd>Value other than -1.</dd>

<dt>F_SETLKW</dt>

<dd>Value other than -1.</dd>

<dt>F_GETOWN</dt>

<dd>Value of the socket owner process or process group; this will not be -1.</dd>

<dt>F_SETOWN</dt>

<dd>Value other than -1.</dd>
</dl>

<p>Otherwise, -1 shall be returned and <i>errno</i> set to indicate the error.</p>
</blockquote>

<h4><a name="tag_03_141_05"></a>ERRORS</h4>

<blockquote>
<p>The <i>fcntl</i>() function shall fail if:</p>

<dl compact>
<dt>[EACCES] or [EAGAIN]</dt>

<dd><br>
The <i>cmd</i> argument is F_SETLK; the type of lock ( <i>l_type</i>) is a shared (F_RDLCK) or exclusive (F_WRLCK) lock and the
segment of a file to be locked is already exclusive-locked by another process, or the type is an exclusive lock and some portion of
the segment of a file to be locked is already shared-locked or exclusive-locked by another process.</dd>

<dt>[EBADF]</dt>

<dd>The <i>fildes</i> argument is not a valid open file descriptor, or the argument <i>cmd</i> is F_SETLK or F_SETLKW, the type of
lock, <i>l_type</i>, is a shared lock (F_RDLCK), and <i>fildes</i> is not a valid file descriptor open for reading, or the type of
lock, <i>l_type</i>, is an exclusive lock (F_WRLCK), and <i>fildes</i> is not a valid file descriptor open for writing.</dd>

<dt>[EINTR]</dt>

<dd>The <i>cmd</i> argument is F_SETLKW and the function was interrupted by a signal.</dd>

<dt>[EINVAL]</dt>

<dd>The <i>cmd</i> argument is invalid, or the <i>cmd</i> argument is F_DUPFD and <i>arg</i> is negative or greater than or equal
to {OPEN_MAX}, or the <i>cmd</i> argument is F_GETLK, F_SETLK, or F_SETLKW and the data pointed to by <i>arg</i> is not valid, or
<i>fildes</i> refers to a file that does not support locking.</dd>

<dt>[EMFILE]</dt>

<dd>The argument <i>cmd</i> is F_DUPFD and {OPEN_MAX} file descriptors are currently open in the calling process, or no file
descriptors greater than or equal to <i>arg</i> are available.</dd>

<dt>[ENOLCK]</dt>

<dd>The argument <i>cmd</i> is F_SETLK or F_SETLKW and satisfying the lock or unlock request would result in the number of locked
regions in the system exceeding a system-imposed limit.</dd>

<dt>[EOVERFLOW]</dt>

<dd>One of the values to be returned cannot be represented correctly.</dd>

<dt>[EOVERFLOW]</dt>

<dd>The <i>cmd</i> argument is F_GETLK, F_SETLK, or F_SETLKW and the smallest or, if <i>l_len</i> is non-zero, the largest offset
of any byte in the requested segment cannot be represented correctly in an object of type <b>off_t</b>.</dd>
</dl>

<p>The <i>fcntl</i>() function may fail if:</p>

<dl compact>
<dt>[EDEADLK]</dt>

<dd>The <i>cmd</i> argument is F_SETLKW, the lock is blocked by a lock from another process, and putting the calling process to
sleep to wait for that lock to become free would cause a deadlock.</dd>
</dl>
</blockquote>

<hr>
<div class="box"><em>The following sections are informative.</em></div>

<h4><a name="tag_03_141_06"></a>EXAMPLES</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4><a name="tag_03_141_07"></a>APPLICATION USAGE</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4><a name="tag_03_141_08"></a>RATIONALE</h4>

<blockquote>
<p>The ellipsis in the SYNOPSIS is the syntax specified by the ISO&nbsp;C standard for a variable number of arguments. It is used
because System V uses pointers for the implementation of file locking functions.</p>

<p>The <i>arg</i> values to F_GETFD, F_SETFD, F_GETFL, and F_SETFL all represent flag values to allow for future growth.
Applications using these functions should do a read-modify-write operation on them, rather than assuming that only the values
defined by this volume of IEEE&nbsp;Std&nbsp;1003.1-2001 are valid. It is a common error to forget this, particularly in the case
of F_SETFD.</p>

<p>This volume of IEEE&nbsp;Std&nbsp;1003.1-2001 permits concurrent read and write access to file data using the <i>fcntl</i>()
function; this is a change from the 1984 /usr/group standard and early proposals. Without concurrency controls, this feature may
not be fully utilized without occasional loss of data.</p>

<p>Data losses occur in several ways. One case occurs when several processes try to update the same record, without sequencing
controls; several updates may occur in parallel and the last writer &quot;wins&quot;. Another case is a bit-tree or other internal
list-based database that is undergoing reorganization. Without exclusive use to the tree segment by the updating process, other
reading processes chance getting lost in the database when the index blocks are split, condensed, inserted, or deleted. While
<i>fcntl</i>() is useful for many applications, it is not intended to be overly general and does not handle the bit-tree example
well.</p>

<p>This facility is only required for regular files because it is not appropriate for many devices such as terminals and network
connections.</p>

<p>Since <i>fcntl</i>() works with &quot;any file descriptor associated with that file, however it is obtained&quot;, the file descriptor
may have been inherited through a <a href="../functions/fork.html"><i>fork</i>()</a> or <i><a href=
"../functions/exec.html">exec</a></i> operation and thus may affect a file that another process also has open.</p>

<p>The use of the open file description to identify what to lock requires extra calls and presents problems if several processes
are sharing an open file description, but there are too many implementations of the existing mechanism for this volume of
IEEE&nbsp;Std&nbsp;1003.1-2001 to use different specifications.</p>

<p>Another consequence of this model is that closing any file descriptor for a given file (whether or not it is the same open file
description that created the lock) causes the locks on that file to be relinquished for that process. Equivalently, any close for
any file/process pair relinquishes the locks owned on that file for that process. But note that while an open file description may
be shared through <a href="../functions/fork.html"><i>fork</i>()</a>, locks are not inherited through <a href=
"../functions/fork.html"><i>fork</i>()</a>. Yet locks may be inherited through one of the <i><a href=
"../functions/exec.html">exec</a></i> functions.</p>

<p>The identification of a machine in a network environment is outside the scope of this volume of IEEE&nbsp;Std&nbsp;1003.1-2001.
Thus, an <i>l_sysid</i> member, such as found in System V, is not included in the locking structure.</p>

<p>Changing of lock types can result in a previously locked region being split into smaller regions.</p>

<p>Mandatory locking was a major feature of the 1984 /usr/group standard.</p>

<p>For advisory file record locking to be effective, all processes that have access to a file must cooperate and use the advisory
mechanism before doing I/O on the file. Enforcement-mode record locking is important when it cannot be assumed that all processes
are cooperating. For example, if one user uses an editor to update a file at the same time that a second user executes another
process that updates the same file and if only one of the two processes is using advisory locking, the processes are not
cooperating. Enforcement-mode record locking would protect against accidental collisions.</p>

<p>Secondly, advisory record locking requires a process using locking to bracket each I/O operation with lock (or test) and unlock
operations. With enforcement-mode file and record locking, a process can lock the file once and unlock when all I/O operations have
been completed. Enforcement-mode record locking provides a base that can be enhanced; for example, with sharable locks. That is,
the mechanism could be enhanced to allow a process to lock a file so other processes could read it, but none of them could write
it.</p>

<p>Mandatory locks were omitted for several reasons:</p>

<ol>
<li>
<p>Mandatory lock setting was done by multiplexing the set-group-ID bit in most implementations; this was confusing, at best.</p>
</li>

<li>
<p>The relationship to file truncation as supported in 4.2 BSD was not well specified.</p>
</li>

<li>
<p>Any publicly readable file could be locked by anyone. Many historical implementations keep the password database in a publicly
readable file. A malicious user could thus prohibit logins. Another possibility would be to hold open a long-distance telephone
line.</p>
</li>

<li>
<p>Some demand-paged historical implementations offer memory mapped files, and enforcement cannot be done on that type of file.</p>
</li>
</ol>

<p>Since sleeping on a region is interrupted with any signal, <a href="../functions/alarm.html"><i>alarm</i>()</a> may be used to
provide a timeout facility in applications requiring it. This is useful in deadlock detection. Since implementation of full
deadlock detection is not always feasible, the [EDEADLK] error was made optional.</p>
</blockquote>

<h4><a name="tag_03_141_09"></a>FUTURE DIRECTIONS</h4>

<blockquote>
<p>None.</p>
</blockquote>

<h4><a name="tag_03_141_10"></a>SEE ALSO</h4>

<blockquote>
<p><a href="alarm.html"><i>alarm</i>()</a> , <a href="close.html"><i>close</i>()</a> , <a href="exec.html"><i><a href=
"../functions/exec.html">exec</a></i>()</a> , <a href="open.html"><i>open</i>()</a> , <a href=
"sigaction.html"><i>sigaction</i>()</a> , the Base Definitions volume of IEEE&nbsp;Std&nbsp;1003.1-2001, <a href=
"../basedefs/fcntl.h.html"><i>&lt;fcntl.h&gt;</i></a>, <a href="../basedefs/signal.h.html"><i>&lt;signal.h&gt;</i></a>, <a href=
"../basedefs/unistd.h.html"><i>&lt;unistd.h&gt;</i></a></p>
</blockquote>

<h4><a name="tag_03_141_11"></a>CHANGE HISTORY</h4>

<blockquote>
<p>First released in Issue 1. Derived from Issue 1 of the SVID.</p>
</blockquote>

<h4><a name="tag_03_141_12"></a>Issue 5</h4>

<blockquote>
<p>The DESCRIPTION is updated for alignment with the POSIX Realtime Extension and the POSIX Threads Extension.</p>

<p>Large File Summit extensions are added.</p>
</blockquote>

<h4><a name="tag_03_141_13"></a>Issue 6</h4>

<blockquote>
<p>In the SYNOPSIS, the optional include of the <a href="../basedefs/sys/types.h.html"><i>&lt;sys/types.h&gt;</i></a> header is
removed.</p>

<p>The following new requirements on POSIX implementations derive from alignment with the Single UNIX Specification:</p>

<ul>
<li>
<p>The requirement to include <a href="../basedefs/sys/types.h.html"><i>&lt;sys/types.h&gt;</i></a> has been removed. Although <a
href="../basedefs/sys/types.h.html"><i>&lt;sys/types.h&gt;</i></a> was required for conforming implementations of previous POSIX
specifications, it was not required for UNIX applications.</p>
</li>

<li>
<p>In the DESCRIPTION, sentences describing behavior when <i>l_len</i> is negative are now mandated, and the description of unlock
(F_UNLOCK) when <i>l_len</i> is non-negative is mandated.</p>
</li>

<li>
<p>In the ERRORS section, the [EINVAL] error condition has the case mandated when the <i>cmd</i> is invalid, and two [EOVERFLOW]
error conditions are added.</p>
</li>
</ul>

<p>The F_GETOWN and F_SETOWN values are added for sockets.</p>

<p>The following changes were made to align with the IEEE&nbsp;P1003.1a draft standard:</p>

<ul>
<li>
<p>Clarification is added that the extent of the bytes locked is determined prior to the blocking action.</p>
</li>
</ul>

<p>The DESCRIPTION is updated for alignment with IEEE&nbsp;Std&nbsp;1003.1j-2000 by specifying that <i>fcntl</i>() results are
unspecified for typed memory objects.</p>

<p>The DESCRIPTION is updated to avoid use of the term &quot;must&quot; for application requirements.</p>
</blockquote>

<div class="box"><em>End of informative text.</em></div>

<hr>
<hr size="2" noshade>
<center><font size="2"><!--footer start-->
UNIX &reg; is a registered Trademark of The Open Group.<br>
POSIX &reg; is a registered Trademark of The IEEE.<br>
[ <a href="../mindex.html">Main Index</a> | <a href="../basedefs/contents.html">XBD</a> | <a href=
"../utilities/contents.html">XCU</a> | <a href="../functions/contents.html">XSH</a> | <a href="../xrat/contents.html">XRAT</a>
]</font></center>

<!--footer end-->
<hr size="2" noshade>
</body>
</html>

